import { Directive, EventEmitter, HostBinding, HostListener, Input, NgModule, Output, ContentChildren } from '@angular/core';
import { animationFrameScheduler, fromEvent, interval, Subject } from 'rxjs';
import { takeUntil, throttle } from 'rxjs/operators';
import { IgxDefaultDropStrategy } from './drag-drop.strategy';
import * as i0 from "@angular/core";
import * as i1 from "../../core/utils";
var DragScrollDirection;
(function (DragScrollDirection) {
    DragScrollDirection[DragScrollDirection["UP"] = 0] = "UP";
    DragScrollDirection[DragScrollDirection["DOWN"] = 1] = "DOWN";
    DragScrollDirection[DragScrollDirection["LEFT"] = 2] = "LEFT";
    DragScrollDirection[DragScrollDirection["RIGHT"] = 3] = "RIGHT";
})(DragScrollDirection || (DragScrollDirection = {}));
export var DragDirection;
(function (DragDirection) {
    DragDirection[DragDirection["VERTICAL"] = 0] = "VERTICAL";
    DragDirection[DragDirection["HORIZONTAL"] = 1] = "HORIZONTAL";
    DragDirection[DragDirection["BOTH"] = 2] = "BOTH";
})(DragDirection || (DragDirection = {}));
export class IgxDragLocation {
    constructor(_pageX, _pageY) {
        this._pageX = _pageX;
        this._pageY = _pageY;
        this.pageX = parseFloat(_pageX);
        this.pageY = parseFloat(_pageY);
    }
}
export class IgxDragHandleDirective {
    constructor(element) {
        this.element = element;
        this.baseClass = true;
    }
}
IgxDragHandleDirective.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.2.2", ngImport: i0, type: IgxDragHandleDirective, deps: [{ token: i0.ElementRef }], target: i0.ɵɵFactoryTarget.Directive });
IgxDragHandleDirective.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "12.0.0", version: "13.2.2", type: IgxDragHandleDirective, selector: "[igxDragHandle]", host: { properties: { "class.igx-drag__handle": "this.baseClass" } }, ngImport: i0 });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.2.2", ngImport: i0, type: IgxDragHandleDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[igxDragHandle]'
                }]
        }], ctorParameters: function () { return [{ type: i0.ElementRef }]; }, propDecorators: { baseClass: [{
                type: HostBinding,
                args: ['class.igx-drag__handle']
            }] } });
export class IgxDragIgnoreDirective {
    constructor(element) {
        this.element = element;
        this.baseClass = true;
    }
}
IgxDragIgnoreDirective.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.2.2", ngImport: i0, type: IgxDragIgnoreDirective, deps: [{ token: i0.ElementRef }], target: i0.ɵɵFactoryTarget.Directive });
IgxDragIgnoreDirective.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "12.0.0", version: "13.2.2", type: IgxDragIgnoreDirective, selector: "[igxDragIgnore]", host: { properties: { "class.igx-drag__ignore": "this.baseClass" } }, ngImport: i0 });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.2.2", ngImport: i0, type: IgxDragIgnoreDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[igxDragIgnore]'
                }]
        }], ctorParameters: function () { return [{ type: i0.ElementRef }]; }, propDecorators: { baseClass: [{
                type: HostBinding,
                args: ['class.igx-drag__ignore']
            }] } });
export class IgxDragDirective {
    constructor(cdr, element, viewContainer, zone, renderer, platformUtil) {
        this.cdr = cdr;
        this.element = element;
        this.viewContainer = viewContainer;
        this.zone = zone;
        this.renderer = renderer;
        this.platformUtil = platformUtil;
        /**
         * An @Input property that indicates when the drag should start.
         * By default the drag starts after the draggable element is moved by 5px.
         * ```html
         * <div igxDrag [dragTolerance]="100">
         *         <span>Drag Me!</span>
         * </div>
         * ```
         *
         * @memberof IgxDragDirective
         */
        this.dragTolerance = 5;
        /**
         * An @Input property that indicates the directions that the element can be dragged.
         * By default it is set to both horizontal and vertical directions.
         * ```html
         * <div igxDrag [dragDirection]="dragDir">
         *         <span>Drag Me!</span>
         * </div>
         * ```
         * ```typescript
         * public dragDir = DragDirection.HORIZONTAL;
         * ```
         *
         * @memberof IgxDragDirective
         */
        this.dragDirection = DragDirection.BOTH;
        /**
         * An @Input property that specifies if the base element should not be moved and a ghost element should be rendered that represents it.
         * By default it is set to `true`.
         * If it is set to `false` when dragging the base element is moved instead and no ghost elements are rendered.
         * ```html
         * <div igxDrag [ghost]="false">
         *      <span>Drag Me!</span>
         * </div>
         * ```
         *
         * @memberof IgxDragDirective
         */
        this.ghost = true;
        /**
         * Sets a custom class that will be added to the `ghostElement` element.
         * ```html
         * <div igxDrag [ghostClass]="'ghostElement'">
         *         <span>Drag Me!</span>
         * </div>
         * ```
         *
         * @memberof IgxDragDirective
         */
        this.ghostClass = '';
        /**
         * An @Input assigning a scroll container to the dragged element. By default its the window.
         */
        this.scrollContainer = null;
        /**
         * Event triggered when the draggable element drag starts.
         * ```html
         * <div igxDrag (dragStart)="onDragStart()">
         *         <span>Drag Me!</span>
         * </div>
         * ```
         * ```typescript
         * public onDragStart(){
         *      alert("The drag has stared!");
         * }
         * ```
         *
         * @memberof IgxDragDirective
         */
        this.dragStart = new EventEmitter();
        /**
         * Event triggered when the draggable element has been moved.
         * ```html
         * <div igxDrag  (dragMove)="onDragMove()">
         *         <span>Drag Me!</span>
         * </div>
         * ```
         * ```typescript
         * public onDragMove(){
         *      alert("The element has moved!");
         * }
         * ```
         *
         * @memberof IgxDragDirective
         */
        this.dragMove = new EventEmitter();
        /**
         * Event triggered when the draggable element is released.
         * ```html
         * <div igxDrag (dragEnd)="onDragEnd()">
         *         <span>Drag Me!</span>
         * </div>
         * ```
         * ```typescript
         * public onDragEnd(){
         *      alert("The drag has ended!");
         * }
         * ```
         *
         * @memberof IgxDragDirective
         */
        this.dragEnd = new EventEmitter();
        /**
         * Event triggered when the draggable element is clicked.
         * ```html
         * <div igxDrag (dragClick)="onDragClick()">
         *         <span>Drag Me!</span>
         * </div>
         * ```
         * ```typescript
         * public onDragClick(){
         *      alert("The element has been clicked!");
         * }
         * ```
         *
         * @memberof IgxDragDirective
         */
        this.dragClick = new EventEmitter();
        /**
         * Event triggered when the drag ghost element is created.
         * ```html
         * <div igxDrag (ghostCreate)="ghostCreated()">
         *         <span>Drag Me!</span>
         * </div>
         * ```
         * ```typescript
         * public ghostCreated(){
         *      alert("The ghost has been created!");
         * }
         * ```
         *
         * @memberof IgxDragDirective
         */
        this.ghostCreate = new EventEmitter();
        /**
         * Event triggered when the drag ghost element is created.
         * ```html
         * <div igxDrag (ghostDestroy)="ghostDestroyed()">
         *         <span>Drag Me!</span>
         * </div>
         * ```
         * ```typescript
         * public ghostDestroyed(){
         *      alert("The ghost has been destroyed!");
         * }
         * ```
         *
         * @memberof IgxDragDirective
         */
        this.ghostDestroy = new EventEmitter();
        /**
         * Event triggered after the draggable element is released and after its animation has finished.
         * ```html
         * <div igxDrag (transitioned)="onMoveEnd()">
         *         <span>Drag Me!</span>
         * </div>
         * ```
         * ```typescript
         * public onMoveEnd(){
         *      alert("The move has ended!");
         * }
         * ```
         *
         * @memberof IgxDragDirective
         */
        this.transitioned = new EventEmitter();
        /**
         * @hidden
         */
        this.baseClass = true;
        /**
         * @hidden
         */
        this.selectDisabled = false;
        /**
         * @hidden
         */
        this.defaultReturnDuration = '0.5s';
        /**
         * @hidden
         */
        this.animInProgress = false;
        this.ghostContext = null;
        this._startX = 0;
        this._startY = 0;
        this._lastX = 0;
        this._lastY = 0;
        this._dragStarted = false;
        this._ghostHostX = 0;
        this._ghostHostY = 0;
        this._pointerDownId = null;
        this._clicked = false;
        this._lastDropArea = null;
        this._destroy = new Subject();
        this._removeOnDestroy = true;
        this._scrollContainer = null;
        this._originalScrollContainerWidth = 0;
        this._originalScrollContainerHeight = 0;
        this._scrollContainerStep = 5;
        this._scrollContainerStepMs = 10;
        this._scrollContainerThreshold = 25;
        this._containerScrollIntervalId = null;
    }
    /**
     * - Save data inside the `igxDrag` directive. This can be set when instancing `igxDrag` on an element.
     * ```html
     * <div [igxDrag]="{ source: myElement }"></div>
     * ```
     *
     * @memberof IgxDragDirective
     */
    set data(value) {
        this._data = value;
    }
    get data() {
        return this._data;
    }
    /**
     * Gets the current location of the element relative to the page.
     */
    get location() {
        return new IgxDragLocation(this.pageX, this.pageY);
    }
    /**
     * Gets the original location of the element before dragging started.
     */
    get originLocation() {
        return new IgxDragLocation(this.baseOriginLeft, this.baseOriginTop);
    }
    /**
     * @hidden
     */
    get pointerEventsEnabled() {
        return typeof PointerEvent !== 'undefined';
    }
    /**
     * @hidden
     */
    get touchEventsEnabled() {
        return 'ontouchstart' in window;
    }
    /**
     * @hidden
     */
    get pageX() {
        if (this.ghost && this.ghostElement) {
            return this.ghostLeft;
        }
        return this.baseLeft + this.windowScrollLeft;
    }
    /**
     * @hidden
     */
    get pageY() {
        if (this.ghost && this.ghostElement) {
            return this.ghostTop;
        }
        return this.baseTop + this.windowScrollTop;
    }
    get baseLeft() {
        return this.element.nativeElement.getBoundingClientRect().left;
    }
    get baseTop() {
        return this.element.nativeElement.getBoundingClientRect().top;
    }
    get baseOriginLeft() {
        return this.baseLeft - this.getTransformX(this.element.nativeElement);
    }
    get baseOriginTop() {
        return this.baseTop - this.getTransformY(this.element.nativeElement);
    }
    set ghostLeft(pageX) {
        if (this.ghostElement) {
            // We need to take into account marginLeft, since top style does not include margin, but pageX includes the margin.
            const ghostMarginLeft = parseInt(document.defaultView.getComputedStyle(this.ghostElement)['margin-left'], 10);
            // If ghost host is defined it needs to be taken into account.
            this.ghostElement.style.left = (pageX - ghostMarginLeft - this._ghostHostX) + 'px';
        }
    }
    get ghostLeft() {
        return parseInt(this.ghostElement.style.left, 10) + this._ghostHostX;
    }
    set ghostTop(pageY) {
        if (this.ghostElement) {
            // We need to take into account marginTop, since top style does not include margin, but pageY includes the margin.
            const ghostMarginTop = parseInt(document.defaultView.getComputedStyle(this.ghostElement)['margin-top'], 10);
            // If ghost host is defined it needs to be taken into account.
            this.ghostElement.style.top = (pageY - ghostMarginTop - this._ghostHostY) + 'px';
        }
    }
    get ghostTop() {
        return parseInt(this.ghostElement.style.top, 10) + this._ghostHostY;
    }
    get windowScrollTop() {
        return document.documentElement.scrollTop || window.scrollY;
    }
    get windowScrollLeft() {
        return document.documentElement.scrollLeft || window.scrollX;
    }
    get windowScrollHeight() {
        return document.documentElement.scrollHeight;
    }
    get windowScrollWidth() {
        return document.documentElement.scrollWidth;
    }
    /**
     * An @Input property that specifies the offset of the dragged element relative to the mouse in pixels.
     * By default it's taking the relative position to the mouse when the drag started and keeps it the same.
     * ```html
     * <div #hostDiv></div>
     * <div igxDrag [ghostOffsetX]="0">
     *         <span>Drag Me!</span>
     * </div>
     * ```
     *
     * @memberof IgxDragDirective
     */
    set ghostOffsetX(value) {
        this._offsetX = parseInt(value, 10);
    }
    get ghostOffsetX() {
        return this._offsetX !== undefined ? this._offsetX : this._defaultOffsetX;
    }
    /**
     * An @Input property that specifies the offset of the dragged element relative to the mouse in pixels.
     * By default it's taking the relative position to the mouse when the drag started and keeps it the same.
     * ```html
     * <div #hostDiv></div>
     * <div igxDrag [ghostOffsetY]="0">
     *         <span>Drag Me!</span>
     * </div>
     * ```
     *
     * @memberof IgxDragDirective
     */
    set ghostOffsetY(value) {
        this._offsetY = parseInt(value, 10);
    }
    get ghostOffsetY() {
        return this._offsetY !== undefined ? this._offsetY : this._defaultOffsetY;
    }
    /**
     * @hidden
     */
    ngAfterContentInit() {
        if (!this.dragHandles || !this.dragHandles.length) {
            // Set user select none to the whole draggable element if no drag handles are defined.
            this.selectDisabled = true;
        }
        // Bind events
        this.zone.runOutsideAngular(() => {
            if (!this.platformUtil.isBrowser) {
                return;
            }
            const targetElements = this.dragHandles && this.dragHandles.length ?
                this.dragHandles.map((item) => item.element.nativeElement) : [this.element.nativeElement];
            targetElements.forEach((element) => {
                if (this.pointerEventsEnabled) {
                    fromEvent(element, 'pointerdown').pipe(takeUntil(this._destroy))
                        .subscribe((res) => this.onPointerDown(res));
                    fromEvent(element, 'pointermove').pipe(throttle(() => interval(0, animationFrameScheduler)), takeUntil(this._destroy)).subscribe((res) => this.onPointerMove(res));
                    fromEvent(element, 'pointerup').pipe(takeUntil(this._destroy))
                        .subscribe((res) => this.onPointerUp(res));
                    if (!this.ghost) {
                        // Do not bind `lostpointercapture` to the target, because we will bind it on the ghost later.
                        fromEvent(element, 'lostpointercapture').pipe(takeUntil(this._destroy))
                            .subscribe((res) => this.onPointerLost(res));
                    }
                }
                else if (this.touchEventsEnabled) {
                    fromEvent(element, 'touchstart').pipe(takeUntil(this._destroy))
                        .subscribe((res) => this.onPointerDown(res));
                }
                else {
                    // We don't have pointer events and touch events. Use then mouse events.
                    fromEvent(element, 'mousedown').pipe(takeUntil(this._destroy))
                        .subscribe((res) => this.onPointerDown(res));
                }
            });
            // We should bind to document events only once when there are no pointer events.
            if (!this.pointerEventsEnabled && this.touchEventsEnabled) {
                fromEvent(document.defaultView, 'touchmove').pipe(throttle(() => interval(0, animationFrameScheduler)), takeUntil(this._destroy)).subscribe((res) => this.onPointerMove(res));
                fromEvent(document.defaultView, 'touchend').pipe(takeUntil(this._destroy))
                    .subscribe((res) => this.onPointerUp(res));
            }
            else if (!this.pointerEventsEnabled) {
                fromEvent(document.defaultView, 'mousemove').pipe(throttle(() => interval(0, animationFrameScheduler)), takeUntil(this._destroy)).subscribe((res) => this.onPointerMove(res));
                fromEvent(document.defaultView, 'mouseup').pipe(takeUntil(this._destroy))
                    .subscribe((res) => this.onPointerUp(res));
            }
            this.element.nativeElement.addEventListener('transitionend', (args) => {
                this.onTransitionEnd(args);
            });
        });
        // Set transition duration to 0s. This also helps with setting `visibility: hidden` to the base to not lag.
        this.element.nativeElement.style.transitionDuration = '0.0s';
    }
    /**
     * @hidden
     */
    ngOnDestroy() {
        this._destroy.next(true);
        this._destroy.complete();
        if (this.ghost && this.ghostElement && this._removeOnDestroy) {
            this.ghostElement.parentNode.removeChild(this.ghostElement);
            this.ghostElement = null;
            if (this._dynamicGhostRef) {
                this._dynamicGhostRef.destroy();
                this._dynamicGhostRef = null;
            }
        }
        if (this._containerScrollIntervalId) {
            clearInterval(this._containerScrollIntervalId);
            this._containerScrollIntervalId = null;
        }
    }
    /**
     * Sets desired location of the base element or ghost element if rended relative to the document.
     *
     * @param newLocation New location that should be applied. It is advised to get new location using getBoundingClientRects() + scroll.
     */
    setLocation(newLocation) {
        // We do not subtract marginLeft and marginTop here because here we calculate deltas.
        if (this.ghost && this.ghostElement) {
            const offsetHostX = this.ghostHost ? this.ghostHostOffsetLeft(this.ghostHost) : 0;
            const offsetHostY = this.ghostHost ? this.ghostHostOffsetTop(this.ghostHost) : 0;
            this.ghostLeft = newLocation.pageX - offsetHostX + this.windowScrollLeft;
            this.ghostTop = newLocation.pageY - offsetHostY + this.windowScrollTop;
        }
        else if (!this.ghost) {
            const deltaX = newLocation.pageX - this.pageX;
            const deltaY = newLocation.pageY - this.pageY;
            const transformX = this.getTransformX(this.element.nativeElement);
            const transformY = this.getTransformY(this.element.nativeElement);
            this.setTransformXY(transformX + deltaX, transformY + deltaY);
        }
        this._startX = this.baseLeft;
        this._startY = this.baseTop;
    }
    /**
     * Animates the base or ghost element depending on the `ghost` input to its initial location.
     * If `ghost` is true but there is not ghost rendered, it will be created and animated.
     * If the base element has changed its DOM position its initial location will be changed accordingly.
     *
     * @param customAnimArgs Custom transition properties that will be applied when performing the transition.
     * @param startLocation Start location from where the transition should start.
     */
    transitionToOrigin(customAnimArgs, startLocation) {
        if ((!!startLocation && startLocation.pageX === this.baseOriginLeft && startLocation.pageY === this.baseOriginLeft) ||
            (!startLocation && this.ghost && !this.ghostElement)) {
            return;
        }
        if (!!startLocation && startLocation.pageX !== this.pageX && startLocation.pageY !== this.pageY) {
            if (this.ghost && !this.ghostElement) {
                this._startX = startLocation.pageX;
                this._startY = startLocation.pageY;
                this._ghostStartX = this._startX;
                this._ghostStartY = this._startY;
                this.createGhost(this._startX, this._startY);
            }
            this.setLocation(startLocation);
        }
        this.animInProgress = true;
        // Use setTimeout because we need to be sure that the element is positioned first correctly if there is start location.
        setTimeout(() => {
            if (this.ghost) {
                this.ghostElement.style.transitionProperty = 'top, left';
                this.ghostElement.style.transitionDuration =
                    customAnimArgs && customAnimArgs.duration ? customAnimArgs.duration + 's' : this.defaultReturnDuration;
                this.ghostElement.style.transitionTimingFunction =
                    customAnimArgs && customAnimArgs.timingFunction ? customAnimArgs.timingFunction : '';
                this.ghostElement.style.transitionDelay = customAnimArgs && customAnimArgs.delay ? customAnimArgs.delay + 's' : '';
                this.setLocation(new IgxDragLocation(this.baseLeft, this.baseTop));
            }
            else if (!this.ghost) {
                this.element.nativeElement.style.transitionProperty = 'transform';
                this.element.nativeElement.style.transitionDuration =
                    customAnimArgs && customAnimArgs.duration ? customAnimArgs.duration + 's' : this.defaultReturnDuration;
                this.element.nativeElement.style.transitionTimingFunction =
                    customAnimArgs && customAnimArgs.timingFunction ? customAnimArgs.timingFunction : '';
                this.element.nativeElement.style.transitionDelay = customAnimArgs && customAnimArgs.delay ? customAnimArgs.delay + 's' : '';
                this._startX = this.baseLeft;
                this._startY = this.baseTop;
                this.setTransformXY(0, 0);
            }
        }, 0);
    }
    /**
     * Animates the base or ghost element to a specific target location or other element using transition.
     * If `ghost` is true but there is not ghost rendered, it will be created and animated.
     * It is recommended to use 'getBoundingClientRects() + pageScroll' when determining desired location.
     *
     * @param target Target that the base or ghost will transition to. It can be either location in the page or another HTML element.
     * @param customAnimArgs Custom transition properties that will be applied when performing the transition.
     * @param startLocation Start location from where the transition should start.
     */
    transitionTo(target, customAnimArgs, startLocation) {
        if (!!startLocation && this.ghost && !this.ghostElement) {
            this._startX = startLocation.pageX;
            this._startY = startLocation.pageY;
            this._ghostStartX = this._startX;
            this._ghostStartY = this._startY;
        }
        else if (!!startLocation && (!this.ghost || this.ghostElement)) {
            this.setLocation(startLocation);
        }
        else if (this.ghost && !this.ghostElement) {
            this._startX = this.baseLeft;
            this._startY = this.baseTop;
            this._ghostStartX = this._startX + this.windowScrollLeft;
            this._ghostStartY = this._startY + this.windowScrollTop;
        }
        if (this.ghost && !this.ghostElement) {
            this.createGhost(this._startX, this._startY);
        }
        this.animInProgress = true;
        // Use setTimeout because we need to be sure that the element is positioned first correctly if there is start location.
        setTimeout(() => {
            const movedElem = this.ghost ? this.ghostElement : this.element.nativeElement;
            movedElem.style.transitionProperty = this.ghost && this.ghostElement ? 'left, top' : 'transform';
            movedElem.style.transitionDuration =
                customAnimArgs && customAnimArgs.duration ? customAnimArgs.duration + 's' : this.defaultReturnDuration;
            movedElem.style.transitionTimingFunction =
                customAnimArgs && customAnimArgs.timingFunction ? customAnimArgs.timingFunction : '';
            movedElem.style.transitionDelay = customAnimArgs && customAnimArgs.delay ? customAnimArgs.delay + 's' : '';
            if (target instanceof IgxDragLocation) {
                this.setLocation(new IgxDragLocation(target.pageX, target.pageY));
            }
            else {
                const targetRects = target.nativeElement.getBoundingClientRect();
                this.setLocation(new IgxDragLocation(targetRects.left - this.windowScrollLeft, targetRects.top - this.windowScrollTop));
            }
        }, 0);
    }
    /**
     * @hidden
     * Method bound to the PointerDown event of the base element igxDrag is initialized.
     * @param event PointerDown event captured
     */
    onPointerDown(event) {
        const ignoredElement = this.dragIgnoredElems.find(elem => elem.element.nativeElement === event.target);
        if (ignoredElement) {
            return;
        }
        this._clicked = true;
        this._pointerDownId = event.pointerId;
        // Set pointer capture so we detect pointermove even if mouse is out of bounds until ghostElement is created.
        const handleFound = this.dragHandles.find(handle => handle.element.nativeElement === event.currentTarget);
        const targetElement = handleFound ? handleFound.element.nativeElement : this.element.nativeElement;
        if (this.pointerEventsEnabled) {
            targetElement.setPointerCapture(this._pointerDownId);
        }
        else {
            targetElement.focus();
            event.preventDefault();
        }
        if (this.pointerEventsEnabled || !this.touchEventsEnabled) {
            // Check first for pointer events or non touch, because we can have pointer events and touch events at once.
            this._startX = event.pageX;
            this._startY = event.pageY;
        }
        else if (this.touchEventsEnabled) {
            this._startX = event.touches[0].pageX;
            this._startY = event.touches[0].pageY;
        }
        this._defaultOffsetX = this.baseLeft - this._startX + this.windowScrollLeft;
        this._defaultOffsetY = this.baseTop - this._startY + this.windowScrollTop;
        this._ghostStartX = this._startX + this.ghostOffsetX;
        this._ghostStartY = this._startY + this.ghostOffsetY;
        this._lastX = this._startX;
        this._lastY = this._startY;
    }
    /**
     * @hidden
     * Perform drag move logic when dragging and dispatching events if there is igxDrop under the pointer.
     * This method is bound at first at the base element.
     * If dragging starts and after the ghostElement is rendered the pointerId is reassigned it. Then this method is bound to it.
     * @param event PointerMove event captured
     */
    onPointerMove(event) {
        if (this._clicked) {
            let pageX;
            let pageY;
            if (this.pointerEventsEnabled || !this.touchEventsEnabled) {
                // Check first for pointer events or non touch, because we can have pointer events and touch events at once.
                pageX = event.pageX;
                pageY = event.pageY;
            }
            else if (this.touchEventsEnabled) {
                pageX = event.touches[0].pageX;
                pageY = event.touches[0].pageY;
                // Prevent scrolling on touch while dragging
                event.preventDefault();
            }
            const totalMovedX = pageX - this._startX;
            const totalMovedY = pageY - this._startY;
            if (!this._dragStarted &&
                (Math.abs(totalMovedX) > this.dragTolerance || Math.abs(totalMovedY) > this.dragTolerance)) {
                const dragStartArgs = {
                    originalEvent: event,
                    owner: this,
                    startX: pageX - totalMovedX,
                    startY: pageY - totalMovedY,
                    pageX,
                    pageY,
                    cancel: false
                };
                this.zone.run(() => {
                    this.dragStart.emit(dragStartArgs);
                });
                if (!dragStartArgs.cancel) {
                    this._dragStarted = true;
                    if (this.ghost) {
                        // We moved enough so ghostElement can be rendered and actual dragging to start.
                        // When creating it will take into account any offset set by the user by default.
                        this.createGhost(pageX, pageY);
                    }
                    else if (this._offsetX !== undefined || this._offsetY !== undefined) {
                        // There is no need for ghost, but we will need to position initially the base element to reflect any offset.
                        const transformX = (this._offsetX !== undefined ? this._offsetX - this._defaultOffsetX : 0) +
                            this.getTransformX(this.element.nativeElement);
                        const transformY = (this._offsetY !== undefined ? this._offsetY - this._defaultOffsetY : 0) +
                            this.getTransformY(this.element.nativeElement);
                        this.setTransformXY(transformX, transformY);
                    }
                }
                else {
                    return;
                }
            }
            else if (!this._dragStarted) {
                return;
            }
            const moveArgs = {
                originalEvent: event,
                owner: this,
                startX: this._startX,
                startY: this._startY,
                pageX: this._lastX,
                pageY: this._lastY,
                nextPageX: pageX,
                nextPageY: pageY,
                cancel: false
            };
            this.dragMove.emit(moveArgs);
            const setPageX = moveArgs.nextPageX;
            const setPageY = moveArgs.nextPageY;
            if (!moveArgs.cancel) {
                // Scroll root container if the user reaches its boundaries.
                this.onScrollContainer();
                // Move the actual element around
                if (this.ghost) {
                    const updatedTotalMovedX = this.dragDirection === DragDirection.VERTICAL ? 0 : setPageX - this._startX;
                    const updatedTotalMovedY = this.dragDirection === DragDirection.HORIZONTAL ? 0 : setPageY - this._startY;
                    this.ghostLeft = this._ghostStartX + updatedTotalMovedX;
                    this.ghostTop = this._ghostStartY + updatedTotalMovedY;
                }
                else {
                    const lastMovedX = this.dragDirection === DragDirection.VERTICAL ? 0 : setPageX - this._lastX;
                    const lastMovedY = this.dragDirection === DragDirection.HORIZONTAL ? 0 : setPageY - this._lastY;
                    const translateX = this.getTransformX(this.element.nativeElement) + lastMovedX;
                    const translateY = this.getTransformY(this.element.nativeElement) + lastMovedY;
                    this.setTransformXY(translateX, translateY);
                }
                this.dispatchDragEvents(pageX, pageY, event);
            }
            this._lastX = setPageX;
            this._lastY = setPageY;
        }
    }
    /**
     * @hidden
     * Perform drag end logic when releasing the ghostElement and dispatching drop event if igxDrop is under the pointer.
     * This method is bound at first at the base element.
     * If dragging starts and after the ghostElement is rendered the pointerId is reassigned to it. Then this method is bound to it.
     * @param event PointerUp event captured
     */
    onPointerUp(event) {
        if (!this._clicked) {
            return;
        }
        let pageX;
        let pageY;
        if (this.pointerEventsEnabled || !this.touchEventsEnabled) {
            // Check first for pointer events or non touch, because we can have pointer events and touch events at once.
            pageX = event.pageX;
            pageY = event.pageY;
        }
        else if (this.touchEventsEnabled) {
            pageX = event.touches[0].pageX;
            pageY = event.touches[0].pageY;
            // Prevent scrolling on touch while dragging
            event.preventDefault();
        }
        const eventArgs = {
            originalEvent: event,
            owner: this,
            startX: this._startX,
            startY: this._startY,
            pageX,
            pageY
        };
        this._pointerDownId = null;
        this._clicked = false;
        if (this._dragStarted) {
            if (this._lastDropArea && this._lastDropArea !== this.element.nativeElement) {
                this.dispatchDropEvent(event.pageX, event.pageY, event);
            }
            this.zone.run(() => {
                this.dragEnd.emit(eventArgs);
            });
            if (!this.animInProgress) {
                this.onTransitionEnd(null);
            }
        }
        else {
            // Trigger our own click event because when there is no ghost, native click cannot be prevented when dragging.
            this.zone.run(() => {
                this.dragClick.emit(eventArgs);
            });
        }
        if (this._containerScrollIntervalId) {
            clearInterval(this._containerScrollIntervalId);
            this._containerScrollIntervalId = null;
        }
    }
    /**
     * @hidden
     * Execute this method whe the pointer capture has been lost.
     * This means that during dragging the user has performed other action like right clicking and then clicking somewhere else.
     * This method will ensure that the drag state is being reset in this case as if the user released the dragged element.
     * @param event Event captured
     */
    onPointerLost(event) {
        if (!this._clicked) {
            return;
        }
        const eventArgs = {
            originalEvent: event,
            owner: this,
            startX: this._startX,
            startY: this._startY,
            pageX: event.pageX,
            pageY: event.pageY
        };
        this._pointerDownId = null;
        this._clicked = false;
        if (this._dragStarted) {
            this.zone.run(() => {
                this.dragEnd.emit(eventArgs);
            });
            if (!this.animInProgress) {
                this.onTransitionEnd(null);
            }
        }
    }
    /**
     * @hidden
     */
    onTransitionEnd(event) {
        if ((!this._dragStarted && !this.animInProgress) || this._clicked) {
            // Return if no dragging started and there is no animation in progress.
            return;
        }
        if (this.ghost && this.ghostElement) {
            this._ghostStartX = this.baseLeft + this.windowScrollLeft;
            this._ghostStartY = this.baseTop + this.windowScrollTop;
            const ghostDestroyArgs = {
                owner: this,
                ghostElement: this.ghostElement,
                cancel: false
            };
            this.ghostDestroy.emit(ghostDestroyArgs);
            if (ghostDestroyArgs.cancel) {
                return;
            }
            this.ghostElement.parentNode.removeChild(this.ghostElement);
            this.ghostElement = null;
            if (this._dynamicGhostRef) {
                this._dynamicGhostRef.destroy();
                this._dynamicGhostRef = null;
            }
        }
        else if (!this.ghost) {
            this.element.nativeElement.style.transitionProperty = '';
            this.element.nativeElement.style.transitionDuration = '0.0s';
            this.element.nativeElement.style.transitionTimingFunction = '';
            this.element.nativeElement.style.transitionDelay = '';
        }
        this.animInProgress = false;
        this._dragStarted = false;
        // Execute transitioned after everything is reset so if the user sets new location on the base now it would work as expected.
        this.zone.run(() => {
            this.transitioned.emit({
                originalEvent: event,
                owner: this,
                startX: this._startX,
                startY: this._startY,
                pageX: this._startX,
                pageY: this._startY
            });
        });
    }
    /**
     * @hidden
     * Create ghost element - if a Node object is provided it creates a clone of that node,
     * otherwise it clones the host element.
     * Bind all needed events.
     * @param pageX Latest pointer position on the X axis relative to the page.
     * @param pageY Latest pointer position on the Y axis relative to the page.
     * @param node The Node object to be cloned.
     */
    createGhost(pageX, pageY, node = null) {
        if (!this.ghost) {
            return;
        }
        if (this.ghostTemplate) {
            this._dynamicGhostRef = this.viewContainer.createEmbeddedView(this.ghostTemplate, this.ghostContext);
            this.ghostElement = this._dynamicGhostRef.rootNodes[0];
        }
        else {
            this.ghostElement = node ? node.cloneNode(true) : this.element.nativeElement.cloneNode(true);
        }
        const totalMovedX = pageX - this._startX;
        const totalMovedY = pageY - this._startY;
        this._ghostHostX = this.ghostHost ? this.ghostHostOffsetLeft(this.ghostHost) : 0;
        this._ghostHostY = this.ghostHost ? this.ghostHostOffsetTop(this.ghostHost) : 0;
        this.ghostElement.style.transitionDuration = '0.0s';
        this.ghostElement.style.position = 'absolute';
        if (this.ghostClass) {
            this.renderer.addClass(this.ghostElement, this.ghostClass);
        }
        const createEventArgs = {
            owner: this,
            ghostElement: this.ghostElement,
            cancel: false
        };
        this.ghostCreate.emit(createEventArgs);
        if (createEventArgs.cancel) {
            this.ghostElement = null;
            if (this.ghostTemplate && this._dynamicGhostRef) {
                this._dynamicGhostRef.destroy();
            }
            return;
        }
        if (this.ghostHost) {
            this.ghostHost.appendChild(this.ghostElement);
        }
        else {
            document.body.appendChild(this.ghostElement);
        }
        const ghostMarginLeft = parseInt(document.defaultView.getComputedStyle(this.ghostElement)['margin-left'], 10);
        const ghostMarginTop = parseInt(document.defaultView.getComputedStyle(this.ghostElement)['margin-top'], 10);
        this.ghostElement.style.left = (this._ghostStartX - ghostMarginLeft + totalMovedX - this._ghostHostX) + 'px';
        this.ghostElement.style.top = (this._ghostStartY - ghostMarginTop + totalMovedY - this._ghostHostX) + 'px';
        if (this.pointerEventsEnabled) {
            // The ghostElement takes control for moving and dragging after it has been rendered.
            if (this._pointerDownId !== null) {
                this.ghostElement.setPointerCapture(this._pointerDownId);
            }
            this.ghostElement.addEventListener('pointermove', (args) => {
                this.onPointerMove(args);
            });
            this.ghostElement.addEventListener('pointerup', (args) => {
                this.onPointerUp(args);
            });
            this.ghostElement.addEventListener('lostpointercapture', (args) => {
                this.onPointerLost(args);
            });
        }
        // Transition animation when the ghostElement is released and it returns to it's original position.
        this.ghostElement.addEventListener('transitionend', (args) => {
            this.onTransitionEnd(args);
        });
        this.cdr.detectChanges();
    }
    /**
     * @hidden
     * Dispatch custom igxDragEnter/igxDragLeave events based on current pointer position and if drop area is under.
     */
    dispatchDragEvents(pageX, pageY, originalEvent) {
        let topDropArea;
        const customEventArgs = {
            startX: this._startX,
            startY: this._startY,
            pageX,
            pageY,
            owner: this,
            originalEvent
        };
        let elementsFromPoint = this.getElementsAtPoint(pageX, pageY);
        // Check for shadowRoot instance and use it if present
        for (const elFromPoint of elementsFromPoint) {
            if (!!elFromPoint?.shadowRoot) {
                elementsFromPoint = elFromPoint.shadowRoot.elementsFromPoint(pageX, pageY);
            }
        }
        for (const element of elementsFromPoint) {
            if (element.getAttribute('droppable') === 'true' &&
                element !== this.ghostElement && element !== this.element.nativeElement) {
                topDropArea = element;
                break;
            }
        }
        if (topDropArea &&
            (!this._lastDropArea || (this._lastDropArea && this._lastDropArea !== topDropArea))) {
            if (this._lastDropArea) {
                this.dispatchEvent(this._lastDropArea, 'igxDragLeave', customEventArgs);
            }
            this._lastDropArea = topDropArea;
            this.dispatchEvent(this._lastDropArea, 'igxDragEnter', customEventArgs);
        }
        else if (!topDropArea && this._lastDropArea) {
            this.dispatchEvent(this._lastDropArea, 'igxDragLeave', customEventArgs);
            this._lastDropArea = null;
            return;
        }
        if (topDropArea) {
            this.dispatchEvent(topDropArea, 'igxDragOver', customEventArgs);
        }
    }
    /**
     * @hidden
     * Dispatch custom igxDrop event based on current pointer position if there is last recorder drop area under the pointer.
     * Last recorder drop area is updated in @dispatchDragEvents method.
     */
    dispatchDropEvent(pageX, pageY, originalEvent) {
        const eventArgs = {
            startX: this._startX,
            startY: this._startY,
            pageX,
            pageY,
            owner: this,
            originalEvent
        };
        this.dispatchEvent(this._lastDropArea, 'igxDrop', eventArgs);
        this.dispatchEvent(this._lastDropArea, 'igxDragLeave', eventArgs);
        this._lastDropArea = null;
    }
    /**
     * @hidden
     */
    getElementsAtPoint(pageX, pageY) {
        // correct the coordinates with the current scroll position, because
        // document.elementsFromPoint consider position within the current viewport
        // window.pageXOffset == window.scrollX; // always true
        // using window.pageXOffset for IE9 compatibility
        const viewPortX = pageX - window.pageXOffset;
        const viewPortY = pageY - window.pageYOffset;
        if (document['msElementsFromPoint']) {
            // Edge and IE special snowflakes
            const elements = document['msElementsFromPoint'](viewPortX, viewPortY);
            return elements === null ? [] : elements;
        }
        else {
            // Other browsers like Chrome, Firefox, Opera
            return document.elementsFromPoint(viewPortX, viewPortY);
        }
    }
    /**
     * @hidden
     */
    dispatchEvent(target, eventName, eventArgs) {
        // This way is IE11 compatible.
        const dragLeaveEvent = document.createEvent('CustomEvent');
        dragLeaveEvent.initCustomEvent(eventName, false, false, eventArgs);
        target.dispatchEvent(dragLeaveEvent);
        // Otherwise can be used `target.dispatchEvent(new CustomEvent(eventName, eventArgs));`
    }
    getTransformX(elem) {
        let posX = 0;
        if (elem.style.transform) {
            const matrix = elem.style.transform;
            const values = matrix ? matrix.match(/-?[\d\.]+/g) : undefined;
            posX = values ? Number(values[1]) : 0;
        }
        return posX;
    }
    getTransformY(elem) {
        let posY = 0;
        if (elem.style.transform) {
            const matrix = elem.style.transform;
            const values = matrix ? matrix.match(/-?[\d\.]+/g) : undefined;
            posY = values ? Number(values[2]) : 0;
        }
        return posY;
    }
    /** Method setting transformation to the base draggable element. */
    setTransformXY(x, y) {
        this.element.nativeElement.style.transform = 'translate3d(' + x + 'px, ' + y + 'px, 0px)';
    }
    ghostHostOffsetLeft(ghostHost) {
        const ghostPosition = document.defaultView.getComputedStyle(ghostHost).getPropertyValue('position');
        if (ghostPosition === 'static' && ghostHost.offsetParent && ghostHost.offsetParent === document.body) {
            return 0;
        }
        else if (ghostPosition === 'static' && ghostHost.offsetParent) {
            return ghostHost.offsetParent.getBoundingClientRect().left - this.windowScrollLeft;
        }
        return ghostHost.getBoundingClientRect().left - this.windowScrollLeft;
    }
    ghostHostOffsetTop(ghostHost) {
        const ghostPosition = document.defaultView.getComputedStyle(ghostHost).getPropertyValue('position');
        if (ghostPosition === 'static' && ghostHost.offsetParent && ghostHost.offsetParent === document.body) {
            return 0;
        }
        else if (ghostPosition === 'static' && ghostHost.offsetParent) {
            return ghostHost.offsetParent.getBoundingClientRect().top - this.windowScrollTop;
        }
        return ghostHost.getBoundingClientRect().top - this.windowScrollTop;
    }
    getContainerScrollDirection() {
        const containerBounds = this.scrollContainer ? this.scrollContainer.getBoundingClientRect() : null;
        const scrolledX = !this.scrollContainer ? this.windowScrollLeft > 0 : this.scrollContainer.scrollLeft > 0;
        const scrolledY = !this.scrollContainer ? this.windowScrollTop > 0 : this.scrollContainer.scrollTop > 0;
        // Take into account window scroll top because we do not use fixed positioning to the window.
        const topBorder = (!this.scrollContainer ? 0 : containerBounds.top) + this.windowScrollTop + this._scrollContainerThreshold;
        // Subtract the element height because we position it from top left corner.
        const elementHeight = this.ghost && this.ghostElement ? this.ghostElement.offsetHeight : this.element.nativeElement.offsetHeight;
        const bottomBorder = (!this.scrollContainer ? window.innerHeight : containerBounds.bottom) +
            this.windowScrollTop - this._scrollContainerThreshold - elementHeight;
        // Same for window scroll left 
        const leftBorder = (!this.scrollContainer ? 0 : containerBounds.left) + this.windowScrollLeft + this._scrollContainerThreshold;
        // Subtract the element width again because we position it from top left corner.
        const elementWidth = this.ghost && this.ghostElement ? this.ghostElement.offsetWidth : this.element.nativeElement.offsetWidth;
        const rightBorder = (!this.scrollContainer ? window.innerWidth : containerBounds.right) +
            this.windowScrollLeft - this._scrollContainerThreshold - elementWidth;
        if (this.pageY <= topBorder && scrolledY) {
            return DragScrollDirection.UP;
        }
        else if (this.pageY > bottomBorder) {
            return DragScrollDirection.DOWN;
        }
        else if (this.pageX < leftBorder && scrolledX) {
            return DragScrollDirection.LEFT;
        }
        else if (this.pageX > rightBorder) {
            return DragScrollDirection.RIGHT;
        }
        return null;
    }
    onScrollContainerStep(scrollDir) {
        animationFrameScheduler.schedule(() => {
            let xDir = scrollDir == DragScrollDirection.LEFT ? -1 : (scrollDir == DragScrollDirection.RIGHT ? 1 : 0);
            let yDir = scrollDir == DragScrollDirection.UP ? -1 : (scrollDir == DragScrollDirection.DOWN ? 1 : 0);
            if (!this.scrollContainer) {
                // Cap scrolling so we don't scroll past the window max scroll position.
                const maxScrollX = this._originalScrollContainerWidth - document.documentElement.clientWidth;
                const maxScrollY = this._originalScrollContainerHeight - document.documentElement.clientHeight;
                xDir = (this.windowScrollLeft <= 0 && xDir < 0) || (this.windowScrollLeft >= maxScrollX && xDir > 0) ? 0 : xDir;
                yDir = (this.windowScrollTop <= 0 && yDir < 0) || (this.windowScrollTop >= maxScrollY && yDir > 0) ? 0 : yDir;
            }
            else {
                // Cap scrolling so we don't scroll past the container max scroll position.
                const maxScrollX = this._originalScrollContainerWidth - this.scrollContainer.clientWidth;
                const maxScrollY = this._originalScrollContainerHeight - this.scrollContainer.clientHeight;
                xDir = (this.scrollContainer.scrollLeft <= 0 && xDir < 0) || (this.scrollContainer.scrollLeft >= maxScrollX && xDir > 0) ? 0 : xDir;
                yDir = (this.scrollContainer.scrollTop <= 0 && yDir < 0) || (this.scrollContainer.scrollTop >= maxScrollY && yDir > 0) ? 0 : yDir;
            }
            const scrollByX = xDir * this._scrollContainerStep;
            const scrollByY = yDir * this._scrollContainerStep;
            // Scroll the corresponding window or container.
            if (!this.scrollContainer) {
                window.scrollBy(scrollByX, scrollByY);
            }
            else {
                this.scrollContainer.scrollLeft += scrollByX;
                this.scrollContainer.scrollTop += scrollByY;
            }
            if (this.ghost && !this.scrollContainer) {
                // Scroll the ghost only when there is no container specifies.
                // If it has container the ghost pretty much stays in the same position while the container is scrolled since e use top/left position.
                // Otherwise increase the position the same amount we have scrolled the window
                this.ghostLeft += scrollByX;
                this.ghostTop += scrollByY;
            }
            else if (!this.ghost) {
                // Move the base element the same amount we moved the window/container because we use transformations.
                const translateX = this.getTransformX(this.element.nativeElement) + scrollByX;
                const translateY = this.getTransformY(this.element.nativeElement) + scrollByY;
                this.setTransformXY(translateX, translateY);
                if (!this.scrollContainer) {
                    this._lastX += scrollByX;
                    this._lastY += scrollByY;
                }
            }
        });
    }
    onScrollContainer() {
        const scrollDir = this.getContainerScrollDirection();
        if (scrollDir !== null && scrollDir !== undefined && !this._containerScrollIntervalId) {
            // Save original container sizes to ensure that we don't increase scroll sizes infinitely when out of bounds.
            this._originalScrollContainerWidth = this.scrollContainer ? this.scrollContainer.scrollWidth : this.windowScrollWidth;
            this._originalScrollContainerHeight = this.scrollContainer ? this.scrollContainer.scrollHeight : this.windowScrollHeight;
            this._containerScrollIntervalId = setInterval(() => this.onScrollContainerStep(scrollDir), this._scrollContainerStepMs);
        }
        else if ((scrollDir === null || scrollDir === undefined) && this._containerScrollIntervalId) {
            // We moved out of end bounds and there is interval started
            clearInterval(this._containerScrollIntervalId);
            this._containerScrollIntervalId = null;
        }
    }
}
IgxDragDirective.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.2.2", ngImport: i0, type: IgxDragDirective, deps: [{ token: i0.ChangeDetectorRef }, { token: i0.ElementRef }, { token: i0.ViewContainerRef }, { token: i0.NgZone }, { token: i0.Renderer2 }, { token: i1.PlatformUtil }], target: i0.ɵɵFactoryTarget.Directive });
IgxDragDirective.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "12.0.0", version: "13.2.2", type: IgxDragDirective, selector: "[igxDrag]", inputs: { data: ["igxDrag", "data"], dragTolerance: "dragTolerance", dragDirection: "dragDirection", dragChannel: "dragChannel", ghost: "ghost", ghostClass: "ghostClass", ghostTemplate: "ghostTemplate", ghostHost: "ghostHost", scrollContainer: "scrollContainer", ghostOffsetX: "ghostOffsetX", ghostOffsetY: "ghostOffsetY" }, outputs: { dragStart: "dragStart", dragMove: "dragMove", dragEnd: "dragEnd", dragClick: "dragClick", ghostCreate: "ghostCreate", ghostDestroy: "ghostDestroy", transitioned: "transitioned" }, host: { properties: { "class.igx-drag": "this.baseClass", "class.igx-drag--select-disabled": "this.selectDisabled" } }, queries: [{ propertyName: "dragHandles", predicate: IgxDragHandleDirective, descendants: true }, { propertyName: "dragIgnoredElems", predicate: IgxDragIgnoreDirective, descendants: true }], exportAs: ["drag"], ngImport: i0 });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.2.2", ngImport: i0, type: IgxDragDirective, decorators: [{
            type: Directive,
            args: [{
                    exportAs: 'drag',
                    selector: '[igxDrag]'
                }]
        }], ctorParameters: function () { return [{ type: i0.ChangeDetectorRef }, { type: i0.ElementRef }, { type: i0.ViewContainerRef }, { type: i0.NgZone }, { type: i0.Renderer2 }, { type: i1.PlatformUtil }]; }, propDecorators: { data: [{
                type: Input,
                args: ['igxDrag']
            }], dragTolerance: [{
                type: Input
            }], dragDirection: [{
                type: Input
            }], dragChannel: [{
                type: Input
            }], ghost: [{
                type: Input
            }], ghostClass: [{
                type: Input
            }], ghostTemplate: [{
                type: Input
            }], ghostHost: [{
                type: Input
            }], scrollContainer: [{
                type: Input
            }], dragStart: [{
                type: Output
            }], dragMove: [{
                type: Output
            }], dragEnd: [{
                type: Output
            }], dragClick: [{
                type: Output
            }], ghostCreate: [{
                type: Output
            }], ghostDestroy: [{
                type: Output
            }], transitioned: [{
                type: Output
            }], dragHandles: [{
                type: ContentChildren,
                args: [IgxDragHandleDirective, { descendants: true }]
            }], dragIgnoredElems: [{
                type: ContentChildren,
                args: [IgxDragIgnoreDirective, { descendants: true }]
            }], baseClass: [{
                type: HostBinding,
                args: ['class.igx-drag']
            }], selectDisabled: [{
                type: HostBinding,
                args: ['class.igx-drag--select-disabled']
            }], ghostOffsetX: [{
                type: Input
            }], ghostOffsetY: [{
                type: Input
            }] } });
export class IgxDropDirective {
    constructor(element, _renderer, _zone) {
        this.element = element;
        this._renderer = _renderer;
        this._zone = _zone;
        /**
         * Event triggered when dragged element enters the area of the element.
         * ```html
         * <div class="cageArea" igxDrop (enter)="dragEnter()" (igxDragEnter)="onDragCageEnter()" (igxDragLeave)="onDragCageLeave()">
         * </div>
         * ```
         * ```typescript
         * public dragEnter(){
         *     alert("A draggable element has entered the chip area!");
         * }
         * ```
         *
         * @memberof IgxDropDirective
         */
        this.enter = new EventEmitter();
        /**
         * Event triggered when dragged element enters the area of the element.
         * ```html
         * <div class="cageArea" igxDrop (enter)="dragEnter()" (igxDragEnter)="onDragCageEnter()" (igxDragLeave)="onDragCageLeave()">
         * </div>
         * ```
         * ```typescript
         * public dragEnter(){
         *     alert("A draggable element has entered the chip area!");
         * }
         * ```
         *
         * @memberof IgxDropDirective
         */
        this.over = new EventEmitter();
        /**
         * Event triggered when dragged element leaves the area of the element.
         * ```html
         * <div class="cageArea" igxDrop (leave)="dragLeave()" (igxDragEnter)="onDragCageEnter()" (igxDragLeave)="onDragCageLeave()">
         * </div>
         * ```
         * ```typescript
         * public dragLeave(){
         *     alert("A draggable element has left the chip area!");
         * }
         * ```
         *
         * @memberof IgxDropDirective
         */
        this.leave = new EventEmitter();
        /**
         * Event triggered when dragged element is dropped in the area of the element.
         * Since the `igxDrop` has default logic that appends the dropped element as a child, it can be canceled here.
         * To cancel the default logic the `cancel` property of the event needs to be set to true.
         * ```html
         * <div class="cageArea" igxDrop (dropped)="dragDrop()" (igxDragEnter)="onDragCageEnter()" (igxDragLeave)="onDragCageLeave()">
         * </div>
         * ```
         * ```typescript
         * public dragDrop(){
         *     alert("A draggable element has been dropped in the chip area!");
         * }
         * ```
         *
         * @memberof IgxDropDirective
         */
        this.dropped = new EventEmitter();
        /**
         * @hidden
         */
        this.droppable = true;
        /**
         * @hidden
         */
        this.dragover = false;
        /**
         * @hidden
         */
        this._destroy = new Subject();
        this._dropStrategy = new IgxDefaultDropStrategy();
    }
    /**
     * - Save data inside the `igxDrop` directive. This can be set when instancing `igxDrop` on an element.
     * ```html
     * <div [igxDrop]="{ source: myElement }"></div>
     * ```
     *
     * @memberof IgxDropDirective
     */
    set data(v) {
        this._data = v;
    }
    get data() {
        return this._data;
    }
    /**
     * An @Input property that specifies a drop strategy type that will be executed when an `IgxDrag` element is released inside
     *  the current drop area. The provided strategies are:
     *  - IgxDefaultDropStrategy - This is the default base strategy and it doesn't perform any actions.
     *  - IgxAppendDropStrategy - Appends the dropped element to last position as a direct child to the `igxDrop`.
     *  - IgxPrependDropStrategy - Prepends the dropped element to first position as a direct child to the `igxDrop`.
     *  - IgxInsertDropStrategy - If the dropped element is released above a child element of the `igxDrop`, it will be inserted
     *      at that position. Otherwise the dropped element will be appended if released outside any child of the `igxDrop`.
     * ```html
     * <div igxDrag>
     *      <span>DragMe</span>
     * </div>
     * <div igxDrop [dropStrategy]="myDropStrategy">
     *         <span>Numbers drop area!</span>
     * </div>
     * ```
     * ```typescript
     * import { IgxAppendDropStrategy } from 'igniteui-angular';
     *
     * export class App {
     *      public myDropStrategy = IgxAppendDropStrategy;
     * }
     * ```
     *
     * @memberof IgxDropDirective
     */
    set dropStrategy(classRef) {
        this._dropStrategy = new classRef(this._renderer);
    }
    get dropStrategy() {
        return this._dropStrategy;
    }
    /**
     * @hidden
     */
    onDragDrop(event) {
        if (!this.isDragLinked(event.detail.owner)) {
            return;
        }
        const elementPosX = this.element.nativeElement.getBoundingClientRect().left + this.getWindowScrollLeft();
        const elementPosY = this.element.nativeElement.getBoundingClientRect().top + this.getWindowScrollTop();
        const offsetX = event.detail.pageX - elementPosX;
        const offsetY = event.detail.pageY - elementPosY;
        const args = {
            owner: this,
            originalEvent: event.detail.originalEvent,
            drag: event.detail.owner,
            dragData: event.detail.owner.data,
            startX: event.detail.startX,
            startY: event.detail.startY,
            pageX: event.detail.pageX,
            pageY: event.detail.pageY,
            offsetX,
            offsetY,
            cancel: false
        };
        this._zone.run(() => {
            this.dropped.emit(args);
        });
        if (this._dropStrategy && !args.cancel) {
            const elementsAtPoint = event.detail.owner.getElementsAtPoint(event.detail.pageX, event.detail.pageY);
            const insertIndex = this.getInsertIndexAt(event.detail.owner, elementsAtPoint);
            this._dropStrategy.dropAction(event.detail.owner, this, insertIndex);
        }
    }
    /**
     * @hidden
     */
    ngOnInit() {
        this._zone.runOutsideAngular(() => {
            fromEvent(this.element.nativeElement, 'igxDragEnter').pipe(takeUntil(this._destroy))
                .subscribe((res) => this.onDragEnter(res));
            fromEvent(this.element.nativeElement, 'igxDragLeave').pipe(takeUntil(this._destroy)).subscribe((res) => this.onDragLeave(res));
            fromEvent(this.element.nativeElement, 'igxDragOver').pipe(takeUntil(this._destroy)).subscribe((res) => this.onDragOver(res));
        });
    }
    /**
     * @hidden
     */
    ngOnDestroy() {
        this._destroy.next(true);
        this._destroy.complete();
    }
    /**
     * @hidden
     */
    onDragOver(event) {
        const elementPosX = this.element.nativeElement.getBoundingClientRect().left + this.getWindowScrollLeft();
        const elementPosY = this.element.nativeElement.getBoundingClientRect().top + this.getWindowScrollTop();
        const offsetX = event.detail.pageX - elementPosX;
        const offsetY = event.detail.pageY - elementPosY;
        const eventArgs = {
            originalEvent: event.detail.originalEvent,
            owner: this,
            drag: event.detail.owner,
            dragData: event.detail.owner.data,
            startX: event.detail.startX,
            startY: event.detail.startY,
            pageX: event.detail.pageX,
            pageY: event.detail.pageY,
            offsetX,
            offsetY
        };
        this.over.emit(eventArgs);
    }
    /**
     * @hidden
     */
    onDragEnter(event) {
        if (!this.isDragLinked(event.detail.owner)) {
            return;
        }
        this.dragover = true;
        const elementPosX = this.element.nativeElement.getBoundingClientRect().left + this.getWindowScrollLeft();
        const elementPosY = this.element.nativeElement.getBoundingClientRect().top + this.getWindowScrollTop();
        const offsetX = event.detail.pageX - elementPosX;
        const offsetY = event.detail.pageY - elementPosY;
        const eventArgs = {
            originalEvent: event.detail.originalEvent,
            owner: this,
            drag: event.detail.owner,
            dragData: event.detail.owner.data,
            startX: event.detail.startX,
            startY: event.detail.startY,
            pageX: event.detail.pageX,
            pageY: event.detail.pageY,
            offsetX,
            offsetY
        };
        this._zone.run(() => {
            this.enter.emit(eventArgs);
        });
    }
    /**
     * @hidden
     */
    onDragLeave(event) {
        if (!this.isDragLinked(event.detail.owner)) {
            return;
        }
        this.dragover = false;
        const elementPosX = this.element.nativeElement.getBoundingClientRect().left + this.getWindowScrollLeft();
        const elementPosY = this.element.nativeElement.getBoundingClientRect().top + this.getWindowScrollTop();
        const offsetX = event.detail.pageX - elementPosX;
        const offsetY = event.detail.pageY - elementPosY;
        const eventArgs = {
            originalEvent: event.detail.originalEvent,
            owner: this,
            drag: event.detail.owner,
            dragData: event.detail.owner.data,
            startX: event.detail.startX,
            startY: event.detail.startY,
            pageX: event.detail.pageX,
            pageY: event.detail.pageY,
            offsetX,
            offsetY
        };
        this._zone.run(() => {
            this.leave.emit(eventArgs);
        });
    }
    getWindowScrollTop() {
        return window.scrollY ? window.scrollY : (window.pageYOffset ? window.pageYOffset : 0);
    }
    getWindowScrollLeft() {
        return window.scrollX ? window.scrollX : (window.pageXOffset ? window.pageXOffset : 0);
    }
    isDragLinked(drag) {
        const dragLinkArray = drag.dragChannel instanceof Array;
        const dropLinkArray = this.dropChannel instanceof Array;
        if (!dragLinkArray && !dropLinkArray) {
            return this.dropChannel === drag.dragChannel;
        }
        else if (!dragLinkArray && dropLinkArray) {
            const dropLinks = this.dropChannel;
            for (const link of dropLinks) {
                if (link === drag.dragChannel) {
                    return true;
                }
            }
        }
        else if (dragLinkArray && !dropLinkArray) {
            const dragLinks = drag.dragChannel;
            for (const link of dragLinks) {
                if (link === this.dropChannel) {
                    return true;
                }
            }
        }
        else {
            const dragLinks = drag.dragChannel;
            const dropLinks = this.dropChannel;
            for (const draglink of dragLinks) {
                for (const droplink of dropLinks) {
                    if (draglink === droplink) {
                        return true;
                    }
                }
            }
        }
        return false;
    }
    getInsertIndexAt(draggedDir, elementsAtPoint) {
        let insertIndex = -1;
        const dropChildren = Array.prototype.slice.call(this.element.nativeElement.children);
        if (!dropChildren.length) {
            return insertIndex;
        }
        let i = 0;
        let childUnder = null;
        while (!childUnder && i < elementsAtPoint.length) {
            if (elementsAtPoint[i].parentElement === this.element.nativeElement) {
                childUnder = elementsAtPoint[i];
            }
            i++;
        }
        const draggedElemIndex = dropChildren.indexOf(draggedDir.element.nativeElement);
        insertIndex = dropChildren.indexOf(childUnder);
        if (draggedElemIndex !== -1 && draggedElemIndex < insertIndex) {
            insertIndex++;
        }
        return insertIndex;
    }
}
IgxDropDirective.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.2.2", ngImport: i0, type: IgxDropDirective, deps: [{ token: i0.ElementRef }, { token: i0.Renderer2 }, { token: i0.NgZone }], target: i0.ɵɵFactoryTarget.Directive });
IgxDropDirective.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "12.0.0", version: "13.2.2", type: IgxDropDirective, selector: "[igxDrop]", inputs: { data: ["igxDrop", "data"], dropChannel: "dropChannel", dropStrategy: "dropStrategy" }, outputs: { enter: "enter", over: "over", leave: "leave", dropped: "dropped" }, host: { listeners: { "igxDrop": "onDragDrop($event)" }, properties: { "attr.droppable": "this.droppable", "class.dragOver": "this.dragover" } }, exportAs: ["drop"], ngImport: i0 });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.2.2", ngImport: i0, type: IgxDropDirective, decorators: [{
            type: Directive,
            args: [{
                    exportAs: 'drop',
                    selector: '[igxDrop]'
                }]
        }], ctorParameters: function () { return [{ type: i0.ElementRef }, { type: i0.Renderer2 }, { type: i0.NgZone }]; }, propDecorators: { data: [{
                type: Input,
                args: ['igxDrop']
            }], dropChannel: [{
                type: Input
            }], dropStrategy: [{
                type: Input
            }], enter: [{
                type: Output
            }], over: [{
                type: Output
            }], leave: [{
                type: Output
            }], dropped: [{
                type: Output
            }], droppable: [{
                type: HostBinding,
                args: ['attr.droppable']
            }], dragover: [{
                type: HostBinding,
                args: ['class.dragOver']
            }], onDragDrop: [{
                type: HostListener,
                args: ['igxDrop', ['$event']]
            }] } });
/**
 * @hidden
 */
export class IgxDragDropModule {
}
IgxDragDropModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.2.2", ngImport: i0, type: IgxDragDropModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
IgxDragDropModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "13.2.2", ngImport: i0, type: IgxDragDropModule, declarations: [IgxDragDirective, IgxDropDirective, IgxDragHandleDirective, IgxDragIgnoreDirective], exports: [IgxDragDirective, IgxDropDirective, IgxDragHandleDirective, IgxDragIgnoreDirective] });
IgxDragDropModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "13.2.2", ngImport: i0, type: IgxDragDropModule });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.2.2", ngImport: i0, type: IgxDragDropModule, decorators: [{
            type: NgModule,
            args: [{
                    declarations: [IgxDragDirective, IgxDropDirective, IgxDragHandleDirective, IgxDragIgnoreDirective],
                    exports: [IgxDragDirective, IgxDropDirective, IgxDragHandleDirective, IgxDragIgnoreDirective]
                }]
        }] });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZHJhZy1kcm9wLmRpcmVjdGl2ZS5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uLy4uL3Byb2plY3RzL2lnbml0ZXVpLWFuZ3VsYXIvc3JjL2xpYi9kaXJlY3RpdmVzL2RyYWctZHJvcC9kcmFnLWRyb3AuZGlyZWN0aXZlLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLE9BQU8sRUFDSCxTQUFTLEVBRVQsWUFBWSxFQUNaLFdBQVcsRUFDWCxZQUFZLEVBQ1osS0FBSyxFQUNMLFFBQVEsRUFJUixNQUFNLEVBTU4sZUFBZSxFQUVsQixNQUFNLGVBQWUsQ0FBQztBQUN2QixPQUFPLEVBQUUsdUJBQXVCLEVBQUUsU0FBUyxFQUFFLFFBQVEsRUFBRSxPQUFPLEVBQUUsTUFBTSxNQUFNLENBQUM7QUFDN0UsT0FBTyxFQUFFLFNBQVMsRUFBRSxRQUFRLEVBQUUsTUFBTSxnQkFBZ0IsQ0FBQztBQUVyRCxPQUFPLEVBQWlCLHNCQUFzQixFQUFFLE1BQU0sc0JBQXNCLENBQUM7OztBQUU3RSxJQUFLLG1CQUtKO0FBTEQsV0FBSyxtQkFBbUI7SUFDdEIseURBQUUsQ0FBQTtJQUNGLDZEQUFJLENBQUE7SUFDSiw2REFBSSxDQUFBO0lBQ0osK0RBQUssQ0FBQTtBQUNQLENBQUMsRUFMSSxtQkFBbUIsS0FBbkIsbUJBQW1CLFFBS3ZCO0FBRUQsTUFBTSxDQUFOLElBQVksYUFJWDtBQUpELFdBQVksYUFBYTtJQUNyQix5REFBUSxDQUFBO0lBQ1IsNkRBQVUsQ0FBQTtJQUNWLGlEQUFJLENBQUE7QUFDUixDQUFDLEVBSlcsYUFBYSxLQUFiLGFBQWEsUUFJeEI7QUEwR0QsTUFBTSxPQUFPLGVBQWU7SUFJeEIsWUFBb0IsTUFBTSxFQUFVLE1BQU07UUFBdEIsV0FBTSxHQUFOLE1BQU0sQ0FBQTtRQUFVLFdBQU0sR0FBTixNQUFNLENBQUE7UUFDdEMsSUFBSSxDQUFDLEtBQUssR0FBRyxVQUFVLENBQUMsTUFBTSxDQUFDLENBQUM7UUFDaEMs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Z0JBQWdCLEVBQUUsc0JBQXNCLEVBQUUsc0JBQXNCLENBQUM7b0JBQ2xHLE9BQU8sRUFBRSxDQUFDLGdCQUFnQixFQUFFLGdCQUFnQixFQUFFLHNCQUFzQixFQUFFLHNCQUFzQixDQUFDO2lCQUNoRyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7XG4gICAgRGlyZWN0aXZlLFxuICAgIEVsZW1lbnRSZWYsXG4gICAgRXZlbnRFbWl0dGVyLFxuICAgIEhvc3RCaW5kaW5nLFxuICAgIEhvc3RMaXN0ZW5lcixcbiAgICBJbnB1dCxcbiAgICBOZ01vZHVsZSxcbiAgICBOZ1pvbmUsXG4gICAgT25EZXN0cm95LFxuICAgIE9uSW5pdCxcbiAgICBPdXRwdXQsXG4gICAgUmVuZGVyZXIyLFxuICAgIENoYW5nZURldGVjdG9yUmVmLFxuICAgIFZpZXdDb250YWluZXJSZWYsXG4gICAgQWZ0ZXJDb250ZW50SW5pdCxcbiAgICBUZW1wbGF0ZVJlZixcbiAgICBDb250ZW50Q2hpbGRyZW4sXG4gICAgUXVlcnlMaXN0XG59IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgYW5pbWF0aW9uRnJhbWVTY2hlZHVsZXIsIGZyb21FdmVudCwgaW50ZXJ2YWwsIFN1YmplY3QgfSBmcm9tICdyeGpzJztcbmltcG9ydCB7IHRha2VVbnRpbCwgdGhyb3R0bGUgfSBmcm9tICdyeGpzL29wZXJhdG9ycyc7XG5pbXBvcnQgeyBJQmFzZUV2ZW50QXJncywgUGxhdGZvcm1VdGlsIH0gZnJvbSAnLi4vLi4vY29yZS91dGlscyc7XG5pbXBvcnQgeyBJRHJvcFN0cmF0ZWd5LCBJZ3hEZWZhdWx0RHJvcFN0cmF0ZWd5IH0gZnJvbSAnLi9kcmFnLWRyb3Auc3RyYXRlZ3knO1xuXG5lbnVtIERyYWdTY3JvbGxEaXJlY3Rpb24ge1xuICBVUCxcbiAgRE9XTixcbiAgTEVGVCxcbiAgUklHSFRcbn1cblxuZXhwb3J0IGVudW0gRHJhZ0RpcmVjdGlvbiB7XG4gICAgVkVSVElDQUwsXG4gICAgSE9SSVpPTlRBTCxcbiAgICBCT1RIXG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgSWd4RHJhZ0N1c3RvbUV2ZW50RGV0YWlscyB7XG4gICAgc3RhcnRYOiBudW1iZXI7XG4gICAgc3RhcnRZOiBudW1iZXI7XG4gICAgcGFnZVg6IG51bWJlcjtcbiAgICBwYWdlWTogbnVtYmVyO1xuICAgIG93bmVyOiBJZ3hEcmFnRGlyZWN0aXZlO1xuICAgIG9yaWdpbmFsRXZlbnQ6IGFueTtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBJRHJvcEJhc2VFdmVudEFyZ3MgZXh0ZW5kcyBJQmFzZUV2ZW50QXJncyB7XG4gICAgLyoqXG4gICAgICogUmVmZXJlbmNlIHRvIHRoZSBvcmlnaW5hbCBldmVudCB0aGF0IGNhdXNlZCB0aGUgZHJhZ2dhYmxlIGVsZW1lbnQgdG8gZW50ZXIgdGhlIGlneERyb3AgZWxlbWVudC5cbiAgICAgKiBDYW4gYmUgUG9pbnRlckV2ZW50LCBUb3VjaEV2ZW50IG9yIE1vdXNlRXZlbnQuXG4gICAgICovXG4gICAgb3JpZ2luYWxFdmVudDogYW55O1xuICAgIC8qKiBUaGUgb3duZXIgaWd4RHJvcCBkaXJlY3RpdmUgdGhhdCB0cmlnZ2VyZWQgdGhpcyBldmVudC4gKi9cbiAgICBvd25lcjogSWd4RHJvcERpcmVjdGl2ZTtcbiAgICAvKiogVGhlIGlneERyYWcgZGlyZWN0aXZlIGluc3RhbmNlZCBvbiBhbiBlbGVtZW50IHRoYXQgZW50ZXJlZCB0aGUgYXJlYSBvZiB0aGUgaWd4RHJvcCBlbGVtZW50ICovXG4gICAgZHJhZzogSWd4RHJhZ0RpcmVjdGl2ZTtcbiAgICAvKiogVGhlIGRhdGEgY29udGFpbmVkIGZvciB0aGUgZHJhZ2dhYmxlIGVsZW1lbnQgaW4gaWd4RHJhZyBkaXJlY3RpdmUuICovXG4gICAgZHJhZ0RhdGE6IGFueTtcbiAgICAvKiogVGhlIGluaXRpYWwgcG9zaXRpb24gb2YgdGhlIHBvaW50ZXIgb24gWCBheGlzIHdoZW4gdGhlIGRyYWdnZWQgZWxlbWVudCBiZWdhbiBtb3ZpbmcgKi9cbiAgICBzdGFydFg6IG51bWJlcjtcbiAgICAvKiogVGhlIGluaXRpYWwgcG9zaXRpb24gb2YgdGhlIHBvaW50ZXIgb24gWSBheGlzIHdoZW4gdGhlIGRyYWdnZWQgZWxlbWVudCBiZWdhbiBtb3ZpbmcgKi9cbiAgICBzdGFydFk6IG51bWJlcjtcbiAgICAvKipcbiAgICAgKiBUaGUgY3VycmVudCBwb3NpdGlvbiBvZiB0aGUgcG9pbnRlciBvbiBYIGF4aXMgd2hlbiB0aGUgZXZlbnQgd2FzIHRyaWdnZXJlZC5cbiAgICAgKiBOb3RlOiBUaGUgYnJvd3NlciBtaWdodCB0cmlnZ2VyIHRoZSBldmVudCB3aXRoIHNvbWUgZGVsYXkgYW5kIHBvaW50ZXIgd291bGQgYmUgYWxyZWFkeSBpbnNpZGUgdGhlIGlneERyb3AuXG4gICAgICovXG4gICAgcGFnZVg6IG51bWJlcjtcbiAgICAvKipcbiAgICAgKiBUaGUgY3VycmVudCBwb3NpdGlvbiBvZiB0aGUgcG9pbnRlciBvbiBZIGF4aXMgd2hlbiB0aGUgZXZlbnQgd2FzIHRyaWdnZXJlZC5cbiAgICAgKiBOb3RlOiBUaGUgYnJvd3NlciBtaWdodCB0cmlnZ2VyIHRoZSBldmVudCB3aXRoIHNvbWUgZGVsYXkgYW5kIHBvaW50ZXIgd291bGQgYmUgYWxyZWFkeSBpbnNpZGUgdGhlIGlneERyb3AuXG4gICAgICovXG4gICAgcGFnZVk6IG51bWJlcjtcbiAgICAvKipcbiAgICAgKiBUaGUgY3VycmVudCBwb3NpdGlvbiBvZiB0aGUgcG9pbnRlciBvbiBYIGF4aXMgcmVsYXRpdmUgdG8gdGhlIGNvbnRhaW5lciB0aGF0IGluaXRpYWxpemVzIHRoZSBpZ3hEcm9wLlxuICAgICAqIE5vdGU6IFRoZSBicm93c2VyIG1pZ2h0IHRyaWdnZXIgdGhlIGV2ZW50IHdpdGggc29tZSBkZWxheSBhbmQgcG9pbnRlciB3b3VsZCBiZSBhbHJlYWR5IGluc2lkZSB0aGUgaWd4RHJvcC5cbiAgICAgKi9cbiAgICBvZmZzZXRYOiBudW1iZXI7XG4gICAgLyoqXG4gICAgICogVGhlIGN1cnJlbnQgcG9zaXRpb24gb2YgdGhlIHBvaW50ZXIgb24gWSBheGlzIHJlbGF0aXZlIHRvIHRoZSBjb250YWluZXIgdGhhdCBpbml0aWFsaXplcyB0aGUgaWd4RHJvcC5cbiAgICAgKiBOb3RlOiBUaGUgYnJvd3NlciBtaWdodCB0cmlnZ2VyIHRoZSBldmVudCB3aXRoIHNvbWUgZGVsYXkgYW5kIHBvaW50ZXIgd291bGQgYmUgYWxyZWFkeSBpbnNpZGUgdGhlIGlneERyb3AuXG4gICAgICovXG4gICAgb2Zmc2V0WTogbnVtYmVyO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIElEcm9wRHJvcHBlZEV2ZW50QXJncyBleHRlbmRzIElEcm9wQmFzZUV2ZW50QXJncyB7XG4gICAgLyoqIFNwZWNpZmllcyBpZiB0aGUgZGVmYXVsdCBkcm9wIGxvZ2ljIHJlbGF0ZWQgdG8gdGhlIGV2ZW50IHNob3VsZCBiZSBjYW5jZWxlZC4gKi9cbiAgICBjYW5jZWw6IGJvb2xlYW47XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgSURyYWdCYXNlRXZlbnRBcmdzIGV4dGVuZHMgSUJhc2VFdmVudEFyZ3Mge1xuICAgIC8qKlxuICAgICAqIFJlZmVyZW5jZSB0byB0aGUgb3JpZ2luYWwgZXZlbnQgdGhhdCBjYXVzZWQgdGhlIGludGVyYWN0aW9uIHdpdGggdGhlIGVsZW1lbnQuXG4gICAgICogQ2FuIGJlIFBvaW50ZXJFdmVudCwgVG91Y2hFdmVudCBvciBNb3VzZUV2ZW50LlxuICAgICAqL1xuICAgIG9yaWdpbmFsRXZlbnQ6IFBvaW50ZXJFdmVudCB8IE1vdXNlRXZlbnQgfCBUb3VjaEV2ZW50O1xuICAgIC8qKiBUaGUgb3duZXIgaWd4RHJhZyBkaXJlY3RpdmUgdGhhdCB0cmlnZ2VyZWQgdGhpcyBldmVudC4gKi9cbiAgICBvd25lcjogSWd4RHJhZ0RpcmVjdGl2ZTtcbiAgICAvKiogVGhlIGluaXRpYWwgcG9zaXRpb24gb2YgdGhlIHBvaW50ZXIgb24gWCBheGlzIHdoZW4gdGhlIGRyYWdnZWQgZWxlbWVudCBiZWdhbiBtb3ZpbmcgKi9cbiAgICBzdGFydFg6IG51bWJlcjtcbiAgICAvKiogVGhlIGluaXRpYWwgcG9zaXRpb24gb2YgdGhlIHBvaW50ZXIgb24gWSBheGlzIHdoZW4gdGhlIGRyYWdnZWQgZWxlbWVudCBiZWdhbiBtb3ZpbmcgKi9cbiAgICBzdGFydFk6IG51bWJlcjtcbiAgICAvKipcbiAgICAgKiBUaGUgY3VycmVudCBwb3NpdGlvbiBvZiB0aGUgcG9pbnRlciBvbiBYIGF4aXMgd2hlbiB0aGUgZXZlbnQgd2FzIHRyaWdnZXJlZC5cbiAgICAgKiBOb3RlOiBUaGUgYnJvd3NlciBtaWdodCB0cmlnZ2VyIHRoZSBldmVudCB3aXRoIHNvbWUgZGVsYXkgYW5kIHBvaW50ZXIgd291bGQgYmUgYWxyZWFkeSBpbnNpZGUgdGhlIGlneERyb3AuXG4gICAgICovXG4gICAgcGFnZVg6IG51bWJlcjtcbiAgICAvKipcbiAgICAgKiBUaGUgY3VycmVudCBwb3NpdGlvbiBvZiB0aGUgcG9pbnRlciBvbiBZIGF4aXMgd2hlbiB0aGUgZXZlbnQgd2FzIHRyaWdnZXJlZC5cbiAgICAgKiBOb3RlOiBUaGUgYnJvd3NlciBtaWdodCB0cmlnZ2VyIHRoZSBldmVudCB3aXRoIHNvbWUgZGVsYXkgYW5kIHBvaW50ZXIgd291bGQgYmUgYWxyZWFkeSBpbnNpZGUgdGhlIGlneERyb3AuXG4gICAgICovXG4gICAgcGFnZVk6IG51bWJlcjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBJRHJhZ1N0YXJ0RXZlbnRBcmdzIGV4dGVuZHMgSURyYWdCYXNlRXZlbnRBcmdzIHtcbiAgICAvKiogU2V0IGlmIHRoZSB0aGUgZHJhZ2dpbmcgc2hvdWxkIGJlIGNhbmNlbGVkLiAqL1xuICAgIGNhbmNlbDogYm9vbGVhbjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBJRHJhZ01vdmVFdmVudEFyZ3MgZXh0ZW5kcyBJRHJhZ1N0YXJ0RXZlbnRBcmdzIHtcbiAgICAvKiogVGhlIG5ldyBwYWdlWCBwb3NpdGlvbiBvZiB0aGUgcG9pbnRlciB0aGF0IHRoZSBpZ3hEcmFnIHdpbGwgdXNlLiBJdCBjYW4gYmUgb3ZlcnJpZGRlbiB0byBsaW1pdCBkcmFnZ2VkIGVsZW1lbnQgWCBtb3ZlbWVudC4gKi9cbiAgICBuZXh0UGFnZVg6IG51bWJlcjtcbiAgICAvKiogVGhlIG5ldyBwYWdlWCBwb3NpdGlvbiBvZiB0aGUgcG9pbnRlciB0aGF0IHRoZSBpZ3hEcmFnIHdpbGwgdXNlLiBJdCBjYW4gYmUgb3ZlcnJpZGRlbiB0byBsaW1pdCBkcmFnZ2VkIGVsZW1lbnQgWSBtb3ZlbWVudC4gKi9cbiAgICBuZXh0UGFnZVk6IG51bWJlcjtcbn1cblxuXG5leHBvcnQgaW50ZXJmYWNlIElEcmFnR2hvc3RCYXNlRXZlbnRBcmdzIGV4dGVuZHMgSUJhc2VFdmVudEFyZ3Mge1xuICAgIC8qKiBUaGUgb3duZXIgaWd4RHJhZyBkaXJlY3RpdmUgdGhhdCB0cmlnZ2VyZWQgdGhpcyBldmVudC4gKi9cbiAgICBvd25lcjogSWd4RHJhZ0RpcmVjdGl2ZTtcbiAgICAvKiogSW5zdGFuY2UgdG8gdGhlIGdob3N0IGVsZW1lbnQgdGhhdCBpcyBjcmVhdGVkIHdoZW4gZHJhZ2dpbmcgc3RhcnRzLiAqL1xuICAgIGdob3N0RWxlbWVudDogYW55O1xuICAgIC8qKiBTZXQgaWYgdGhlIGdob3N0IGNyZWF0aW9uL2Rlc3RydWN0aW9uIHNob3VsZCBiZSBjYW5jZWxlZC4gKi9cbiAgICBjYW5jZWw6IGJvb2xlYW47XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgSURyYWdDdXN0b21UcmFuc2l0aW9uQXJncyB7XG4gICAgZHVyYXRpb24/OiBudW1iZXI7XG4gICAgdGltaW5nRnVuY3Rpb24/OiBzdHJpbmc7XG4gICAgZGVsYXk/OiBudW1iZXI7XG59XG5cbmV4cG9ydCBjbGFzcyBJZ3hEcmFnTG9jYXRpb24ge1xuICAgIHB1YmxpYyBwYWdlWDogbnVtYmVyO1xuICAgIHB1YmxpYyBwYWdlWTogbnVtYmVyO1xuXG4gICAgY29uc3RydWN0b3IocHJpdmF0ZSBfcGFnZVgsIHByaXZhdGUgX3BhZ2VZKSB7XG4gICAgICAgIHRoaXMucGFnZVggPSBwYXJzZUZsb2F0KF9wYWdlWCk7XG4gICAgICAgIHRoaXMucGFnZVkgPSBwYXJzZUZsb2F0KF9wYWdlWSk7XG4gICAgfVxufVxuXG5ARGlyZWN0aXZlKHtcbiAgICBzZWxlY3RvcjogJ1tpZ3hEcmFnSGFuZGxlXSdcbn0pXG5leHBvcnQgY2xhc3MgSWd4RHJhZ0hhbmRsZURpcmVjdGl2ZSB7XG5cbiAgICBASG9zdEJpbmRpbmcoJ2NsYXNzLmlneC1kcmFnX19oYW5kbGUnKVxuICAgIHB1YmxpYyBiYXNlQ2xhc3MgPSB0cnVlO1xuXG4gICAgY29uc3RydWN0b3IocHVibGljIGVsZW1lbnQ6IEVsZW1lbnRSZWY8YW55Pikge31cbn1cblxuQERpcmVjdGl2ZSh7XG4gICAgc2VsZWN0b3I6ICdbaWd4RHJhZ0lnbm9yZV0nXG59KVxuZXhwb3J0IGNsYXNzIElneERyYWdJZ25vcmVEaXJlY3RpdmUge1xuXG4gICAgQEhvc3RCaW5kaW5nKCdjbGFzcy5pZ3gtZHJhZ19faWdub3JlJylcbiAgICBwdWJsaWMgYmFzZUNsYXNzID0gdHJ1ZTtcblxuICAgIGNvbnN0cnVjdG9yKHB1YmxpYyBlbGVtZW50OiBFbGVtZW50UmVmPGFueT4pIHt9XG59XG5cbkBEaXJlY3RpdmUoe1xuICAgIGV4cG9ydEFzOiAnZHJhZycsXG4gICAgc2VsZWN0b3I6ICdbaWd4RHJhZ10nXG59KVxuZXhwb3J0IGNsYXNzIElneERyYWdEaXJlY3RpdmUgaW1wbGVtZW50cyBBZnRlckNvbnRlbnRJbml0LCBPbkRlc3Ryb3kge1xuICAgIC8qKlxuICAgICAqIC0gU2F2ZSBkYXRhIGluc2lkZSB0aGUgYGlneERyYWdgIGRpcmVjdGl2ZS4gVGhpcyBjYW4gYmUgc2V0IHdoZW4gaW5zdGFuY2luZyBgaWd4RHJhZ2Agb24gYW4gZWxlbWVudC5cbiAgICAgKiBgYGBodG1sXG4gICAgICogPGRpdiBbaWd4RHJhZ109XCJ7IHNvdXJjZTogbXlFbGVtZW50IH1cIj48L2Rpdj5cbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBJZ3hEcmFnRGlyZWN0aXZlXG4gICAgICovXG4gICAgQElucHV0KCdpZ3hEcmFnJylcbiAgICBwdWJsaWMgc2V0IGRhdGEodmFsdWU6IGFueSkge1xuICAgICAgICB0aGlzLl9kYXRhID0gdmFsdWU7XG4gICAgfVxuXG4gICAgcHVibGljIGdldCBkYXRhKCk6IGFueSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kYXRhO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFuIEBJbnB1dCBwcm9wZXJ0eSB0aGF0IGluZGljYXRlcyB3aGVuIHRoZSBkcmFnIHNob3VsZCBzdGFydC5cbiAgICAgKiBCeSBkZWZhdWx0IHRoZSBkcmFnIHN0YXJ0cyBhZnRlciB0aGUgZHJhZ2dhYmxlIGVsZW1lbnQgaXMgbW92ZWQgYnkgNXB4LlxuICAgICAqIGBgYGh0bWxcbiAgICAgKiA8ZGl2IGlneERyYWcgW2RyYWdUb2xlcmFuY2VdPVwiMTAwXCI+XG4gICAgICogICAgICAgICA8c3Bhbj5EcmFnIE1lITwvc3Bhbj5cbiAgICAgKiA8L2Rpdj5cbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBJZ3hEcmFnRGlyZWN0aXZlXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBwdWJsaWMgZHJhZ1RvbGVyYW5jZSA9IDU7XG5cbiAgICAvKipcbiAgICAgKiBBbiBASW5wdXQgcHJvcGVydHkgdGhhdCBpbmRpY2F0ZXMgdGhlIGRpcmVjdGlvbnMgdGhhdCB0aGUgZWxlbWVudCBjYW4gYmUgZHJhZ2dlZC5cbiAgICAgKiBCeSBkZWZhdWx0IGl0IGlzIHNldCB0byBib3RoIGhvcml6b250YWwgYW5kIHZlcnRpY2FsIGRpcmVjdGlvbnMuXG4gICAgICogYGBgaHRtbFxuICAgICAqIDxkaXYgaWd4RHJhZyBbZHJhZ0RpcmVjdGlvbl09XCJkcmFnRGlyXCI+XG4gICAgICogICAgICAgICA8c3Bhbj5EcmFnIE1lITwvc3Bhbj5cbiAgICAgKiA8L2Rpdj5cbiAgICAgKiBgYGBcbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogcHVibGljIGRyYWdEaXIgPSBEcmFnRGlyZWN0aW9uLkhPUklaT05UQUw7XG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgSWd4RHJhZ0RpcmVjdGl2ZVxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgcHVibGljIGRyYWdEaXJlY3Rpb24gPSBEcmFnRGlyZWN0aW9uLkJPVEg7XG5cbiAgICAvKipcbiAgICAgKiBBbiBASW5wdXQgcHJvcGVydHkgdGhhdCBwcm92aWRlIGEgd2F5IGZvciBpZ3hEcmFnIGFuZCBpZ3hEcm9wIHRvIGJlIGxpbmtlZCB0aHJvdWdoIGNoYW5uZWxzLlxuICAgICAqIEl0IGFjY2VwdHMgc2luZ2xlIHZhbHVlIG9yIGFuIGFycmF5IG9mIHZhbHVlcyBhbmQgZXZhbHVhdGVzIHRoZW4gdXNpbmcgc3RyaWN0IGVxdWFsaXR5LlxuICAgICAqIGBgYGh0bWxcbiAgICAgKiA8ZGl2IGlneERyYWcgW2RyYWdDaGFubmVsXT1cIidvZGQnXCI+XG4gICAgICogICAgICAgICA8c3Bhbj45NTwvc3Bhbj5cbiAgICAgKiA8L2Rpdj5cbiAgICAgKiA8ZGl2IGlneERyb3AgW2Ryb3BDaGFubmVsXT1cIlsnb2RkJywgJ2lycmF0aW9uYWwnXVwiPlxuICAgICAqICAgICAgICAgPHNwYW4+TnVtYmVycyBkcm9wIGFyZWEhPC9zcGFuPlxuICAgICAqIDwvZGl2PlxuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogQG1lbWJlcm9mIElneERyYWdEaXJlY3RpdmVcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIHB1YmxpYyBkcmFnQ2hhbm5lbDogbnVtYmVyIHwgc3RyaW5nIHwgbnVtYmVyW10gfCBzdHJpbmdbXTtcblxuICAgIC8qKlxuICAgICAqIEFuIEBJbnB1dCBwcm9wZXJ0eSB0aGF0IHNwZWNpZmllcyBpZiB0aGUgYmFzZSBlbGVtZW50IHNob3VsZCBub3QgYmUgbW92ZWQgYW5kIGEgZ2hvc3QgZWxlbWVudCBzaG91bGQgYmUgcmVuZGVyZWQgdGhhdCByZXByZXNlbnRzIGl0LlxuICAgICAqIEJ5IGRlZmF1bHQgaXQgaXMgc2V0IHRvIGB0cnVlYC5cbiAgICAgKiBJZiBpdCBpcyBzZXQgdG8gYGZhbHNlYCB3aGVuIGRyYWdnaW5nIHRoZSBiYXNlIGVsZW1lbnQgaXMgbW92ZWQgaW5zdGVhZCBhbmQgbm8gZ2hvc3QgZWxlbWVudHMgYXJlIHJlbmRlcmVkLlxuICAgICAqIGBgYGh0bWxcbiAgICAgKiA8ZGl2IGlneERyYWcgW2dob3N0XT1cImZhbHNlXCI+XG4gICAgICogICAgICA8c3Bhbj5EcmFnIE1lITwvc3Bhbj5cbiAgICAgKiA8L2Rpdj5cbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBJZ3hEcmFnRGlyZWN0aXZlXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBwdWJsaWMgZ2hvc3QgPSB0cnVlO1xuXG4gICAgLyoqXG4gICAgICogU2V0cyBhIGN1c3RvbSBjbGFzcyB0aGF0IHdpbGwgYmUgYWRkZWQgdG8gdGhlIGBnaG9zdEVsZW1lbnRgIGVsZW1lbnQuXG4gICAgICogYGBgaHRtbFxuICAgICAqIDxkaXYgaWd4RHJhZyBbZ2hvc3RDbGFzc109XCInZ2hvc3RFbGVtZW50J1wiPlxuICAgICAqICAgICAgICAgPHNwYW4+RHJhZyBNZSE8L3NwYW4+XG4gICAgICogPC9kaXY+XG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgSWd4RHJhZ0RpcmVjdGl2ZVxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgcHVibGljIGdob3N0Q2xhc3MgPSAnJztcblxuXG4gICAgLyoqXG4gICAgICogQW4gQElucHV0IHByb3BlcnR5IHRoYXQgc3BlY2lmaWVzIGEgdGVtcGxhdGUgZm9yIHRoZSBnaG9zdCBlbGVtZW50IGNyZWF0ZWQgd2hlbiBkcmFnZ2luZyBzdGFydHMgYW5kIGBnaG9zdGAgaXMgdHJ1ZS5cbiAgICAgKiBCeSBkZWZhdWx0IGEgY2xvbmUgb2YgdGhlIGJhc2UgZWxlbWVudCB0aGUgaWd4RHJhZyBpcyBpbnN0YW5jZWQgaXMgY3JlYXRlZC5cbiAgICAgKiBgYGBodG1sXG4gICAgICogPGRpdiBpZ3hEcmFnIFtnaG9zdFRlbXBsYXRlXT1cImN1c3RvbUdob3N0XCI+XG4gICAgICogICAgICAgICA8c3Bhbj5EcmFnIE1lITwvc3Bhbj5cbiAgICAgKiA8L2Rpdj5cbiAgICAgKiA8bmctdGVtcGxhdGUgI2N1c3RvbUdob3N0PlxuICAgICAqICAgICAgPGRpdiBjbGFzcz1cImN1c3RvbUdob3N0U3R5bGVcIj5cbiAgICAgKiAgICAgICAgICA8c3Bhbj5JIGFtIGJlaW5nIGRyYWdnZWQhPC9zcGFuPlxuICAgICAqICAgICAgPC9kaXY+XG4gICAgICogPC9uZy10ZW1wbGF0ZT5cbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBJZ3hEcmFnRGlyZWN0aXZlXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBwdWJsaWMgZ2hvc3RUZW1wbGF0ZTogVGVtcGxhdGVSZWY8YW55PjtcblxuICAgIC8qKlxuICAgICAqIEFuIEBJbnB1dCBwcm9wZXJ0eSB0aGF0IHNldHMgdGhlIGVsZW1lbnQgdG8gd2hpY2ggdGhlIGRyYWdnZWQgZWxlbWVudCB3aWxsIGJlIGFwcGVuZGVkLlxuICAgICAqIEJ5IGRlZmF1bHQgaXQncyBzZXQgdG8gbnVsbCBhbmQgdGhlIGRyYWdnZWQgZWxlbWVudCBpcyBhcHBlbmRlZCB0byB0aGUgYm9keS5cbiAgICAgKiBgYGBodG1sXG4gICAgICogPGRpdiAjaG9zdERpdj48L2Rpdj5cbiAgICAgKiA8ZGl2IGlneERyYWcgW2dob3N0SG9zdF09XCJob3N0RGl2XCI+XG4gICAgICogICAgICAgICA8c3Bhbj5EcmFnIE1lITwvc3Bhbj5cbiAgICAgKiA8L2Rpdj5cbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBJZ3hEcmFnRGlyZWN0aXZlXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBwdWJsaWMgZ2hvc3RIb3N0O1xuXG4gICAgLyoqXG4gICAgICogQW4gQElucHV0IGFzc2lnbmluZyBhIHNjcm9sbCBjb250YWluZXIgdG8gdGhlIGRyYWdnZWQgZWxlbWVudC4gQnkgZGVmYXVsdCBpdHMgdGhlIHdpbmRvdy5cbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIHB1YmxpYyBzY3JvbGxDb250YWluZXI6IEhUTUxFbGVtZW50ID1udWxsXG5cbiAgICAvKipcbiAgICAgKiBFdmVudCB0cmlnZ2VyZWQgd2hlbiB0aGUgZHJhZ2dhYmxlIGVsZW1lbnQgZHJhZyBzdGFydHMuXG4gICAgICogYGBgaHRtbFxuICAgICAqIDxkaXYgaWd4RHJhZyAoZHJhZ1N0YXJ0KT1cIm9uRHJhZ1N0YXJ0KClcIj5cbiAgICAgKiAgICAgICAgIDxzcGFuPkRyYWcgTWUhPC9zcGFuPlxuICAgICAqIDwvZGl2PlxuICAgICAqIGBgYFxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiBwdWJsaWMgb25EcmFnU3RhcnQoKXtcbiAgICAgKiAgICAgIGFsZXJ0KFwiVGhlIGRyYWcgaGFzIHN0YXJlZCFcIik7XG4gICAgICogfVxuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogQG1lbWJlcm9mIElneERyYWdEaXJlY3RpdmVcbiAgICAgKi9cbiAgICBAT3V0cHV0KClcbiAgICBwdWJsaWMgZHJhZ1N0YXJ0ID0gbmV3IEV2ZW50RW1pdHRlcjxJRHJhZ1N0YXJ0RXZlbnRBcmdzPigpO1xuXG4gICAgLyoqXG4gICAgICogRXZlbnQgdHJpZ2dlcmVkIHdoZW4gdGhlIGRyYWdnYWJsZSBlbGVtZW50IGhhcyBiZWVuIG1vdmVkLlxuICAgICAqIGBgYGh0bWxcbiAgICAgKiA8ZGl2IGlneERyYWcgIChkcmFnTW92ZSk9XCJvbkRyYWdNb3ZlKClcIj5cbiAgICAgKiAgICAgICAgIDxzcGFuPkRyYWcgTWUhPC9zcGFuPlxuICAgICAqIDwvZGl2PlxuICAgICAqIGBgYFxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiBwdWJsaWMgb25EcmFnTW92ZSgpe1xuICAgICAqICAgICAgYWxlcnQoXCJUaGUgZWxlbWVudCBoYXMgbW92ZWQhXCIpO1xuICAgICAqIH1cbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBJZ3hEcmFnRGlyZWN0aXZlXG4gICAgICovXG4gICAgQE91dHB1dCgpXG4gICAgcHVibGljIGRyYWdNb3ZlID0gbmV3IEV2ZW50RW1pdHRlcjxJRHJhZ01vdmVFdmVudEFyZ3M+KCk7XG5cbiAgICAvKipcbiAgICAgKiBFdmVudCB0cmlnZ2VyZWQgd2hlbiB0aGUgZHJhZ2dhYmxlIGVsZW1lbnQgaXMgcmVsZWFzZWQuXG4gICAgICogYGBgaHRtbFxuICAgICAqIDxkaXYgaWd4RHJhZyAoZHJhZ0VuZCk9XCJvbkRyYWdFbmQoKVwiPlxuICAgICAqICAgICAgICAgPHNwYW4+RHJhZyBNZSE8L3NwYW4+XG4gICAgICogPC9kaXY+XG4gICAgICogYGBgXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIHB1YmxpYyBvbkRyYWdFbmQoKXtcbiAgICAgKiAgICAgIGFsZXJ0KFwiVGhlIGRyYWcgaGFzIGVuZGVkIVwiKTtcbiAgICAgKiB9XG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgSWd4RHJhZ0RpcmVjdGl2ZVxuICAgICAqL1xuICAgIEBPdXRwdXQoKVxuICAgIHB1YmxpYyBkcmFnRW5kID0gbmV3IEV2ZW50RW1pdHRlcjxJRHJhZ0Jhc2VFdmVudEFyZ3M+KCk7XG5cbiAgICAvKipcbiAgICAgKiBFdmVudCB0cmlnZ2VyZWQgd2hlbiB0aGUgZHJhZ2dhYmxlIGVsZW1lbnQgaXMgY2xpY2tlZC5cbiAgICAgKiBgYGBodG1sXG4gICAgICogPGRpdiBpZ3hEcmFnIChkcmFnQ2xpY2spPVwib25EcmFnQ2xpY2soKVwiPlxuICAgICAqICAgICAgICAgPHNwYW4+RHJhZyBNZSE8L3NwYW4+XG4gICAgICogPC9kaXY+XG4gICAgICogYGBgXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIHB1YmxpYyBvbkRyYWdDbGljaygpe1xuICAgICAqICAgICAgYWxlcnQoXCJUaGUgZWxlbWVudCBoYXMgYmVlbiBjbGlja2VkIVwiKTtcbiAgICAgKiB9XG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgSWd4RHJhZ0RpcmVjdGl2ZVxuICAgICAqL1xuICAgIEBPdXRwdXQoKVxuICAgIHB1YmxpYyBkcmFnQ2xpY2sgPSBuZXcgRXZlbnRFbWl0dGVyPElEcmFnQmFzZUV2ZW50QXJncz4oKTtcblxuICAgIC8qKlxuICAgICAqIEV2ZW50IHRyaWdnZXJlZCB3aGVuIHRoZSBkcmFnIGdob3N0IGVsZW1lbnQgaXMgY3JlYXRlZC5cbiAgICAgKiBgYGBodG1sXG4gICAgICogPGRpdiBpZ3hEcmFnIChnaG9zdENyZWF0ZSk9XCJnaG9zdENyZWF0ZWQoKVwiPlxuICAgICAqICAgICAgICAgPHNwYW4+RHJhZyBNZSE8L3NwYW4+XG4gICAgICogPC9kaXY+XG4gICAgICogYGBgXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIHB1YmxpYyBnaG9zdENyZWF0ZWQoKXtcbiAgICAgKiAgICAgIGFsZXJ0KFwiVGhlIGdob3N0IGhhcyBiZWVuIGNyZWF0ZWQhXCIpO1xuICAgICAqIH1cbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBJZ3hEcmFnRGlyZWN0aXZlXG4gICAgICovXG4gICAgQE91dHB1dCgpXG4gICAgcHVibGljIGdob3N0Q3JlYXRlID0gbmV3IEV2ZW50RW1pdHRlcjxJRHJhZ0dob3N0QmFzZUV2ZW50QXJncz4oKTtcblxuICAgIC8qKlxuICAgICAqIEV2ZW50IHRyaWdnZXJlZCB3aGVuIHRoZSBkcmFnIGdob3N0IGVsZW1lbnQgaXMgY3JlYXRlZC5cbiAgICAgKiBgYGBodG1sXG4gICAgICogPGRpdiBpZ3hEcmFnIChnaG9zdERlc3Ryb3kpPVwiZ2hvc3REZXN0cm95ZWQoKVwiPlxuICAgICAqICAgICAgICAgPHNwYW4+RHJhZyBNZSE8L3NwYW4+XG4gICAgICogPC9kaXY+XG4gICAgICogYGBgXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIHB1YmxpYyBnaG9zdERlc3Ryb3llZCgpe1xuICAgICAqICAgICAgYWxlcnQoXCJUaGUgZ2hvc3QgaGFzIGJlZW4gZGVzdHJveWVkIVwiKTtcbiAgICAgKiB9XG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgSWd4RHJhZ0RpcmVjdGl2ZVxuICAgICAqL1xuICAgIEBPdXRwdXQoKVxuICAgIHB1YmxpYyBnaG9zdERlc3Ryb3kgPSBuZXcgRXZlbnRFbWl0dGVyPElEcmFnR2hvc3RCYXNlRXZlbnRBcmdzPigpO1xuXG4gICAgLyoqXG4gICAgICogRXZlbnQgdHJpZ2dlcmVkIGFmdGVyIHRoZSBkcmFnZ2FibGUgZWxlbWVudCBpcyByZWxlYXNlZCBhbmQgYWZ0ZXIgaXRzIGFuaW1hdGlvbiBoYXMgZmluaXNoZWQuXG4gICAgICogYGBgaHRtbFxuICAgICAqIDxkaXYgaWd4RHJhZyAodHJhbnNpdGlvbmVkKT1cIm9uTW92ZUVuZCgpXCI+XG4gICAgICogICAgICAgICA8c3Bhbj5EcmFnIE1lITwvc3Bhbj5cbiAgICAgKiA8L2Rpdj5cbiAgICAgKiBgYGBcbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogcHVibGljIG9uTW92ZUVuZCgpe1xuICAgICAqICAgICAgYWxlcnQoXCJUaGUgbW92ZSBoYXMgZW5kZWQhXCIpO1xuICAgICAqIH1cbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBJZ3hEcmFnRGlyZWN0aXZlXG4gICAgICovXG4gICAgQE91dHB1dCgpXG4gICAgcHVibGljIHRyYW5zaXRpb25lZCA9IG5ldyBFdmVudEVtaXR0ZXI8SURyYWdCYXNlRXZlbnRBcmdzPigpO1xuXG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIEBDb250ZW50Q2hpbGRyZW4oSWd4RHJhZ0hhbmRsZURpcmVjdGl2ZSwgeyBkZXNjZW5kYW50czogdHJ1ZSB9KVxuICAgIHB1YmxpYyBkcmFnSGFuZGxlczogUXVlcnlMaXN0PElneERyYWdIYW5kbGVEaXJlY3RpdmU+O1xuXG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIEBDb250ZW50Q2hpbGRyZW4oSWd4RHJhZ0lnbm9yZURpcmVjdGl2ZSwgeyBkZXNjZW5kYW50czogdHJ1ZSB9KVxuICAgIHB1YmxpYyBkcmFnSWdub3JlZEVsZW1zOiBRdWVyeUxpc3Q8SWd4RHJhZ0lnbm9yZURpcmVjdGl2ZT47XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgQEhvc3RCaW5kaW5nKCdjbGFzcy5pZ3gtZHJhZycpXG4gICAgcHVibGljIGJhc2VDbGFzcyA9IHRydWU7XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgQEhvc3RCaW5kaW5nKCdjbGFzcy5pZ3gtZHJhZy0tc2VsZWN0LWRpc2FibGVkJylcbiAgICBwdWJsaWMgc2VsZWN0RGlzYWJsZWQgPSBmYWxzZTtcblxuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgY3VycmVudCBsb2NhdGlvbiBvZiB0aGUgZWxlbWVudCByZWxhdGl2ZSB0byB0aGUgcGFnZS5cbiAgICAgKi9cbiAgICBwdWJsaWMgZ2V0IGxvY2F0aW9uKCk6IElneERyYWdMb2NhdGlvbiB7XG4gICAgICAgIHJldHVybiBuZXcgSWd4RHJhZ0xvY2F0aW9uKHRoaXMucGFnZVgsIHRoaXMucGFnZVkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIG9yaWdpbmFsIGxvY2F0aW9uIG9mIHRoZSBlbGVtZW50IGJlZm9yZSBkcmFnZ2luZyBzdGFydGVkLlxuICAgICAqL1xuICAgIHB1YmxpYyBnZXQgb3JpZ2luTG9jYXRpb24oKTogSWd4RHJhZ0xvY2F0aW9uIHtcbiAgICAgICAgcmV0dXJuIG5ldyBJZ3hEcmFnTG9jYXRpb24odGhpcy5iYXNlT3JpZ2luTGVmdCwgdGhpcy5iYXNlT3JpZ2luVG9wKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgcHVibGljIGdldCBwb2ludGVyRXZlbnRzRW5hYmxlZCgpIHtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiBQb2ludGVyRXZlbnQgIT09ICd1bmRlZmluZWQnO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBwdWJsaWMgZ2V0IHRvdWNoRXZlbnRzRW5hYmxlZCgpIHtcbiAgICAgICAgcmV0dXJuICdvbnRvdWNoc3RhcnQnIGluIHdpbmRvdztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgcHVibGljIGdldCBwYWdlWCgpIHtcbiAgICAgICAgaWYgKHRoaXMuZ2hvc3QgJiYgdGhpcy5naG9zdEVsZW1lbnQpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdob3N0TGVmdDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5iYXNlTGVmdCArIHRoaXMud2luZG93U2Nyb2xsTGVmdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgcHVibGljIGdldCBwYWdlWSgpIHtcbiAgICAgICAgaWYgKHRoaXMuZ2hvc3QgJiYgdGhpcy5naG9zdEVsZW1lbnQpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdob3N0VG9wO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmJhc2VUb3AgKyB0aGlzLndpbmRvd1Njcm9sbFRvcDtcbiAgICB9XG5cbiAgICBwcm90ZWN0ZWQgZ2V0IGJhc2VMZWZ0KCk6IG51bWJlciB7XG4gICAgICAgIHJldHVybiB0aGlzLmVsZW1lbnQubmF0aXZlRWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5sZWZ0O1xuICAgIH1cblxuICAgIHByb3RlY3RlZCBnZXQgYmFzZVRvcCgpOiBudW1iZXIge1xuICAgICAgICByZXR1cm4gdGhpcy5lbGVtZW50Lm5hdGl2ZUVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkudG9wO1xuICAgIH1cblxuICAgIHByb3RlY3RlZCBnZXQgYmFzZU9yaWdpbkxlZnQoKTogbnVtYmVyIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYmFzZUxlZnQgLSB0aGlzLmdldFRyYW5zZm9ybVgodGhpcy5lbGVtZW50Lm5hdGl2ZUVsZW1lbnQpO1xuICAgIH1cblxuICAgIHByb3RlY3RlZCBnZXQgYmFzZU9yaWdpblRvcCgpOiBudW1iZXIge1xuICAgICAgICByZXR1cm4gdGhpcy5iYXNlVG9wIC0gdGhpcy5nZXRUcmFuc2Zvcm1ZKHRoaXMuZWxlbWVudC5uYXRpdmVFbGVtZW50KTtcbiAgICB9XG5cbiAgICBwcm90ZWN0ZWQgc2V0IGdob3N0TGVmdChwYWdlWDogbnVtYmVyKSB7XG4gICAgICAgIGlmICh0aGlzLmdob3N0RWxlbWVudCkge1xuICAgICAgICAgICAgLy8gV2UgbmVlZCB0byB0YWtlIGludG8gYWNjb3VudCBtYXJnaW5MZWZ0LCBzaW5jZSB0b3Agc3R5bGUgZG9lcyBub3QgaW5jbHVkZSBtYXJnaW4sIGJ1dCBwYWdlWCBpbmNsdWRlcyB0aGUgbWFyZ2luLlxuICAgICAgICAgICAgY29uc3QgZ2hvc3RNYXJnaW5MZWZ0ID0gcGFyc2VJbnQoZG9jdW1lbnQuZGVmYXVsdFZpZXcuZ2V0Q29tcHV0ZWRTdHlsZSh0aGlzLmdob3N0RWxlbWVudClbJ21hcmdpbi1sZWZ0J10sIDEwKTtcbiAgICAgICAgICAgIC8vIElmIGdob3N0IGhvc3QgaXMgZGVmaW5lZCBpdCBuZWVkcyB0byBiZSB0YWtlbiBpbnRvIGFjY291bnQuXG4gICAgICAgICAgICB0aGlzLmdob3N0RWxlbWVudC5zdHlsZS5sZWZ0ID0gKHBhZ2VYIC0gZ2hvc3RNYXJnaW5MZWZ0IC0gdGhpcy5fZ2hvc3RIb3N0WCkgKyAncHgnO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcHJvdGVjdGVkIGdldCBnaG9zdExlZnQoKSB7XG4gICAgICAgIHJldHVybiBwYXJzZUludCh0aGlzLmdob3N0RWxlbWVudC5zdHlsZS5sZWZ0LCAxMCkgKyB0aGlzLl9naG9zdEhvc3RYO1xuICAgIH1cblxuICAgIHByb3RlY3RlZCBzZXQgZ2hvc3RUb3AocGFnZVk6IG51bWJlcikge1xuICAgICAgICBpZiAodGhpcy5naG9zdEVsZW1lbnQpIHtcbiAgICAgICAgICAgIC8vIFdlIG5lZWQgdG8gdGFrZSBpbnRvIGFjY291bnQgbWFyZ2luVG9wLCBzaW5jZSB0b3Agc3R5bGUgZG9lcyBub3QgaW5jbHVkZSBtYXJnaW4sIGJ1dCBwYWdlWSBpbmNsdWRlcyB0aGUgbWFyZ2luLlxuICAgICAgICAgICAgY29uc3QgZ2hvc3RNYXJnaW5Ub3AgPSBwYXJzZUludChkb2N1bWVudC5kZWZhdWx0Vmlldy5nZXRDb21wdXRlZFN0eWxlKHRoaXMuZ2hvc3RFbGVtZW50KVsnbWFyZ2luLXRvcCddLCAxMCk7XG4gICAgICAgICAgICAvLyBJZiBnaG9zdCBob3N0IGlzIGRlZmluZWQgaXQgbmVlZHMgdG8gYmUgdGFrZW4gaW50byBhY2NvdW50LlxuICAgICAgICAgICAgdGhpcy5naG9zdEVsZW1lbnQuc3R5bGUudG9wID0gKHBhZ2VZIC0gZ2hvc3RNYXJnaW5Ub3AgLSB0aGlzLl9naG9zdEhvc3RZKSArICdweCc7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwcm90ZWN0ZWQgZ2V0IGdob3N0VG9wKCkge1xuICAgICAgICByZXR1cm4gcGFyc2VJbnQodGhpcy5naG9zdEVsZW1lbnQuc3R5bGUudG9wLCAxMCkgKyB0aGlzLl9naG9zdEhvc3RZO1xuICAgIH1cblxuICAgIHByb3RlY3RlZCBnZXQgd2luZG93U2Nyb2xsVG9wKCkge1xuICAgICAgICByZXR1cm4gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnNjcm9sbFRvcCB8fCB3aW5kb3cuc2Nyb2xsWTtcbiAgICB9XG5cbiAgICBwcm90ZWN0ZWQgZ2V0IHdpbmRvd1Njcm9sbExlZnQoKSB7XG4gICAgICAgIHJldHVybiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc2Nyb2xsTGVmdCB8fCB3aW5kb3cuc2Nyb2xsWDtcbiAgICB9XG5cbiAgICBwcm90ZWN0ZWQgZ2V0IHdpbmRvd1Njcm9sbEhlaWdodCgpIHtcbiAgICAgICAgcmV0dXJuIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zY3JvbGxIZWlnaHQ7XG4gICAgfVxuXG4gICAgcHJvdGVjdGVkIGdldCB3aW5kb3dTY3JvbGxXaWR0aCgpIHtcbiAgICAgICAgcmV0dXJuIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zY3JvbGxXaWR0aDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgcHVibGljIGRlZmF1bHRSZXR1cm5EdXJhdGlvbiA9ICcwLjVzJztcblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBwdWJsaWMgZ2hvc3RFbGVtZW50O1xuXG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIHB1YmxpYyBhbmltSW5Qcm9ncmVzcyA9IGZhbHNlO1xuXG4gICAgcHJvdGVjdGVkIGdob3N0Q29udGV4dDogYW55ID0gbnVsbDtcbiAgICBwcm90ZWN0ZWQgX3N0YXJ0WCA9IDA7XG4gICAgcHJvdGVjdGVkIF9zdGFydFkgPSAwO1xuICAgIHByb3RlY3RlZCBfbGFzdFggPSAwO1xuICAgIHByb3RlY3RlZCBfbGFzdFkgPSAwO1xuICAgIHByb3RlY3RlZCBfZHJhZ1N0YXJ0ZWQgPSBmYWxzZTtcblxuICAgIC8qKiBEcmFnIGdob3N0IHJlbGF0ZWQgcHJvcGVydGllcyAqL1xuICAgIHByb3RlY3RlZCBfZGVmYXVsdE9mZnNldFg7XG4gICAgcHJvdGVjdGVkIF9kZWZhdWx0T2Zmc2V0WTtcbiAgICBwcm90ZWN0ZWQgX29mZnNldFg7XG4gICAgcHJvdGVjdGVkIF9vZmZzZXRZO1xuICAgIHByb3RlY3RlZCBfZ2hvc3RTdGFydFg7XG4gICAgcHJvdGVjdGVkIF9naG9zdFN0YXJ0WTtcbiAgICBwcm90ZWN0ZWQgX2dob3N0SG9zdFggPSAwO1xuICAgIHByb3RlY3RlZCBfZ2hvc3RIb3N0WSA9IDA7XG4gICAgcHJvdGVjdGVkIF9keW5hbWljR2hvc3RSZWY7XG5cbiAgICBwcm90ZWN0ZWQgX3BvaW50ZXJEb3duSWQgPSBudWxsO1xuICAgIHByb3RlY3RlZCBfY2xpY2tlZCA9IGZhbHNlO1xuICAgIHByb3RlY3RlZCBfbGFzdERyb3BBcmVhID0gbnVsbDtcblxuICAgIHByb3RlY3RlZCBfZGVzdHJveSA9IG5ldyBTdWJqZWN0PGJvb2xlYW4+KCk7XG4gICAgcHJvdGVjdGVkIF9yZW1vdmVPbkRlc3Ryb3kgPSB0cnVlO1xuICAgIHByb3RlY3RlZCBfZGF0YTogYW55O1xuICAgIHByb3RlY3RlZCBfc2Nyb2xsQ29udGFpbmVyID0gbnVsbDtcbiAgICBwcm90ZWN0ZWQgX29yaWdpbmFsU2Nyb2xsQ29udGFpbmVyV2lkdGggPSAwO1xuICAgIHByb3RlY3RlZCBfb3JpZ2luYWxTY3JvbGxDb250YWluZXJIZWlnaHQgPSAwO1xuICAgIHByb3RlY3RlZCBfc2Nyb2xsQ29udGFpbmVyU3RlcCA9IDU7XG4gICAgcHJvdGVjdGVkIF9zY3JvbGxDb250YWluZXJTdGVwTXMgPSAxMDtcbiAgICBwcm90ZWN0ZWQgX3Njcm9sbENvbnRhaW5lclRocmVzaG9sZCA9IDI1O1xuICAgIHByb3RlY3RlZCBfY29udGFpbmVyU2Nyb2xsSW50ZXJ2YWxJZCA9IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBBbiBASW5wdXQgcHJvcGVydHkgdGhhdCBzcGVjaWZpZXMgdGhlIG9mZnNldCBvZiB0aGUgZHJhZ2dlZCBlbGVtZW50IHJlbGF0aXZlIHRvIHRoZSBtb3VzZSBpbiBwaXhlbHMuXG4gICAgICogQnkgZGVmYXVsdCBpdCdzIHRha2luZyB0aGUgcmVsYXRpdmUgcG9zaXRpb24gdG8gdGhlIG1vdXNlIHdoZW4gdGhlIGRyYWcgc3RhcnRlZCBhbmQga2VlcHMgaXQgdGhlIHNhbWUuXG4gICAgICogYGBgaHRtbFxuICAgICAqIDxkaXYgI2hvc3REaXY+PC9kaXY+XG4gICAgICogPGRpdiBpZ3hEcmFnIFtnaG9zdE9mZnNldFhdPVwiMFwiPlxuICAgICAqICAgICAgICAgPHNwYW4+RHJhZyBNZSE8L3NwYW4+XG4gICAgICogPC9kaXY+XG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgSWd4RHJhZ0RpcmVjdGl2ZVxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgcHVibGljIHNldCBnaG9zdE9mZnNldFgodmFsdWUpIHtcbiAgICAgICAgdGhpcy5fb2Zmc2V0WCA9IHBhcnNlSW50KHZhbHVlLCAxMCk7XG4gICAgfVxuXG4gICAgcHVibGljIGdldCBnaG9zdE9mZnNldFgoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9vZmZzZXRYICE9PSB1bmRlZmluZWQgPyB0aGlzLl9vZmZzZXRYIDogdGhpcy5fZGVmYXVsdE9mZnNldFg7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQW4gQElucHV0IHByb3BlcnR5IHRoYXQgc3BlY2lmaWVzIHRoZSBvZmZzZXQgb2YgdGhlIGRyYWdnZWQgZWxlbWVudCByZWxhdGl2ZSB0byB0aGUgbW91c2UgaW4gcGl4ZWxzLlxuICAgICAqIEJ5IGRlZmF1bHQgaXQncyB0YWtpbmcgdGhlIHJlbGF0aXZlIHBvc2l0aW9uIHRvIHRoZSBtb3VzZSB3aGVuIHRoZSBkcmFnIHN0YXJ0ZWQgYW5kIGtlZXBzIGl0IHRoZSBzYW1lLlxuICAgICAqIGBgYGh0bWxcbiAgICAgKiA8ZGl2ICNob3N0RGl2PjwvZGl2PlxuICAgICAqIDxkaXYgaWd4RHJhZyBbZ2hvc3RPZmZzZXRZXT1cIjBcIj5cbiAgICAgKiAgICAgICAgIDxzcGFuPkRyYWcgTWUhPC9zcGFuPlxuICAgICAqIDwvZGl2PlxuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogQG1lbWJlcm9mIElneERyYWdEaXJlY3RpdmVcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIHB1YmxpYyBzZXQgZ2hvc3RPZmZzZXRZKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuX29mZnNldFkgPSBwYXJzZUludCh2YWx1ZSwgMTApO1xuICAgIH1cblxuICAgIHB1YmxpYyBnZXQgZ2hvc3RPZmZzZXRZKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fb2Zmc2V0WSAhPT0gdW5kZWZpbmVkID8gdGhpcy5fb2Zmc2V0WSA6IHRoaXMuX2RlZmF1bHRPZmZzZXRZIDtcbiAgICB9XG5cbiAgICBjb25zdHJ1Y3RvcihcbiAgICAgICAgcHVibGljIGNkcjogQ2hhbmdlRGV0ZWN0b3JSZWYsXG4gICAgICAgIHB1YmxpYyBlbGVtZW50OiBFbGVtZW50UmVmLFxuICAgICAgICBwdWJsaWMgdmlld0NvbnRhaW5lcjogVmlld0NvbnRhaW5lclJlZixcbiAgICAgICAgcHVibGljIHpvbmU6IE5nWm9uZSxcbiAgICAgICAgcHVibGljIHJlbmRlcmVyOiBSZW5kZXJlcjIsXG4gICAgICAgIHByb3RlY3RlZCBwbGF0Zm9ybVV0aWw6IFBsYXRmb3JtVXRpbCxcbiAgICApIHtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgcHVibGljIG5nQWZ0ZXJDb250ZW50SW5pdCgpIHtcbiAgICAgICAgaWYgKCF0aGlzLmRyYWdIYW5kbGVzIHx8ICF0aGlzLmRyYWdIYW5kbGVzLmxlbmd0aCApIHtcbiAgICAgICAgICAgIC8vIFNldCB1c2VyIHNlbGVjdCBub25lIHRvIHRoZSB3aG9sZSBkcmFnZ2FibGUgZWxlbWVudCBpZiBubyBkcmFnIGhhbmRsZXMgYXJlIGRlZmluZWQuXG4gICAgICAgICAgICB0aGlzLnNlbGVjdERpc2FibGVkID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEJpbmQgZXZlbnRzXG4gICAgICAgIHRoaXMuem9uZS5ydW5PdXRzaWRlQW5ndWxhcigoKSA9PiB7XG4gICAgICAgICAgICBpZiAoIXRoaXMucGxhdGZvcm1VdGlsLmlzQnJvd3Nlcikge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHRhcmdldEVsZW1lbnRzID0gdGhpcy5kcmFnSGFuZGxlcyAmJiB0aGlzLmRyYWdIYW5kbGVzLmxlbmd0aCA/XG4gICAgICAgICAgICAgICAgdGhpcy5kcmFnSGFuZGxlcy5tYXAoKGl0ZW0pID0+IGl0ZW0uZWxlbWVudC5uYXRpdmVFbGVtZW50KSA6IFt0aGlzLmVsZW1lbnQubmF0aXZlRWxlbWVudF07XG4gICAgICAgICAgICB0YXJnZXRFbGVtZW50cy5mb3JFYWNoKChlbGVtZW50KSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMucG9pbnRlckV2ZW50c0VuYWJsZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgZnJvbUV2ZW50KGVsZW1lbnQsICdwb2ludGVyZG93bicpLnBpcGUodGFrZVVudGlsKHRoaXMuX2Rlc3Ryb3kpKVxuICAgICAgICAgICAgICAgICAgICAuc3Vic2NyaWJlKChyZXMpID0+IHRoaXMub25Qb2ludGVyRG93bihyZXMpKTtcblxuICAgICAgICAgICAgICAgICAgICBmcm9tRXZlbnQoZWxlbWVudCwgJ3BvaW50ZXJtb3ZlJykucGlwZShcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm90dGxlKCgpID0+IGludGVydmFsKDAsIGFuaW1hdGlvbkZyYW1lU2NoZWR1bGVyKSksXG4gICAgICAgICAgICAgICAgICAgICAgICB0YWtlVW50aWwodGhpcy5fZGVzdHJveSlcbiAgICAgICAgICAgICAgICAgICAgKS5zdWJzY3JpYmUoKHJlcykgPT4gdGhpcy5vblBvaW50ZXJNb3ZlKHJlcykpO1xuXG4gICAgICAgICAgICAgICAgICAgIGZyb21FdmVudChlbGVtZW50LCAncG9pbnRlcnVwJykucGlwZSh0YWtlVW50aWwodGhpcy5fZGVzdHJveSkpXG4gICAgICAgICAgICAgICAgICAgICAgICAuc3Vic2NyaWJlKChyZXMpID0+IHRoaXMub25Qb2ludGVyVXAocmVzKSk7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKCF0aGlzLmdob3N0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBEbyBub3QgYmluZCBgbG9zdHBvaW50ZXJjYXB0dXJlYCB0byB0aGUgdGFyZ2V0LCBiZWNhdXNlIHdlIHdpbGwgYmluZCBpdCBvbiB0aGUgZ2hvc3QgbGF0ZXIuXG4gICAgICAgICAgICAgICAgICAgICAgICBmcm9tRXZlbnQoZWxlbWVudCwgJ2xvc3Rwb2ludGVyY2FwdHVyZScpLnBpcGUodGFrZVVudGlsKHRoaXMuX2Rlc3Ryb3kpKVxuICAgICAgICAgICAgICAgICAgICAgICAgLnN1YnNjcmliZSgocmVzKSA9PiB0aGlzLm9uUG9pbnRlckxvc3QocmVzKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMudG91Y2hFdmVudHNFbmFibGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGZyb21FdmVudChlbGVtZW50LCAndG91Y2hzdGFydCcpLnBpcGUodGFrZVVudGlsKHRoaXMuX2Rlc3Ryb3kpKVxuICAgICAgICAgICAgICAgICAgICAuc3Vic2NyaWJlKChyZXMpID0+IHRoaXMub25Qb2ludGVyRG93bihyZXMpKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBXZSBkb24ndCBoYXZlIHBvaW50ZXIgZXZlbnRzIGFuZCB0b3VjaCBldmVudHMuIFVzZSB0aGVuIG1vdXNlIGV2ZW50cy5cbiAgICAgICAgICAgICAgICAgICAgZnJvbUV2ZW50KGVsZW1lbnQsICdtb3VzZWRvd24nKS5waXBlKHRha2VVbnRpbCh0aGlzLl9kZXN0cm95KSlcbiAgICAgICAgICAgICAgICAgICAgLnN1YnNjcmliZSgocmVzKSA9PiB0aGlzLm9uUG9pbnRlckRvd24ocmVzKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIC8vIFdlIHNob3VsZCBiaW5kIHRvIGRvY3VtZW50IGV2ZW50cyBvbmx5IG9uY2Ugd2hlbiB0aGVyZSBhcmUgbm8gcG9pbnRlciBldmVudHMuXG4gICAgICAgICAgICBpZiAoIXRoaXMucG9pbnRlckV2ZW50c0VuYWJsZWQgJiYgdGhpcy50b3VjaEV2ZW50c0VuYWJsZWQpIHtcbiAgICAgICAgICAgICAgICBmcm9tRXZlbnQoZG9jdW1lbnQuZGVmYXVsdFZpZXcsICd0b3VjaG1vdmUnKS5waXBlKFxuICAgICAgICAgICAgICAgICAgICB0aHJvdHRsZSgoKSA9PiBpbnRlcnZhbCgwLCBhbmltYXRpb25GcmFtZVNjaGVkdWxlcikpLFxuICAgICAgICAgICAgICAgICAgICB0YWtlVW50aWwodGhpcy5fZGVzdHJveSlcbiAgICAgICAgICAgICAgICApLnN1YnNjcmliZSgocmVzKSA9PiB0aGlzLm9uUG9pbnRlck1vdmUocmVzKSk7XG5cbiAgICAgICAgICAgICAgICBmcm9tRXZlbnQoZG9jdW1lbnQuZGVmYXVsdFZpZXcsICd0b3VjaGVuZCcpLnBpcGUodGFrZVVudGlsKHRoaXMuX2Rlc3Ryb3kpKVxuICAgICAgICAgICAgICAgICAgICAuc3Vic2NyaWJlKChyZXMpID0+IHRoaXMub25Qb2ludGVyVXAocmVzKSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKCF0aGlzLnBvaW50ZXJFdmVudHNFbmFibGVkKSB7XG4gICAgICAgICAgICAgICAgZnJvbUV2ZW50KGRvY3VtZW50LmRlZmF1bHRWaWV3LCAnbW91c2Vtb3ZlJykucGlwZShcbiAgICAgICAgICAgICAgICAgICAgdGhyb3R0bGUoKCkgPT4gaW50ZXJ2YWwoMCwgYW5pbWF0aW9uRnJhbWVTY2hlZHVsZXIpKSxcbiAgICAgICAgICAgICAgICAgICAgdGFrZVVudGlsKHRoaXMuX2Rlc3Ryb3kpXG4gICAgICAgICAgICAgICAgKS5zdWJzY3JpYmUoKHJlcykgPT4gdGhpcy5vblBvaW50ZXJNb3ZlKHJlcykpO1xuXG4gICAgICAgICAgICAgICAgZnJvbUV2ZW50KGRvY3VtZW50LmRlZmF1bHRWaWV3LCAnbW91c2V1cCcpLnBpcGUodGFrZVVudGlsKHRoaXMuX2Rlc3Ryb3kpKVxuICAgICAgICAgICAgICAgICAgICAuc3Vic2NyaWJlKChyZXMpID0+IHRoaXMub25Qb2ludGVyVXAocmVzKSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMuZWxlbWVudC5uYXRpdmVFbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3RyYW5zaXRpb25lbmQnLCAoYXJncykgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMub25UcmFuc2l0aW9uRW5kKGFyZ3MpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIFNldCB0cmFuc2l0aW9uIGR1cmF0aW9uIHRvIDBzLiBUaGlzIGFsc28gaGVscHMgd2l0aCBzZXR0aW5nIGB2aXNpYmlsaXR5OiBoaWRkZW5gIHRvIHRoZSBiYXNlIHRvIG5vdCBsYWcuXG4gICAgICAgIHRoaXMuZWxlbWVudC5uYXRpdmVFbGVtZW50LnN0eWxlLnRyYW5zaXRpb25EdXJhdGlvbiA9ICcwLjBzJztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgcHVibGljIG5nT25EZXN0cm95KCkge1xuICAgICAgICB0aGlzLl9kZXN0cm95Lm5leHQodHJ1ZSk7XG4gICAgICAgIHRoaXMuX2Rlc3Ryb3kuY29tcGxldGUoKTtcblxuICAgICAgICBpZiAodGhpcy5naG9zdCAmJiB0aGlzLmdob3N0RWxlbWVudCAmJiB0aGlzLl9yZW1vdmVPbkRlc3Ryb3kpIHtcbiAgICAgICAgICAgIHRoaXMuZ2hvc3RFbGVtZW50LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodGhpcy5naG9zdEVsZW1lbnQpO1xuICAgICAgICAgICAgdGhpcy5naG9zdEVsZW1lbnQgPSBudWxsO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBpZiAodGhpcy5fZHluYW1pY0dob3N0UmVmKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fZHluYW1pY0dob3N0UmVmLmRlc3Ryb3koKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9keW5hbWljR2hvc3RSZWYgPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuX2NvbnRhaW5lclNjcm9sbEludGVydmFsSWQpIHtcbiAgICAgICAgICAgIGNsZWFySW50ZXJ2YWwodGhpcy5fY29udGFpbmVyU2Nyb2xsSW50ZXJ2YWxJZCk7XG4gICAgICAgICAgICB0aGlzLl9jb250YWluZXJTY3JvbGxJbnRlcnZhbElkID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNldHMgZGVzaXJlZCBsb2NhdGlvbiBvZiB0aGUgYmFzZSBlbGVtZW50IG9yIGdob3N0IGVsZW1lbnQgaWYgcmVuZGVkIHJlbGF0aXZlIHRvIHRoZSBkb2N1bWVudC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBuZXdMb2NhdGlvbiBOZXcgbG9jYXRpb24gdGhhdCBzaG91bGQgYmUgYXBwbGllZC4gSXQgaXMgYWR2aXNlZCB0byBnZXQgbmV3IGxvY2F0aW9uIHVzaW5nIGdldEJvdW5kaW5nQ2xpZW50UmVjdHMoKSArIHNjcm9sbC5cbiAgICAgKi9cbiAgICBwdWJsaWMgc2V0TG9jYXRpb24obmV3TG9jYXRpb246IElneERyYWdMb2NhdGlvbikge1xuICAgICAgICAvLyBXZSBkbyBub3Qgc3VidHJhY3QgbWFyZ2luTGVmdCBhbmQgbWFyZ2luVG9wIGhlcmUgYmVjYXVzZSBoZXJlIHdlIGNhbGN1bGF0ZSBkZWx0YXMuXG4gICAgICAgIGlmICh0aGlzLmdob3N0ICYmIHRoaXMuZ2hvc3RFbGVtZW50KSB7XG4gICAgICAgICAgICBjb25zdCBvZmZzZXRIb3N0WCA9IHRoaXMuZ2hvc3RIb3N0ID8gdGhpcy5naG9zdEhvc3RPZmZzZXRMZWZ0KHRoaXMuZ2hvc3RIb3N0KSA6IDA7XG4gICAgICAgICAgICBjb25zdCBvZmZzZXRIb3N0WSA9IHRoaXMuZ2hvc3RIb3N0ID8gdGhpcy5naG9zdEhvc3RPZmZzZXRUb3AodGhpcy5naG9zdEhvc3QpIDogMDtcbiAgICAgICAgICAgIHRoaXMuZ2hvc3RMZWZ0ID0gbmV3TG9jYXRpb24ucGFnZVggLSBvZmZzZXRIb3N0WCArIHRoaXMud2luZG93U2Nyb2xsTGVmdDtcbiAgICAgICAgICAgIHRoaXMuZ2hvc3RUb3AgPSBuZXdMb2NhdGlvbi5wYWdlWSAtIG9mZnNldEhvc3RZICsgdGhpcy53aW5kb3dTY3JvbGxUb3A7XG4gICAgICAgIH0gZWxzZSBpZiAoIXRoaXMuZ2hvc3QpIHtcbiAgICAgICAgICAgIGNvbnN0IGRlbHRhWCA9IG5ld0xvY2F0aW9uLnBhZ2VYIC0gdGhpcy5wYWdlWDtcbiAgICAgICAgICAgIGNvbnN0IGRlbHRhWSA9IG5ld0xvY2F0aW9uLnBhZ2VZIC0gdGhpcy5wYWdlWTtcbiAgICAgICAgICAgIGNvbnN0IHRyYW5zZm9ybVggPSB0aGlzLmdldFRyYW5zZm9ybVgodGhpcy5lbGVtZW50Lm5hdGl2ZUVsZW1lbnQpO1xuICAgICAgICAgICAgY29uc3QgdHJhbnNmb3JtWSA9IHRoaXMuZ2V0VHJhbnNmb3JtWSh0aGlzLmVsZW1lbnQubmF0aXZlRWxlbWVudCk7XG4gICAgICAgICAgICB0aGlzLnNldFRyYW5zZm9ybVhZKHRyYW5zZm9ybVggKyBkZWx0YVgsIHRyYW5zZm9ybVkgKyBkZWx0YVkpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fc3RhcnRYID0gdGhpcy5iYXNlTGVmdDtcbiAgICAgICAgdGhpcy5fc3RhcnRZID0gdGhpcy5iYXNlVG9wO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFuaW1hdGVzIHRoZSBiYXNlIG9yIGdob3N0IGVsZW1lbnQgZGVwZW5kaW5nIG9uIHRoZSBgZ2hvc3RgIGlucHV0IHRvIGl0cyBpbml0aWFsIGxvY2F0aW9uLlxuICAgICAqIElmIGBnaG9zdGAgaXMgdHJ1ZSBidXQgdGhlcmUgaXMgbm90IGdob3N0IHJlbmRlcmVkLCBpdCB3aWxsIGJlIGNyZWF0ZWQgYW5kIGFuaW1hdGVkLlxuICAgICAqIElmIHRoZSBiYXNlIGVsZW1lbnQgaGFzIGNoYW5nZWQgaXRzIERPTSBwb3NpdGlvbiBpdHMgaW5pdGlhbCBsb2NhdGlvbiB3aWxsIGJlIGNoYW5nZWQgYWNjb3JkaW5nbHkuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gY3VzdG9tQW5pbUFyZ3MgQ3VzdG9tIHRyYW5zaXRpb24gcHJvcGVydGllcyB0aGF0IHdpbGwgYmUgYXBwbGllZCB3aGVuIHBlcmZvcm1pbmcgdGhlIHRyYW5zaXRpb24uXG4gICAgICogQHBhcmFtIHN0YXJ0TG9jYXRpb24gU3RhcnQgbG9jYXRpb24gZnJvbSB3aGVyZSB0aGUgdHJhbnNpdGlvbiBzaG91bGQgc3RhcnQuXG4gICAgICovXG4gICAgcHVibGljIHRyYW5zaXRpb25Ub09yaWdpbihjdXN0b21BbmltQXJncz86IElEcmFnQ3VzdG9tVHJhbnNpdGlvbkFyZ3MsIHN0YXJ0TG9jYXRpb24/OiBJZ3hEcmFnTG9jYXRpb24pIHtcbiAgICAgICAgaWYgKCghIXN0YXJ0TG9jYXRpb24gJiYgc3RhcnRMb2NhdGlvbi5wYWdlWCA9PT0gdGhpcy5iYXNlT3JpZ2luTGVmdCAmJiBzdGFydExvY2F0aW9uLnBhZ2VZID09PSB0aGlzLmJhc2VPcmlnaW5MZWZ0KSB8fFxuICAgICAgICAgICAgKCFzdGFydExvY2F0aW9uICYmIHRoaXMuZ2hvc3QgJiYgIXRoaXMuZ2hvc3RFbGVtZW50KSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCEhc3RhcnRMb2NhdGlvbiAmJiBzdGFydExvY2F0aW9uLnBhZ2VYICE9PSB0aGlzLnBhZ2VYICYmIHN0YXJ0TG9jYXRpb24ucGFnZVkgIT09IHRoaXMucGFnZVkpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmdob3N0ICYmICF0aGlzLmdob3N0RWxlbWVudCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3N0YXJ0WCA9IHN0YXJ0TG9jYXRpb24ucGFnZVg7XG4gICAgICAgICAgICAgICAgdGhpcy5fc3RhcnRZID0gc3RhcnRMb2NhdGlvbi5wYWdlWTtcbiAgICAgICAgICAgICAgICB0aGlzLl9naG9zdFN0YXJ0WCA9IHRoaXMuX3N0YXJ0WDtcbiAgICAgICAgICAgICAgICB0aGlzLl9naG9zdFN0YXJ0WSA9IHRoaXMuX3N0YXJ0WTtcbiAgICAgICAgICAgICAgICB0aGlzLmNyZWF0ZUdob3N0KHRoaXMuX3N0YXJ0WCwgdGhpcy5fc3RhcnRZKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5zZXRMb2NhdGlvbihzdGFydExvY2F0aW9uKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuYW5pbUluUHJvZ3Jlc3MgPSB0cnVlO1xuICAgICAgICAvLyBVc2Ugc2V0VGltZW91dCBiZWNhdXNlIHdlIG5lZWQgdG8gYmUgc3VyZSB0aGF0IHRoZSBlbGVtZW50IGlzIHBvc2l0aW9uZWQgZmlyc3QgY29ycmVjdGx5IGlmIHRoZXJlIGlzIHN0YXJ0IGxvY2F0aW9uLlxuICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgIGlmICh0aGlzLmdob3N0KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5naG9zdEVsZW1lbnQuc3R5bGUudHJhbnNpdGlvblByb3BlcnR5ID0gJ3RvcCwgbGVmdCc7XG4gICAgICAgICAgICAgICAgdGhpcy5naG9zdEVsZW1lbnQuc3R5bGUudHJhbnNpdGlvbkR1cmF0aW9uID1cbiAgICAgICAgICAgICAgICAgICAgY3VzdG9tQW5pbUFyZ3MgJiYgY3VzdG9tQW5pbUFyZ3MuZHVyYXRpb24gPyBjdXN0b21BbmltQXJncy5kdXJhdGlvbiArICdzJyA6IHRoaXMuZGVmYXVsdFJldHVybkR1cmF0aW9uIDtcbiAgICAgICAgICAgICAgICB0aGlzLmdob3N0RWxlbWVudC5zdHlsZS50cmFuc2l0aW9uVGltaW5nRnVuY3Rpb24gPVxuICAgICAgICAgICAgICAgICAgICBjdXN0b21BbmltQXJncyAmJiBjdXN0b21BbmltQXJncy50aW1pbmdGdW5jdGlvbiA/IGN1c3RvbUFuaW1BcmdzLnRpbWluZ0Z1bmN0aW9uIDogJyc7XG4gICAgICAgICAgICAgICAgdGhpcy5naG9zdEVsZW1lbnQuc3R5bGUudHJhbnNpdGlvbkRlbGF5ID0gY3VzdG9tQW5pbUFyZ3MgJiYgY3VzdG9tQW5pbUFyZ3MuZGVsYXkgPyBjdXN0b21BbmltQXJncy5kZWxheSArICdzJyA6ICcnO1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0TG9jYXRpb24obmV3IElneERyYWdMb2NhdGlvbih0aGlzLmJhc2VMZWZ0LCB0aGlzLmJhc2VUb3ApKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoIXRoaXMuZ2hvc3QpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmVsZW1lbnQubmF0aXZlRWxlbWVudC5zdHlsZS50cmFuc2l0aW9uUHJvcGVydHkgPSAndHJhbnNmb3JtJztcbiAgICAgICAgICAgICAgICB0aGlzLmVsZW1lbnQubmF0aXZlRWxlbWVudC5zdHlsZS50cmFuc2l0aW9uRHVyYXRpb24gPVxuICAgICAgICAgICAgICAgICAgICBjdXN0b21BbmltQXJncyAmJiBjdXN0b21BbmltQXJncy5kdXJhdGlvbiA/IGN1c3RvbUFuaW1BcmdzLmR1cmF0aW9uICsgJ3MnIDogdGhpcy5kZWZhdWx0UmV0dXJuRHVyYXRpb24gO1xuICAgICAgICAgICAgICAgIHRoaXMuZWxlbWVudC5uYXRpdmVFbGVtZW50LnN0eWxlLnRyYW5zaXRpb25UaW1pbmdGdW5jdGlvbiA9XG4gICAgICAgICAgICAgICAgICAgIGN1c3RvbUFuaW1BcmdzICYmIGN1c3RvbUFuaW1BcmdzLnRpbWluZ0Z1bmN0aW9uID8gY3VzdG9tQW5pbUFyZ3MudGltaW5nRnVuY3Rpb24gOiAnJztcbiAgICAgICAgICAgICAgICB0aGlzLmVsZW1lbnQubmF0aXZlRWxlbWVudC5zdHlsZS50cmFuc2l0aW9uRGVsYXkgPSBjdXN0b21BbmltQXJncyAmJiBjdXN0b21BbmltQXJncy5kZWxheSA/IGN1c3RvbUFuaW1BcmdzLmRlbGF5ICsgJ3MnIDogJyc7XG4gICAgICAgICAgICAgICAgdGhpcy5fc3RhcnRYID0gdGhpcy5iYXNlTGVmdDtcbiAgICAgICAgICAgICAgICB0aGlzLl9zdGFydFkgPSB0aGlzLmJhc2VUb3A7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXRUcmFuc2Zvcm1YWSgwLCAwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgMCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQW5pbWF0ZXMgdGhlIGJhc2Ugb3IgZ2hvc3QgZWxlbWVudCB0byBhIHNwZWNpZmljIHRhcmdldCBsb2NhdGlvbiBvciBvdGhlciBlbGVtZW50IHVzaW5nIHRyYW5zaXRpb24uXG4gICAgICogSWYgYGdob3N0YCBpcyB0cnVlIGJ1dCB0aGVyZSBpcyBub3QgZ2hvc3QgcmVuZGVyZWQsIGl0IHdpbGwgYmUgY3JlYXRlZCBhbmQgYW5pbWF0ZWQuXG4gICAgICogSXQgaXMgcmVjb21tZW5kZWQgdG8gdXNlICdnZXRCb3VuZGluZ0NsaWVudFJlY3RzKCkgKyBwYWdlU2Nyb2xsJyB3aGVuIGRldGVybWluaW5nIGRlc2lyZWQgbG9jYXRpb24uXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdGFyZ2V0IFRhcmdldCB0aGF0IHRoZSBiYXNlIG9yIGdob3N0IHdpbGwgdHJhbnNpdGlvbiB0by4gSXQgY2FuIGJlIGVpdGhlciBsb2NhdGlvbiBpbiB0aGUgcGFnZSBvciBhbm90aGVyIEhUTUwgZWxlbWVudC5cbiAgICAgKiBAcGFyYW0gY3VzdG9tQW5pbUFyZ3MgQ3VzdG9tIHRyYW5zaXRpb24gcHJvcGVydGllcyB0aGF0IHdpbGwgYmUgYXBwbGllZCB3aGVuIHBlcmZvcm1pbmcgdGhlIHRyYW5zaXRpb24uXG4gICAgICogQHBhcmFtIHN0YXJ0TG9jYXRpb24gU3RhcnQgbG9jYXRpb24gZnJvbSB3aGVyZSB0aGUgdHJhbnNpdGlvbiBzaG91bGQgc3RhcnQuXG4gICAgICovXG4gICAgcHVibGljIHRyYW5zaXRpb25Ubyh0YXJnZXQ6IElneERyYWdMb2NhdGlvbiB8IEVsZW1lbnRSZWYsIGN1c3RvbUFuaW1BcmdzPzogSURyYWdDdXN0b21UcmFuc2l0aW9uQXJncywgc3RhcnRMb2NhdGlvbj86IElneERyYWdMb2NhdGlvbikge1xuICAgICAgICBpZiAoISFzdGFydExvY2F0aW9uICYmIHRoaXMuZ2hvc3QgJiYgIXRoaXMuZ2hvc3RFbGVtZW50KSB7XG4gICAgICAgICAgICB0aGlzLl9zdGFydFggPSBzdGFydExvY2F0aW9uLnBhZ2VYO1xuICAgICAgICAgICAgdGhpcy5fc3RhcnRZID0gc3RhcnRMb2NhdGlvbi5wYWdlWTtcbiAgICAgICAgICAgIHRoaXMuX2dob3N0U3RhcnRYID0gdGhpcy5fc3RhcnRYO1xuICAgICAgICAgICAgdGhpcy5fZ2hvc3RTdGFydFkgPSB0aGlzLl9zdGFydFk7XG4gICAgICAgIH0gZWxzZSBpZiAoISFzdGFydExvY2F0aW9uICYmICghdGhpcy5naG9zdCB8fCB0aGlzLmdob3N0RWxlbWVudCkpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0TG9jYXRpb24oc3RhcnRMb2NhdGlvbik7XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5naG9zdCAmJiAhdGhpcy5naG9zdEVsZW1lbnQpIHtcbiAgICAgICAgICAgIHRoaXMuX3N0YXJ0WCA9IHRoaXMuYmFzZUxlZnQ7XG4gICAgICAgICAgICB0aGlzLl9zdGFydFkgPSB0aGlzLmJhc2VUb3A7XG4gICAgICAgICAgICB0aGlzLl9naG9zdFN0YXJ0WCA9IHRoaXMuX3N0YXJ0WCArIHRoaXMud2luZG93U2Nyb2xsTGVmdDtcbiAgICAgICAgICAgIHRoaXMuX2dob3N0U3RhcnRZID0gdGhpcy5fc3RhcnRZICsgdGhpcy53aW5kb3dTY3JvbGxUb3A7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5naG9zdCAmJiAhdGhpcy5naG9zdEVsZW1lbnQpIHtcbiAgICAgICAgICAgIHRoaXMuY3JlYXRlR2hvc3QodGhpcy5fc3RhcnRYLCB0aGlzLl9zdGFydFkpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5hbmltSW5Qcm9ncmVzcyA9IHRydWU7XG4gICAgICAgIC8vIFVzZSBzZXRUaW1lb3V0IGJlY2F1c2Ugd2UgbmVlZCB0byBiZSBzdXJlIHRoYXQgdGhlIGVsZW1lbnQgaXMgcG9zaXRpb25lZCBmaXJzdCBjb3JyZWN0bHkgaWYgdGhlcmUgaXMgc3RhcnQgbG9jYXRpb24uXG4gICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgbW92ZWRFbGVtID0gdGhpcy5naG9zdCA/IHRoaXMuZ2hvc3RFbGVtZW50IDogdGhpcy5lbGVtZW50Lm5hdGl2ZUVsZW1lbnQ7XG4gICAgICAgICAgICBtb3ZlZEVsZW0uc3R5bGUudHJhbnNpdGlvblByb3BlcnR5ID0gdGhpcy5naG9zdCAmJiB0aGlzLmdob3N0RWxlbWVudCA/ICdsZWZ0LCB0b3AnIDogJ3RyYW5zZm9ybSc7XG4gICAgICAgICAgICBtb3ZlZEVsZW0uc3R5bGUudHJhbnNpdGlvbkR1cmF0aW9uID1cbiAgICAgICAgICAgICAgICBjdXN0b21BbmltQXJncyAmJiBjdXN0b21BbmltQXJncy5kdXJhdGlvbiA/IGN1c3RvbUFuaW1BcmdzLmR1cmF0aW9uICsgJ3MnIDogdGhpcy5kZWZhdWx0UmV0dXJuRHVyYXRpb24gO1xuICAgICAgICAgICAgbW92ZWRFbGVtLnN0eWxlLnRyYW5zaXRpb25UaW1pbmdGdW5jdGlvbiA9XG4gICAgICAgICAgICAgICAgY3VzdG9tQW5pbUFyZ3MgJiYgY3VzdG9tQW5pbUFyZ3MudGltaW5nRnVuY3Rpb24gPyBjdXN0b21BbmltQXJncy50aW1pbmdGdW5jdGlvbiA6ICcnO1xuICAgICAgICAgICAgbW92ZWRFbGVtLnN0eWxlLnRyYW5zaXRpb25EZWxheSA9IGN1c3RvbUFuaW1BcmdzICYmIGN1c3RvbUFuaW1BcmdzLmRlbGF5ID8gY3VzdG9tQW5pbUFyZ3MuZGVsYXkgKyAncycgOiAnJztcblxuICAgICAgICAgICAgaWYgKHRhcmdldCBpbnN0YW5jZW9mIElneERyYWdMb2NhdGlvbikge1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0TG9jYXRpb24obmV3IElneERyYWdMb2NhdGlvbiAodGFyZ2V0LnBhZ2VYLCB0YXJnZXQucGFnZVkpKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdGFyZ2V0UmVjdHMgPSB0YXJnZXQubmF0aXZlRWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgICAgICAgICB0aGlzLnNldExvY2F0aW9uKG5ldyBJZ3hEcmFnTG9jYXRpb24oXG4gICAgICAgICAgICAgICAgICAgIHRhcmdldFJlY3RzLmxlZnQgLSAgdGhpcy53aW5kb3dTY3JvbGxMZWZ0LFxuICAgICAgICAgICAgICAgICAgICB0YXJnZXRSZWN0cy50b3AgLSB0aGlzLndpbmRvd1Njcm9sbFRvcFxuICAgICAgICAgICAgICAgICkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LCAwKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICogTWV0aG9kIGJvdW5kIHRvIHRoZSBQb2ludGVyRG93biBldmVudCBvZiB0aGUgYmFzZSBlbGVtZW50IGlneERyYWcgaXMgaW5pdGlhbGl6ZWQuXG4gICAgICogQHBhcmFtIGV2ZW50IFBvaW50ZXJEb3duIGV2ZW50IGNhcHR1cmVkXG4gICAgICovXG4gICAgcHVibGljIG9uUG9pbnRlckRvd24oZXZlbnQpIHtcbiAgICAgICAgY29uc3QgaWdub3JlZEVsZW1lbnQgPSB0aGlzLmRyYWdJZ25vcmVkRWxlbXMuZmluZChlbGVtID0+IGVsZW0uZWxlbWVudC5uYXRpdmVFbGVtZW50ID09PSBldmVudC50YXJnZXQpO1xuICAgICAgICBpZiAoaWdub3JlZEVsZW1lbnQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX2NsaWNrZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLl9wb2ludGVyRG93bklkID0gZXZlbnQucG9pbnRlcklkO1xuXG4gICAgICAgIC8vIFNldCBwb2ludGVyIGNhcHR1cmUgc28gd2UgZGV0ZWN0IHBvaW50ZXJtb3ZlIGV2ZW4gaWYgbW91c2UgaXMgb3V0IG9mIGJvdW5kcyB1bnRpbCBnaG9zdEVsZW1lbnQgaXMgY3JlYXRlZC5cbiAgICAgICAgY29uc3QgaGFuZGxlRm91bmQgPSB0aGlzLmRyYWdIYW5kbGVzLmZpbmQoaGFuZGxlID0+IGhhbmRsZS5lbGVtZW50Lm5hdGl2ZUVsZW1lbnQgPT09IGV2ZW50LmN1cnJlbnRUYXJnZXQpO1xuICAgICAgICBjb25zdCB0YXJnZXRFbGVtZW50ID0gaGFuZGxlRm91bmQgPyBoYW5kbGVGb3VuZC5lbGVtZW50Lm5hdGl2ZUVsZW1lbnQgOiB0aGlzLmVsZW1lbnQubmF0aXZlRWxlbWVudDtcbiAgICAgICAgaWYgKHRoaXMucG9pbnRlckV2ZW50c0VuYWJsZWQpIHtcbiAgICAgICAgICAgIHRhcmdldEVsZW1lbnQuc2V0UG9pbnRlckNhcHR1cmUodGhpcy5fcG9pbnRlckRvd25JZCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0YXJnZXRFbGVtZW50LmZvY3VzKCk7XG4gICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMucG9pbnRlckV2ZW50c0VuYWJsZWQgfHwgIXRoaXMudG91Y2hFdmVudHNFbmFibGVkKSB7XG4gICAgICAgICAgICAvLyBDaGVjayBmaXJzdCBmb3IgcG9pbnRlciBldmVudHMgb3Igbm9uIHRvdWNoLCBiZWNhdXNlIHdlIGNhbiBoYXZlIHBvaW50ZXIgZXZlbnRzIGFuZCB0b3VjaCBldmVudHMgYXQgb25jZS5cbiAgICAgICAgICAgIHRoaXMuX3N0YXJ0WCA9IGV2ZW50LnBhZ2VYO1xuICAgICAgICAgICAgdGhpcy5fc3RhcnRZID0gZXZlbnQucGFnZVk7XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy50b3VjaEV2ZW50c0VuYWJsZWQpIHtcbiAgICAgICAgICAgIHRoaXMuX3N0YXJ0WCA9IGV2ZW50LnRvdWNoZXNbMF0ucGFnZVg7XG4gICAgICAgICAgICB0aGlzLl9zdGFydFkgPSBldmVudC50b3VjaGVzWzBdLnBhZ2VZO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fZGVmYXVsdE9mZnNldFggPSB0aGlzLmJhc2VMZWZ0IC0gdGhpcy5fc3RhcnRYICsgdGhpcy53aW5kb3dTY3JvbGxMZWZ0O1xuICAgICAgICB0aGlzLl9kZWZhdWx0T2Zmc2V0WSA9IHRoaXMuYmFzZVRvcCAtIHRoaXMuX3N0YXJ0WSArIHRoaXMud2luZG93U2Nyb2xsVG9wO1xuICAgICAgICB0aGlzLl9naG9zdFN0YXJ0WCA9IHRoaXMuX3N0YXJ0WCArIHRoaXMuZ2hvc3RPZmZzZXRYO1xuICAgICAgICB0aGlzLl9naG9zdFN0YXJ0WSA9IHRoaXMuX3N0YXJ0WSArIHRoaXMuZ2hvc3RPZmZzZXRZO1xuICAgICAgICB0aGlzLl9sYXN0WCA9IHRoaXMuX3N0YXJ0WDtcbiAgICAgICAgdGhpcy5fbGFzdFkgPSB0aGlzLl9zdGFydFk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqIFBlcmZvcm0gZHJhZyBtb3ZlIGxvZ2ljIHdoZW4gZHJhZ2dpbmcgYW5kIGRpc3BhdGNoaW5nIGV2ZW50cyBpZiB0aGVyZSBpcyBpZ3hEcm9wIHVuZGVyIHRoZSBwb2ludGVyLlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGJvdW5kIGF0IGZpcnN0IGF0IHRoZSBiYXNlIGVsZW1lbnQuXG4gICAgICogSWYgZHJhZ2dpbmcgc3RhcnRzIGFuZCBhZnRlciB0aGUgZ2hvc3RFbGVtZW50IGlzIHJlbmRlcmVkIHRoZSBwb2ludGVySWQgaXMgcmVhc3NpZ25lZCBpdC4gVGhlbiB0aGlzIG1ldGhvZCBpcyBib3VuZCB0byBpdC5cbiAgICAgKiBAcGFyYW0gZXZlbnQgUG9pbnRlck1vdmUgZXZlbnQgY2FwdHVyZWRcbiAgICAgKi9cbiAgICBwdWJsaWMgb25Qb2ludGVyTW92ZShldmVudCkge1xuICAgICAgICBpZiAodGhpcy5fY2xpY2tlZCkge1xuICAgICAgICAgICAgbGV0IHBhZ2VYOyBsZXQgcGFnZVk7XG4gICAgICAgICAgICBpZiAodGhpcy5wb2ludGVyRXZlbnRzRW5hYmxlZCB8fCAhdGhpcy50b3VjaEV2ZW50c0VuYWJsZWQpIHtcbiAgICAgICAgICAgICAgICAvLyBDaGVjayBmaXJzdCBmb3IgcG9pbnRlciBldmVudHMgb3Igbm9uIHRvdWNoLCBiZWNhdXNlIHdlIGNhbiBoYXZlIHBvaW50ZXIgZXZlbnRzIGFuZCB0b3VjaCBldmVudHMgYXQgb25jZS5cbiAgICAgICAgICAgICAgICBwYWdlWCA9IGV2ZW50LnBhZ2VYO1xuICAgICAgICAgICAgICAgIHBhZ2VZID0gZXZlbnQucGFnZVk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMudG91Y2hFdmVudHNFbmFibGVkKSB7XG4gICAgICAgICAgICAgICAgcGFnZVggPSBldmVudC50b3VjaGVzWzBdLnBhZ2VYO1xuICAgICAgICAgICAgICAgIHBhZ2VZID0gZXZlbnQudG91Y2hlc1swXS5wYWdlWTtcblxuICAgICAgICAgICAgICAgIC8vIFByZXZlbnQgc2Nyb2xsaW5nIG9uIHRvdWNoIHdoaWxlIGRyYWdnaW5nXG4gICAgICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY29uc3QgdG90YWxNb3ZlZFggPSBwYWdlWCAtIHRoaXMuX3N0YXJ0WDtcbiAgICAgICAgICAgIGNvbnN0IHRvdGFsTW92ZWRZID0gcGFnZVkgLSB0aGlzLl9zdGFydFk7XG4gICAgICAgICAgICBpZiAoIXRoaXMuX2RyYWdTdGFydGVkICYmXG4gICAgICAgICAgICAgICAgKE1hdGguYWJzKHRvdGFsTW92ZWRYKSA+IHRoaXMuZHJhZ1RvbGVyYW5jZSB8fCBNYXRoLmFicyh0b3RhbE1vdmVkWSkgPiB0aGlzLmRyYWdUb2xlcmFuY2UpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZHJhZ1N0YXJ0QXJnczogSURyYWdTdGFydEV2ZW50QXJncyA9IHtcbiAgICAgICAgICAgICAgICAgICAgb3JpZ2luYWxFdmVudDogZXZlbnQsXG4gICAgICAgICAgICAgICAgICAgIG93bmVyOiB0aGlzLFxuICAgICAgICAgICAgICAgICAgICBzdGFydFg6IHBhZ2VYIC0gdG90YWxNb3ZlZFgsXG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0WTogcGFnZVkgLSB0b3RhbE1vdmVkWSxcbiAgICAgICAgICAgICAgICAgICAgcGFnZVgsXG4gICAgICAgICAgICAgICAgICAgIHBhZ2VZLFxuICAgICAgICAgICAgICAgICAgICBjYW5jZWw6IGZhbHNlXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB0aGlzLnpvbmUucnVuKCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmFnU3RhcnQuZW1pdChkcmFnU3RhcnRBcmdzKTtcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIGlmICghZHJhZ1N0YXJ0QXJncy5jYW5jZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZHJhZ1N0YXJ0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5naG9zdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gV2UgbW92ZWQgZW5vdWdoIHNvIGdob3N0RWxlbWVudCBjYW4gYmUgcmVuZGVyZWQgYW5kIGFjdHVhbCBkcmFnZ2luZyB0byBzdGFydC5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFdoZW4gY3JlYXRpbmcgaXQgd2lsbCB0YWtlIGludG8gYWNjb3VudCBhbnkgb2Zmc2V0IHNldCBieSB0aGUgdXNlciBieSBkZWZhdWx0LlxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jcmVhdGVHaG9zdChwYWdlWCwgcGFnZVkpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMuX29mZnNldFggIT09IHVuZGVmaW5lZCB8fCB0aGlzLl9vZmZzZXRZICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoZXJlIGlzIG5vIG5lZWQgZm9yIGdob3N0LCBidXQgd2Ugd2lsbCBuZWVkIHRvIHBvc2l0aW9uIGluaXRpYWxseSB0aGUgYmFzZSBlbGVtZW50IHRvIHJlZmxlY3QgYW55IG9mZnNldC5cbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHRyYW5zZm9ybVggPSAodGhpcy5fb2Zmc2V0WCAhPT0gdW5kZWZpbmVkID8gdGhpcy5fb2Zmc2V0WCAtIHRoaXMuX2RlZmF1bHRPZmZzZXRYIDogMCkgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZ2V0VHJhbnNmb3JtWCh0aGlzLmVsZW1lbnQubmF0aXZlRWxlbWVudCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB0cmFuc2Zvcm1ZID0gKHRoaXMuX29mZnNldFkgIT09IHVuZGVmaW5lZCA/IHRoaXMuX29mZnNldFkgLSB0aGlzLl9kZWZhdWx0T2Zmc2V0WSA6IDApICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmdldFRyYW5zZm9ybVkodGhpcy5lbGVtZW50Lm5hdGl2ZUVsZW1lbnQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXRUcmFuc2Zvcm1YWSh0cmFuc2Zvcm1YLCB0cmFuc2Zvcm1ZKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKCF0aGlzLl9kcmFnU3RhcnRlZCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY29uc3QgbW92ZUFyZ3M6IElEcmFnTW92ZUV2ZW50QXJncyA9IHtcbiAgICAgICAgICAgICAgICBvcmlnaW5hbEV2ZW50OiBldmVudCxcbiAgICAgICAgICAgICAgICBvd25lcjogdGhpcyxcbiAgICAgICAgICAgICAgICBzdGFydFg6IHRoaXMuX3N0YXJ0WCxcbiAgICAgICAgICAgICAgICBzdGFydFk6IHRoaXMuX3N0YXJ0WSxcbiAgICAgICAgICAgICAgICBwYWdlWDogdGhpcy5fbGFzdFgsXG4gICAgICAgICAgICAgICAgcGFnZVk6IHRoaXMuX2xhc3RZLFxuICAgICAgICAgICAgICAgIG5leHRQYWdlWDogcGFnZVgsXG4gICAgICAgICAgICAgICAgbmV4dFBhZ2VZOiBwYWdlWSxcbiAgICAgICAgICAgICAgICBjYW5jZWw6IGZhbHNlXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdGhpcy5kcmFnTW92ZS5lbWl0KG1vdmVBcmdzKTtcblxuICAgICAgICAgICAgY29uc3Qgc2V0UGFnZVggPSBtb3ZlQXJncy5uZXh0UGFnZVg7XG4gICAgICAgICAgICBjb25zdCBzZXRQYWdlWSA9IG1vdmVBcmdzLm5leHRQYWdlWTtcbiAgICAgICAgICAgIGlmICghbW92ZUFyZ3MuY2FuY2VsKSB7XG4gICAgICAgICAgICAgICAgLy8gU2Nyb2xsIHJvb3QgY29udGFpbmVyIGlmIHRoZSB1c2VyIHJlYWNoZXMgaXRzIGJvdW5kYXJpZXMuXG4gICAgICAgICAgICAgICAgdGhpcy5vblNjcm9sbENvbnRhaW5lcigpO1xuXG4gICAgICAgICAgICAgICAgLy8gTW92ZSB0aGUgYWN0dWFsIGVsZW1lbnQgYXJvdW5kXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuZ2hvc3QpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdXBkYXRlZFRvdGFsTW92ZWRYID0gdGhpcy5kcmFnRGlyZWN0aW9uID09PSBEcmFnRGlyZWN0aW9uLlZFUlRJQ0FMID8gMCA6IHNldFBhZ2VYIC0gdGhpcy5fc3RhcnRYO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB1cGRhdGVkVG90YWxNb3ZlZFkgPSB0aGlzLmRyYWdEaXJlY3Rpb24gPT09IERyYWdEaXJlY3Rpb24uSE9SSVpPTlRBTCA/IDAgOiBzZXRQYWdlWSAtIHRoaXMuX3N0YXJ0WTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5naG9zdExlZnQgPSB0aGlzLl9naG9zdFN0YXJ0WCArIHVwZGF0ZWRUb3RhbE1vdmVkWDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5naG9zdFRvcCA9IHRoaXMuX2dob3N0U3RhcnRZICsgdXBkYXRlZFRvdGFsTW92ZWRZO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGxhc3RNb3ZlZFggPSB0aGlzLmRyYWdEaXJlY3Rpb24gPT09IERyYWdEaXJlY3Rpb24uVkVSVElDQUwgPyAwIDogc2V0UGFnZVggLSB0aGlzLl9sYXN0WDtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbGFzdE1vdmVkWSA9IHRoaXMuZHJhZ0RpcmVjdGlvbiA9PT0gRHJhZ0RpcmVjdGlvbi5IT1JJWk9OVEFMID8gMCA6IHNldFBhZ2VZIC0gdGhpcy5fbGFzdFk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHRyYW5zbGF0ZVggPSB0aGlzLmdldFRyYW5zZm9ybVgodGhpcy5lbGVtZW50Lm5hdGl2ZUVsZW1lbnQpICsgbGFzdE1vdmVkWDtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdHJhbnNsYXRlWSA9IHRoaXMuZ2V0VHJhbnNmb3JtWSh0aGlzLmVsZW1lbnQubmF0aXZlRWxlbWVudCkgKyBsYXN0TW92ZWRZO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNldFRyYW5zZm9ybVhZKHRyYW5zbGF0ZVgsIHRyYW5zbGF0ZVkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLmRpc3BhdGNoRHJhZ0V2ZW50cyhwYWdlWCwgcGFnZVksIGV2ZW50KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5fbGFzdFggPSBzZXRQYWdlWDtcbiAgICAgICAgICAgIHRoaXMuX2xhc3RZID0gc2V0UGFnZVk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICogUGVyZm9ybSBkcmFnIGVuZCBsb2dpYyB3aGVuIHJlbGVhc2luZyB0aGUgZ2hvc3RFbGVtZW50IGFuZCBkaXNwYXRjaGluZyBkcm9wIGV2ZW50IGlmIGlneERyb3AgaXMgdW5kZXIgdGhlIHBvaW50ZXIuXG4gICAgICogVGhpcyBtZXRob2QgaXMgYm91bmQgYXQgZmlyc3QgYXQgdGhlIGJhc2UgZWxlbWVudC5cbiAgICAgKiBJZiBkcmFnZ2luZyBzdGFydHMgYW5kIGFmdGVyIHRoZSBnaG9zdEVsZW1lbnQgaXMgcmVuZGVyZWQgdGhlIHBvaW50ZXJJZCBpcyByZWFzc2lnbmVkIHRvIGl0LiBUaGVuIHRoaXMgbWV0aG9kIGlzIGJvdW5kIHRvIGl0LlxuICAgICAqIEBwYXJhbSBldmVudCBQb2ludGVyVXAgZXZlbnQgY2FwdHVyZWRcbiAgICAgKi9cbiAgICBwdWJsaWMgb25Qb2ludGVyVXAoZXZlbnQpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9jbGlja2VkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgcGFnZVg7IGxldCBwYWdlWTtcbiAgICAgICAgaWYgKHRoaXMucG9pbnRlckV2ZW50c0VuYWJsZWQgfHwgIXRoaXMudG91Y2hFdmVudHNFbmFibGVkKSB7XG4gICAgICAgICAgICAvLyBDaGVjayBmaXJzdCBmb3IgcG9pbnRlciBldmVudHMgb3Igbm9uIHRvdWNoLCBiZWNhdXNlIHdlIGNhbiBoYXZlIHBvaW50ZXIgZXZlbnRzIGFuZCB0b3VjaCBldmVudHMgYXQgb25jZS5cbiAgICAgICAgICAgIHBhZ2VYID0gZXZlbnQucGFnZVg7XG4gICAgICAgICAgICBwYWdlWSA9IGV2ZW50LnBhZ2VZO1xuICAgICAgICB9IGVsc2UgaWYgKHRoaXMudG91Y2hFdmVudHNFbmFibGVkKSB7XG4gICAgICAgICAgICBwYWdlWCA9IGV2ZW50LnRvdWNoZXNbMF0ucGFnZVg7XG4gICAgICAgICAgICBwYWdlWSA9IGV2ZW50LnRvdWNoZXNbMF0ucGFnZVk7XG5cbiAgICAgICAgICAgIC8vIFByZXZlbnQgc2Nyb2xsaW5nIG9uIHRvdWNoIHdoaWxlIGRyYWdnaW5nXG4gICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgZXZlbnRBcmdzOiBJRHJhZ0Jhc2VFdmVudEFyZ3MgPSB7XG4gICAgICAgICAgICBvcmlnaW5hbEV2ZW50OiBldmVudCxcbiAgICAgICAgICAgIG93bmVyOiB0aGlzLFxuICAgICAgICAgICAgc3RhcnRYOiB0aGlzLl9zdGFydFgsXG4gICAgICAgICAgICBzdGFydFk6IHRoaXMuX3N0YXJ0WSxcbiAgICAgICAgICAgIHBhZ2VYLFxuICAgICAgICAgICAgcGFnZVlcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5fcG9pbnRlckRvd25JZCA9IG51bGw7XG4gICAgICAgIHRoaXMuX2NsaWNrZWQgPSBmYWxzZTtcbiAgICAgICAgaWYgKHRoaXMuX2RyYWdTdGFydGVkKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fbGFzdERyb3BBcmVhICYmIHRoaXMuX2xhc3REcm9wQXJlYSAhPT0gdGhpcy5lbGVtZW50Lm5hdGl2ZUVsZW1lbnQgKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5kaXNwYXRjaERyb3BFdmVudChldmVudC5wYWdlWCwgZXZlbnQucGFnZVksIGV2ZW50KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy56b25lLnJ1bigoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5kcmFnRW5kLmVtaXQoZXZlbnRBcmdzKTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBpZiAoIXRoaXMuYW5pbUluUHJvZ3Jlc3MpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm9uVHJhbnNpdGlvbkVuZChudWxsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIFRyaWdnZXIgb3VyIG93biBjbGljayBldmVudCBiZWNhdXNlIHdoZW4gdGhlcmUgaXMgbm8gZ2hvc3QsIG5hdGl2ZSBjbGljayBjYW5ub3QgYmUgcHJldmVudGVkIHdoZW4gZHJhZ2dpbmcuXG4gICAgICAgICAgICB0aGlzLnpvbmUucnVuKCgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLmRyYWdDbGljay5lbWl0KGV2ZW50QXJncyk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLl9jb250YWluZXJTY3JvbGxJbnRlcnZhbElkKSB7XG4gICAgICAgICAgICBjbGVhckludGVydmFsKHRoaXMuX2NvbnRhaW5lclNjcm9sbEludGVydmFsSWQpO1xuICAgICAgICAgICAgdGhpcy5fY29udGFpbmVyU2Nyb2xsSW50ZXJ2YWxJZCA9IG51bGw7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICogRXhlY3V0ZSB0aGlzIG1ldGhvZCB3aGUgdGhlIHBvaW50ZXIgY2FwdHVyZSBoYXMgYmVlbiBsb3N0LlxuICAgICAqIFRoaXMgbWVhbnMgdGhhdCBkdXJpbmcgZHJhZ2dpbmcgdGhlIHVzZXIgaGFzIHBlcmZvcm1lZCBvdGhlciBhY3Rpb24gbGlrZSByaWdodCBjbGlja2luZyBhbmQgdGhlbiBjbGlja2luZyBzb21ld2hlcmUgZWxzZS5cbiAgICAgKiBUaGlzIG1ldGhvZCB3aWxsIGVuc3VyZSB0aGF0IHRoZSBkcmFnIHN0YXRlIGlzIGJlaW5nIHJlc2V0IGluIHRoaXMgY2FzZSBhcyBpZiB0aGUgdXNlciByZWxlYXNlZCB0aGUgZHJhZ2dlZCBlbGVtZW50LlxuICAgICAqIEBwYXJhbSBldmVudCBFdmVudCBjYXB0dXJlZFxuICAgICAqL1xuICAgIHB1YmxpYyBvblBvaW50ZXJMb3N0KGV2ZW50KSB7XG4gICAgICAgIGlmICghdGhpcy5fY2xpY2tlZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgZXZlbnRBcmdzID0ge1xuICAgICAgICAgICAgb3JpZ2luYWxFdmVudDogZXZlbnQsXG4gICAgICAgICAgICBvd25lcjogdGhpcyxcbiAgICAgICAgICAgIHN0YXJ0WDogdGhpcy5fc3RhcnRYLFxuICAgICAgICAgICAgc3RhcnRZOiB0aGlzLl9zdGFydFksXG4gICAgICAgICAgICBwYWdlWDogZXZlbnQucGFnZVgsXG4gICAgICAgICAgICBwYWdlWTogZXZlbnQucGFnZVlcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5fcG9pbnRlckRvd25JZCA9IG51bGw7XG4gICAgICAgIHRoaXMuX2NsaWNrZWQgPSBmYWxzZTtcbiAgICAgICAgaWYgKHRoaXMuX2RyYWdTdGFydGVkKSB7XG4gICAgICAgICAgICB0aGlzLnpvbmUucnVuKCgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLmRyYWdFbmQuZW1pdChldmVudEFyZ3MpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAoIXRoaXMuYW5pbUluUHJvZ3Jlc3MpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm9uVHJhbnNpdGlvbkVuZChudWxsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBwdWJsaWMgb25UcmFuc2l0aW9uRW5kKGV2ZW50KSB7XG4gICAgICAgIGlmICgoIXRoaXMuX2RyYWdTdGFydGVkICYmICF0aGlzLmFuaW1JblByb2dyZXNzKSB8fCB0aGlzLl9jbGlja2VkKSB7XG4gICAgICAgICAgICAvLyBSZXR1cm4gaWYgbm8gZHJhZ2dpbmcgc3RhcnRlZCBhbmQgdGhlcmUgaXMgbm8gYW5pbWF0aW9uIGluIHByb2dyZXNzLlxuICAgICAgICAgICAgcmV0dXJuIDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLmdob3N0ICYmIHRoaXMuZ2hvc3RFbGVtZW50KSB7XG4gICAgICAgICAgICB0aGlzLl9naG9zdFN0YXJ0WCA9IHRoaXMuYmFzZUxlZnQgKyB0aGlzLndpbmRvd1Njcm9sbExlZnQ7XG4gICAgICAgICAgICB0aGlzLl9naG9zdFN0YXJ0WSA9IHRoaXMuYmFzZVRvcCArIHRoaXMud2luZG93U2Nyb2xsVG9wO1xuXG4gICAgICAgICAgICBjb25zdCBnaG9zdERlc3Ryb3lBcmdzOiBJRHJhZ0dob3N0QmFzZUV2ZW50QXJncyA9IHtcbiAgICAgICAgICAgICAgICBvd25lcjogdGhpcyxcbiAgICAgICAgICAgICAgICBnaG9zdEVsZW1lbnQ6IHRoaXMuZ2hvc3RFbGVtZW50LFxuICAgICAgICAgICAgICAgIGNhbmNlbDogZmFsc2VcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB0aGlzLmdob3N0RGVzdHJveS5lbWl0KGdob3N0RGVzdHJveUFyZ3MpO1xuICAgICAgICAgICAgaWYgKGdob3N0RGVzdHJveUFyZ3MuY2FuY2VsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5naG9zdEVsZW1lbnQucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0aGlzLmdob3N0RWxlbWVudCk7XG4gICAgICAgICAgICB0aGlzLmdob3N0RWxlbWVudCA9IG51bGw7XG4gICAgICAgICAgICBpZiAodGhpcy5fZHluYW1pY0dob3N0UmVmKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fZHluYW1pY0dob3N0UmVmLmRlc3Ryb3koKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9keW5hbWljR2hvc3RSZWYgPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKCF0aGlzLmdob3N0KSB7XG4gICAgICAgICAgICB0aGlzLmVsZW1lbnQubmF0aXZlRWxlbWVudC5zdHlsZS50cmFuc2l0aW9uUHJvcGVydHkgPSAnJztcbiAgICAgICAgICAgIHRoaXMuZWxlbWVudC5uYXRpdmVFbGVtZW50LnN0eWxlLnRyYW5zaXRpb25EdXJhdGlvbiA9ICcwLjBzJztcbiAgICAgICAgICAgIHRoaXMuZWxlbWVudC5uYXRpdmVFbGVtZW50LnN0eWxlLnRyYW5zaXRpb25UaW1pbmdGdW5jdGlvbiA9ICcnO1xuICAgICAgICAgICAgdGhpcy5lbGVtZW50Lm5hdGl2ZUVsZW1lbnQuc3R5bGUudHJhbnNpdGlvbkRlbGF5ID0gJyc7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5hbmltSW5Qcm9ncmVzcyA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9kcmFnU3RhcnRlZCA9IGZhbHNlO1xuXG4gICAgICAgIC8vIEV4ZWN1dGUgdHJhbnNpdGlvbmVkIGFmdGVyIGV2ZXJ5dGhpbmcgaXMgcmVzZXQgc28gaWYgdGhlIHVzZXIgc2V0cyBuZXcgbG9jYXRpb24gb24gdGhlIGJhc2Ugbm93IGl0IHdvdWxkIHdvcmsgYXMgZXhwZWN0ZWQuXG4gICAgICAgIHRoaXMuem9uZS5ydW4oKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy50cmFuc2l0aW9uZWQuZW1pdCh7XG4gICAgICAgICAgICAgICAgb3JpZ2luYWxFdmVudDogZXZlbnQsXG4gICAgICAgICAgICAgICAgb3duZXI6IHRoaXMsXG4gICAgICAgICAgICAgICAgc3RhcnRYOiB0aGlzLl9zdGFydFgsXG4gICAgICAgICAgICAgICAgc3RhcnRZOiB0aGlzLl9zdGFydFksXG4gICAgICAgICAgICAgICAgcGFnZVg6IHRoaXMuX3N0YXJ0WCxcbiAgICAgICAgICAgICAgICBwYWdlWTogdGhpcy5fc3RhcnRZXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqIENyZWF0ZSBnaG9zdCBlbGVtZW50IC0gaWYgYSBOb2RlIG9iamVjdCBpcyBwcm92aWRlZCBpdCBjcmVhdGVzIGEgY2xvbmUgb2YgdGhhdCBub2RlLFxuICAgICAqIG90aGVyd2lzZSBpdCBjbG9uZXMgdGhlIGhvc3QgZWxlbWVudC5cbiAgICAgKiBCaW5kIGFsbCBuZWVkZWQgZXZlbnRzLlxuICAgICAqIEBwYXJhbSBwYWdlWCBMYXRlc3QgcG9pbnRlciBwb3NpdGlvbiBvbiB0aGUgWCBheGlzIHJlbGF0aXZlIHRvIHRoZSBwYWdlLlxuICAgICAqIEBwYXJhbSBwYWdlWSBMYXRlc3QgcG9pbnRlciBwb3NpdGlvbiBvbiB0aGUgWSBheGlzIHJlbGF0aXZlIHRvIHRoZSBwYWdlLlxuICAgICAqIEBwYXJhbSBub2RlIFRoZSBOb2RlIG9iamVjdCB0byBiZSBjbG9uZWQuXG4gICAgICovXG4gICAgcHJvdGVjdGVkIGNyZWF0ZUdob3N0KHBhZ2VYLCBwYWdlWSwgbm9kZTogYW55ID0gbnVsbCkge1xuICAgICAgICBpZiAoIXRoaXMuZ2hvc3QpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLmdob3N0VGVtcGxhdGUpIHtcbiAgICAgICAgICAgIHRoaXMuX2R5bmFtaWNHaG9zdFJlZiA9IHRoaXMudmlld0NvbnRhaW5lci5jcmVhdGVFbWJlZGRlZFZpZXcodGhpcy5naG9zdFRlbXBsYXRlLCB0aGlzLmdob3N0Q29udGV4dCk7XG4gICAgICAgICAgICB0aGlzLmdob3N0RWxlbWVudCA9IHRoaXMuX2R5bmFtaWNHaG9zdFJlZi5yb290Tm9kZXNbMF07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmdob3N0RWxlbWVudCA9IG5vZGUgPyBub2RlLmNsb25lTm9kZSh0cnVlKSA6IHRoaXMuZWxlbWVudC5uYXRpdmVFbGVtZW50LmNsb25lTm9kZSh0cnVlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHRvdGFsTW92ZWRYID0gcGFnZVggLSB0aGlzLl9zdGFydFg7XG4gICAgICAgIGNvbnN0IHRvdGFsTW92ZWRZID0gcGFnZVkgLSB0aGlzLl9zdGFydFk7XG4gICAgICAgIHRoaXMuX2dob3N0SG9zdFggPSB0aGlzLmdob3N0SG9zdCA/IHRoaXMuZ2hvc3RIb3N0T2Zmc2V0TGVmdCh0aGlzLmdob3N0SG9zdCkgOiAwO1xuICAgICAgICB0aGlzLl9naG9zdEhvc3RZID0gdGhpcy5naG9zdEhvc3QgPyB0aGlzLmdob3N0SG9zdE9mZnNldFRvcCh0aGlzLmdob3N0SG9zdCkgOiAwO1xuXG4gICAgICAgIHRoaXMuZ2hvc3RFbGVtZW50LnN0eWxlLnRyYW5zaXRpb25EdXJhdGlvbiA9ICcwLjBzJztcbiAgICAgICAgdGhpcy5naG9zdEVsZW1lbnQuc3R5bGUucG9zaXRpb24gPSAnYWJzb2x1dGUnO1xuXG5cbiAgICAgICAgaWYgKHRoaXMuZ2hvc3RDbGFzcykge1xuICAgICAgICAgICAgdGhpcy5yZW5kZXJlci5hZGRDbGFzcyh0aGlzLmdob3N0RWxlbWVudCwgdGhpcy5naG9zdENsYXNzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGNyZWF0ZUV2ZW50QXJncyA9IHtcbiAgICAgICAgICAgIG93bmVyOiB0aGlzLFxuICAgICAgICAgICAgZ2hvc3RFbGVtZW50OiB0aGlzLmdob3N0RWxlbWVudCxcbiAgICAgICAgICAgIGNhbmNlbDogZmFsc2VcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5naG9zdENyZWF0ZS5lbWl0KGNyZWF0ZUV2ZW50QXJncyk7XG4gICAgICAgIGlmIChjcmVhdGVFdmVudEFyZ3MuY2FuY2VsKSB7XG4gICAgICAgICAgICB0aGlzLmdob3N0RWxlbWVudCA9IG51bGw7XG4gICAgICAgICAgICBpZiAodGhpcy5naG9zdFRlbXBsYXRlICYmIHRoaXMuX2R5bmFtaWNHaG9zdFJlZikge1xuICAgICAgICAgICAgICAgIHRoaXMuX2R5bmFtaWNHaG9zdFJlZi5kZXN0cm95KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5naG9zdEhvc3QpIHtcbiAgICAgICAgICAgIHRoaXMuZ2hvc3RIb3N0LmFwcGVuZENoaWxkKHRoaXMuZ2hvc3RFbGVtZW50KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQodGhpcy5naG9zdEVsZW1lbnQpO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgZ2hvc3RNYXJnaW5MZWZ0ID0gcGFyc2VJbnQoZG9jdW1lbnQuZGVmYXVsdFZpZXcuZ2V0Q29tcHV0ZWRTdHlsZSh0aGlzLmdob3N0RWxlbWVudClbJ21hcmdpbi1sZWZ0J10sIDEwKTtcbiAgICAgICAgY29uc3QgZ2hvc3RNYXJnaW5Ub3AgPSBwYXJzZUludChkb2N1bWVudC5kZWZhdWx0Vmlldy5nZXRDb21wdXRlZFN0eWxlKHRoaXMuZ2hvc3RFbGVtZW50KVsnbWFyZ2luLXRvcCddLCAxMCk7XG4gICAgICAgIHRoaXMuZ2hvc3RFbGVtZW50LnN0eWxlLmxlZnQgPSAodGhpcy5fZ2hvc3RTdGFydFggLSBnaG9zdE1hcmdpbkxlZnQgKyB0b3RhbE1vdmVkWCAtIHRoaXMuX2dob3N0SG9zdFgpICsgJ3B4JztcbiAgICAgICAgdGhpcy5naG9zdEVsZW1lbnQuc3R5bGUudG9wID0gKHRoaXMuX2dob3N0U3RhcnRZIC0gZ2hvc3RNYXJnaW5Ub3AgKyB0b3RhbE1vdmVkWSAtIHRoaXMuX2dob3N0SG9zdFgpICsgJ3B4JztcblxuICAgICAgICBpZiAodGhpcy5wb2ludGVyRXZlbnRzRW5hYmxlZCkge1xuICAgICAgICAgICAgLy8gVGhlIGdob3N0RWxlbWVudCB0YWtlcyBjb250cm9sIGZvciBtb3ZpbmcgYW5kIGRyYWdnaW5nIGFmdGVyIGl0IGhhcyBiZWVuIHJlbmRlcmVkLlxuICAgICAgICAgICAgaWYgKHRoaXMuX3BvaW50ZXJEb3duSWQgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmdob3N0RWxlbWVudC5zZXRQb2ludGVyQ2FwdHVyZSh0aGlzLl9wb2ludGVyRG93bklkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuZ2hvc3RFbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3BvaW50ZXJtb3ZlJywgKGFyZ3MpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLm9uUG9pbnRlck1vdmUoYXJncyk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMuZ2hvc3RFbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3BvaW50ZXJ1cCcsIChhcmdzKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5vblBvaW50ZXJVcChhcmdzKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy5naG9zdEVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignbG9zdHBvaW50ZXJjYXB0dXJlJywgKGFyZ3MpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLm9uUG9pbnRlckxvc3QoYXJncyk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFRyYW5zaXRpb24gYW5pbWF0aW9uIHdoZW4gdGhlIGdob3N0RWxlbWVudCBpcyByZWxlYXNlZCBhbmQgaXQgcmV0dXJucyB0byBpdCdzIG9yaWdpbmFsIHBvc2l0aW9uLlxuICAgICAgICB0aGlzLmdob3N0RWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCd0cmFuc2l0aW9uZW5kJywgKGFyZ3MpID0+IHtcbiAgICAgICAgICAgIHRoaXMub25UcmFuc2l0aW9uRW5kKGFyZ3MpO1xuICAgICAgICB9KTtcblxuICAgICAgICB0aGlzLmNkci5kZXRlY3RDaGFuZ2VzKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqIERpc3BhdGNoIGN1c3RvbSBpZ3hEcmFnRW50ZXIvaWd4RHJhZ0xlYXZlIGV2ZW50cyBiYXNlZCBvbiBjdXJyZW50IHBvaW50ZXIgcG9zaXRpb24gYW5kIGlmIGRyb3AgYXJlYSBpcyB1bmRlci5cbiAgICAgKi9cbiAgICBwcm90ZWN0ZWQgZGlzcGF0Y2hEcmFnRXZlbnRzKHBhZ2VYOiBudW1iZXIsIHBhZ2VZOiBudW1iZXIsIG9yaWdpbmFsRXZlbnQpIHtcbiAgICAgICAgbGV0IHRvcERyb3BBcmVhO1xuICAgICAgICBjb25zdCBjdXN0b21FdmVudEFyZ3M6IElneERyYWdDdXN0b21FdmVudERldGFpbHMgPSB7XG4gICAgICAgICAgICBzdGFydFg6IHRoaXMuX3N0YXJ0WCxcbiAgICAgICAgICAgIHN0YXJ0WTogdGhpcy5fc3RhcnRZLFxuICAgICAgICAgICAgcGFnZVgsXG4gICAgICAgICAgICBwYWdlWSxcbiAgICAgICAgICAgIG93bmVyOiB0aGlzLFxuICAgICAgICAgICAgb3JpZ2luYWxFdmVudFxuICAgICAgICB9O1xuXG4gICAgICAgIGxldCBlbGVtZW50c0Zyb21Qb2ludCA9IHRoaXMuZ2V0RWxlbWVudHNBdFBvaW50KHBhZ2VYLCBwYWdlWSk7XG5cbiAgICAgICAgLy8gQ2hlY2sgZm9yIHNoYWRvd1Jvb3QgaW5zdGFuY2UgYW5kIHVzZSBpdCBpZiBwcmVzZW50XG4gICAgICAgIGZvciAoY29uc3QgZWxGcm9tUG9pbnQgb2YgZWxlbWVudHNGcm9tUG9pbnQpIHtcbiAgICAgICAgICAgIGlmICghIWVsRnJvbVBvaW50Py5zaGFkb3dSb290KSB7XG4gICAgICAgICAgICAgICAgZWxlbWVudHNGcm9tUG9pbnQgPSBlbEZyb21Qb2ludC5zaGFkb3dSb290LmVsZW1lbnRzRnJvbVBvaW50KHBhZ2VYLCBwYWdlWSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKGNvbnN0IGVsZW1lbnQgb2YgZWxlbWVudHNGcm9tUG9pbnQpIHtcbiAgICAgICAgICAgIGlmIChlbGVtZW50LmdldEF0dHJpYnV0ZSgnZHJvcHBhYmxlJykgPT09ICd0cnVlJyAmJlxuICAgICAgICAgICAgZWxlbWVudCAhPT0gdGhpcy5naG9zdEVsZW1lbnQgJiYgZWxlbWVudCAhPT0gdGhpcy5lbGVtZW50Lm5hdGl2ZUVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICB0b3BEcm9wQXJlYSA9IGVsZW1lbnQ7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodG9wRHJvcEFyZWEgJiZcbiAgICAgICAgICAgICghdGhpcy5fbGFzdERyb3BBcmVhIHx8ICh0aGlzLl9sYXN0RHJvcEFyZWEgJiYgdGhpcy5fbGFzdERyb3BBcmVhICE9PSB0b3BEcm9wQXJlYSkpKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX2xhc3REcm9wQXJlYSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmRpc3BhdGNoRXZlbnQodGhpcy5fbGFzdERyb3BBcmVhLCAnaWd4RHJhZ0xlYXZlJywgY3VzdG9tRXZlbnRBcmdzKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB0aGlzLl9sYXN0RHJvcEFyZWEgPSB0b3BEcm9wQXJlYTtcbiAgICAgICAgICAgICAgICB0aGlzLmRpc3BhdGNoRXZlbnQodGhpcy5fbGFzdERyb3BBcmVhLCAnaWd4RHJhZ0VudGVyJywgY3VzdG9tRXZlbnRBcmdzKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoIXRvcERyb3BBcmVhICYmIHRoaXMuX2xhc3REcm9wQXJlYSkge1xuICAgICAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudCh0aGlzLl9sYXN0RHJvcEFyZWEsICdpZ3hEcmFnTGVhdmUnLCBjdXN0b21FdmVudEFyZ3MpO1xuICAgICAgICAgICAgICAgIHRoaXMuX2xhc3REcm9wQXJlYSA9IG51bGw7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgIGlmICh0b3BEcm9wQXJlYSkge1xuICAgICAgICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KHRvcERyb3BBcmVhLCAnaWd4RHJhZ092ZXInLCBjdXN0b21FdmVudEFyZ3MpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqIERpc3BhdGNoIGN1c3RvbSBpZ3hEcm9wIGV2ZW50IGJhc2VkIG9uIGN1cnJlbnQgcG9pbnRlciBwb3NpdGlvbiBpZiB0aGVyZSBpcyBsYXN0IHJlY29yZGVyIGRyb3AgYXJlYSB1bmRlciB0aGUgcG9pbnRlci5cbiAgICAgKiBMYXN0IHJlY29yZGVyIGRyb3AgYXJlYSBpcyB1cGRhdGVkIGluIEBkaXNwYXRjaERyYWdFdmVudHMgbWV0aG9kLlxuICAgICAqL1xuICAgIHByb3RlY3RlZCBkaXNwYXRjaERyb3BFdmVudChwYWdlWDogbnVtYmVyLCBwYWdlWTogbnVtYmVyLCBvcmlnaW5hbEV2ZW50KSB7XG4gICAgICAgIGNvbnN0IGV2ZW50QXJnczogSWd4RHJhZ0N1c3RvbUV2ZW50RGV0YWlscyA9IHtcbiAgICAgICAgICAgIHN0YXJ0WDogdGhpcy5fc3RhcnRYLFxuICAgICAgICAgICAgc3RhcnRZOiB0aGlzLl9zdGFydFksXG4gICAgICAgICAgICBwYWdlWCxcbiAgICAgICAgICAgIHBhZ2VZLFxuICAgICAgICAgICAgb3duZXI6IHRoaXMsXG4gICAgICAgICAgICBvcmlnaW5hbEV2ZW50XG4gICAgICAgIH07XG5cbiAgICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KHRoaXMuX2xhc3REcm9wQXJlYSwgJ2lneERyb3AnLCBldmVudEFyZ3MpO1xuICAgICAgICB0aGlzLmRpc3BhdGNoRXZlbnQodGhpcy5fbGFzdERyb3BBcmVhLCAnaWd4RHJhZ0xlYXZlJywgZXZlbnRBcmdzKTtcbiAgICAgICAgdGhpcy5fbGFzdERyb3BBcmVhID0gbnVsbDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgcHJvdGVjdGVkIGdldEVsZW1lbnRzQXRQb2ludChwYWdlWDogbnVtYmVyLCBwYWdlWTogbnVtYmVyKSB7XG4gICAgICAgIC8vIGNvcnJlY3QgdGhlIGNvb3JkaW5hdGVzIHdpdGggdGhlIGN1cnJlbnQgc2Nyb2xsIHBvc2l0aW9uLCBiZWNhdXNlXG4gICAgICAgIC8vIGRvY3VtZW50LmVsZW1lbnRzRnJvbVBvaW50IGNvbnNpZGVyIHBvc2l0aW9uIHdpdGhpbiB0aGUgY3VycmVudCB2aWV3cG9ydFxuICAgICAgICAvLyB3aW5kb3cucGFnZVhPZmZzZXQgPT0gd2luZG93LnNjcm9sbFg7IC8vIGFsd2F5cyB0cnVlXG4gICAgICAgIC8vIHVzaW5nIHdpbmRvdy5wYWdlWE9mZnNldCBmb3IgSUU5IGNvbXBhdGliaWxpdHlcbiAgICAgICAgY29uc3Qgdmlld1BvcnRYID0gcGFnZVggLSB3aW5kb3cucGFnZVhPZmZzZXQ7XG4gICAgICAgIGNvbnN0IHZpZXdQb3J0WSA9IHBhZ2VZIC0gd2luZG93LnBhZ2VZT2Zmc2V0O1xuICAgICAgICBpZiAoZG9jdW1lbnRbJ21zRWxlbWVudHNGcm9tUG9pbnQnXSkge1xuICAgICAgICAgICAgLy8gRWRnZSBhbmQgSUUgc3BlY2lhbCBzbm93Zmxha2VzXG4gICAgICAgICAgICBjb25zdCBlbGVtZW50cyA9IGRvY3VtZW50Wydtc0VsZW1lbnRzRnJvbVBvaW50J10odmlld1BvcnRYLCB2aWV3UG9ydFkpO1xuICAgICAgICAgICAgcmV0dXJuIGVsZW1lbnRzID09PSBudWxsID8gW10gOiBlbGVtZW50cztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIE90aGVyIGJyb3dzZXJzIGxpa2UgQ2hyb21lLCBGaXJlZm94LCBPcGVyYVxuICAgICAgICAgICAgcmV0dXJuIGRvY3VtZW50LmVsZW1lbnRzRnJvbVBvaW50KHZpZXdQb3J0WCwgdmlld1BvcnRZKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBwcm90ZWN0ZWQgZGlzcGF0Y2hFdmVudCh0YXJnZXQsIGV2ZW50TmFtZTogc3RyaW5nLCBldmVudEFyZ3M6IElneERyYWdDdXN0b21FdmVudERldGFpbHMpIHtcbiAgICAgICAgLy8gVGhpcyB3YXkgaXMgSUUxMSBjb21wYXRpYmxlLlxuICAgICAgICBjb25zdCBkcmFnTGVhdmVFdmVudCA9IGRvY3VtZW50LmNyZWF0ZUV2ZW50KCdDdXN0b21FdmVudCcpO1xuICAgICAgICBkcmFnTGVhdmVFdmVudC5pbml0Q3VzdG9tRXZlbnQoZXZlbnROYW1lLCBmYWxzZSwgZmFsc2UsIGV2ZW50QXJncyk7XG4gICAgICAgIHRhcmdldC5kaXNwYXRjaEV2ZW50KGRyYWdMZWF2ZUV2ZW50KTtcbiAgICAgICAgLy8gT3RoZXJ3aXNlIGNhbiBiZSB1c2VkIGB0YXJnZXQuZGlzcGF0Y2hFdmVudChuZXcgQ3VzdG9tRXZlbnQoZXZlbnROYW1lLCBldmVudEFyZ3MpKTtgXG4gICAgfVxuXG4gICAgcHJvdGVjdGVkIGdldFRyYW5zZm9ybVgoZWxlbSkge1xuICAgICAgICBsZXQgcG9zWCA9IDA7XG4gICAgICAgIGlmIChlbGVtLnN0eWxlLnRyYW5zZm9ybSkge1xuICAgICAgICAgICAgY29uc3QgbWF0cml4ID0gZWxlbS5zdHlsZS50cmFuc2Zvcm07XG4gICAgICAgICAgICBjb25zdCB2YWx1ZXMgPSBtYXRyaXggPyBtYXRyaXgubWF0Y2goLy0/W1xcZFxcLl0rL2cpIDogdW5kZWZpbmVkO1xuICAgICAgICAgICAgcG9zWCA9IHZhbHVlcyA/IE51bWJlcih2YWx1ZXNbIDEgXSkgOiAwO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHBvc1g7XG4gICAgfVxuXG4gICAgcHJvdGVjdGVkIGdldFRyYW5zZm9ybVkoZWxlbSkge1xuICAgICAgICBsZXQgcG9zWSA9IDA7XG4gICAgICAgIGlmIChlbGVtLnN0eWxlLnRyYW5zZm9ybSkge1xuICAgICAgICAgICAgY29uc3QgbWF0cml4ID0gZWxlbS5zdHlsZS50cmFuc2Zvcm07XG4gICAgICAgICAgICBjb25zdCB2YWx1ZXMgPSBtYXRyaXggPyBtYXRyaXgubWF0Y2goLy0/W1xcZFxcLl0rL2cpIDogdW5kZWZpbmVkO1xuICAgICAgICAgICAgcG9zWSA9IHZhbHVlcyA/IE51bWJlcih2YWx1ZXNbIDIgXSkgOiAwO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHBvc1k7XG4gICAgfVxuXG4gICAgLyoqIE1ldGhvZCBzZXR0aW5nIHRyYW5zZm9ybWF0aW9uIHRvIHRoZSBiYXNlIGRyYWdnYWJsZSBlbGVtZW50LiAqL1xuICAgIHByb3RlY3RlZCBzZXRUcmFuc2Zvcm1YWSh4OiBudW1iZXIsIHk6IG51bWJlcikge1xuICAgICAgICB0aGlzLmVsZW1lbnQubmF0aXZlRWxlbWVudC5zdHlsZS50cmFuc2Zvcm0gPSAndHJhbnNsYXRlM2QoJyArIHggKyAncHgsICcgKyB5ICsgJ3B4LCAwcHgpJztcbiAgICB9XG5cbiAgICBwcm90ZWN0ZWQgZ2hvc3RIb3N0T2Zmc2V0TGVmdChnaG9zdEhvc3Q6IGFueSkge1xuICAgICAgICBjb25zdCBnaG9zdFBvc2l0aW9uID0gZG9jdW1lbnQuZGVmYXVsdFZpZXcuZ2V0Q29tcHV0ZWRTdHlsZShnaG9zdEhvc3QpLmdldFByb3BlcnR5VmFsdWUoJ3Bvc2l0aW9uJyk7XG4gICAgICAgIGlmIChnaG9zdFBvc2l0aW9uID09PSAnc3RhdGljJyAmJiBnaG9zdEhvc3Qub2Zmc2V0UGFyZW50ICYmIGdob3N0SG9zdC5vZmZzZXRQYXJlbnQgPT09IGRvY3VtZW50LmJvZHkpIHtcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9IGVsc2UgaWYgKGdob3N0UG9zaXRpb24gPT09ICdzdGF0aWMnICYmIGdob3N0SG9zdC5vZmZzZXRQYXJlbnQpIHtcbiAgICAgICAgICAgIHJldHVybiBnaG9zdEhvc3Qub2Zmc2V0UGFyZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLmxlZnQgLSB0aGlzLndpbmRvd1Njcm9sbExlZnQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGdob3N0SG9zdC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5sZWZ0IC0gdGhpcy53aW5kb3dTY3JvbGxMZWZ0O1xuICAgIH1cblxuICAgIHByb3RlY3RlZCBnaG9zdEhvc3RPZmZzZXRUb3AoZ2hvc3RIb3N0OiBhbnkpIHtcbiAgICAgICAgY29uc3QgZ2hvc3RQb3NpdGlvbiA9IGRvY3VtZW50LmRlZmF1bHRWaWV3LmdldENvbXB1dGVkU3R5bGUoZ2hvc3RIb3N0KS5nZXRQcm9wZXJ0eVZhbHVlKCdwb3NpdGlvbicpO1xuICAgICAgICBpZiAoZ2hvc3RQb3NpdGlvbiA9PT0gJ3N0YXRpYycgJiYgZ2hvc3RIb3N0Lm9mZnNldFBhcmVudCAmJiBnaG9zdEhvc3Qub2Zmc2V0UGFyZW50ID09PSBkb2N1bWVudC5ib2R5KSB7XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfSBlbHNlIGlmIChnaG9zdFBvc2l0aW9uID09PSAnc3RhdGljJyAmJiBnaG9zdEhvc3Qub2Zmc2V0UGFyZW50KSB7XG4gICAgICAgICAgICByZXR1cm4gZ2hvc3RIb3N0Lm9mZnNldFBhcmVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS50b3AgLSB0aGlzLndpbmRvd1Njcm9sbFRvcDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZ2hvc3RIb3N0LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLnRvcCAtIHRoaXMud2luZG93U2Nyb2xsVG9wO1xuICAgIH1cblxuICAgIHByb3RlY3RlZCBnZXRDb250YWluZXJTY3JvbGxEaXJlY3Rpb24oKSB7XG4gICAgICAgIGNvbnN0IGNvbnRhaW5lckJvdW5kcyA9IHRoaXMuc2Nyb2xsQ29udGFpbmVyID8gIHRoaXMuc2Nyb2xsQ29udGFpbmVyLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpIDogbnVsbDtcbiAgICAgICAgY29uc3Qgc2Nyb2xsZWRYID0gIXRoaXMuc2Nyb2xsQ29udGFpbmVyID8gdGhpcy53aW5kb3dTY3JvbGxMZWZ0ID4gMCA6IHRoaXMuc2Nyb2xsQ29udGFpbmVyLnNjcm9sbExlZnQgPiAwO1xuICAgICAgICBjb25zdCBzY3JvbGxlZFkgPSAhdGhpcy5zY3JvbGxDb250YWluZXIgPyB0aGlzLndpbmRvd1Njcm9sbFRvcCA+IDAgOiB0aGlzLnNjcm9sbENvbnRhaW5lci5zY3JvbGxUb3AgPiAwO1xuICAgICAgICAvLyBUYWtlIGludG8gYWNjb3VudCB3aW5kb3cgc2Nyb2xsIHRvcCBiZWNhdXNlIHdlIGRvIG5vdCB1c2UgZml4ZWQgcG9zaXRpb25pbmcgdG8gdGhlIHdpbmRvdy5cbiAgICAgICAgY29uc3QgdG9wQm9yZGVyID0gKCF0aGlzLnNjcm9sbENvbnRhaW5lciA/IDAgOiBjb250YWluZXJCb3VuZHMudG9wKSArIHRoaXMud2luZG93U2Nyb2xsVG9wICsgdGhpcy5fc2Nyb2xsQ29udGFpbmVyVGhyZXNob2xkO1xuICAgICAgICAvLyBTdWJ0cmFjdCB0aGUgZWxlbWVudCBoZWlnaHQgYmVjYXVzZSB3ZSBwb3NpdGlvbiBpdCBmcm9tIHRvcCBsZWZ0IGNvcm5lci5cbiAgICAgICAgY29uc3QgZWxlbWVudEhlaWdodCA9IHRoaXMuZ2hvc3QgJiYgdGhpcy5naG9zdEVsZW1lbnQgPyB0aGlzLmdob3N0RWxlbWVudC5vZmZzZXRIZWlnaHQgOiB0aGlzLmVsZW1lbnQubmF0aXZlRWxlbWVudC5vZmZzZXRIZWlnaHQ7XG4gICAgICAgIGNvbnN0IGJvdHRvbUJvcmRlciA9ICghdGhpcy5zY3JvbGxDb250YWluZXIgPyB3aW5kb3cuaW5uZXJIZWlnaHQgOiBjb250YWluZXJCb3VuZHMuYm90dG9tICkgK1xuICAgICAgICAgICAgdGhpcy53aW5kb3dTY3JvbGxUb3AgLSB0aGlzLl9zY3JvbGxDb250YWluZXJUaHJlc2hvbGQgIC0gZWxlbWVudEhlaWdodDtcbiAgICAgICAgLy8gU2FtZSBmb3Igd2luZG93IHNjcm9sbCBsZWZ0IFxuICAgICAgICBjb25zdCBsZWZ0Qm9yZGVyID0gKCF0aGlzLnNjcm9sbENvbnRhaW5lciA/IDAgOiBjb250YWluZXJCb3VuZHMubGVmdCkgKyB0aGlzLndpbmRvd1Njcm9sbExlZnQgKyB0aGlzLl9zY3JvbGxDb250YWluZXJUaHJlc2hvbGQ7XG4gICAgICAgIC8vIFN1YnRyYWN0IHRoZSBlbGVtZW50IHdpZHRoIGFnYWluIGJlY2F1c2Ugd2UgcG9zaXRpb24gaXQgZnJvbSB0b3AgbGVmdCBjb3JuZXIuXG4gICAgICAgIGNvbnN0IGVsZW1lbnRXaWR0aCA9IHRoaXMuZ2hvc3QgJiYgdGhpcy5naG9zdEVsZW1lbnQgPyB0aGlzLmdob3N0RWxlbWVudC5vZmZzZXRXaWR0aCA6ICB0aGlzLmVsZW1lbnQubmF0aXZlRWxlbWVudC5vZmZzZXRXaWR0aDtcbiAgICAgICAgY29uc3QgcmlnaHRCb3JkZXIgPSAoIXRoaXMuc2Nyb2xsQ29udGFpbmVyID8gd2luZG93LmlubmVyV2lkdGggOiBjb250YWluZXJCb3VuZHMucmlnaHQpICtcbiAgICAgICAgICAgIHRoaXMud2luZG93U2Nyb2xsTGVmdCAtIHRoaXMuX3Njcm9sbENvbnRhaW5lclRocmVzaG9sZCAtIGVsZW1lbnRXaWR0aFxuICAgICAgICBcbiAgICAgICAgaWYgKHRoaXMucGFnZVkgPD0gdG9wQm9yZGVyICYmIHNjcm9sbGVkWSkge1xuICAgICAgICAgICAgcmV0dXJuIERyYWdTY3JvbGxEaXJlY3Rpb24uVVA7XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5wYWdlWSA+IGJvdHRvbUJvcmRlcikge1xuICAgICAgICAgICAgcmV0dXJuIERyYWdTY3JvbGxEaXJlY3Rpb24uRE9XTjtcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLnBhZ2VYIDwgbGVmdEJvcmRlciAmJiBzY3JvbGxlZFgpIHtcbiAgICAgICAgICAgIHJldHVybiBEcmFnU2Nyb2xsRGlyZWN0aW9uLkxFRlQ7XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5wYWdlWCA+IHJpZ2h0Qm9yZGVyKSB7XG4gICAgICAgICAgICByZXR1cm4gRHJhZ1Njcm9sbERpcmVjdGlvbi5SSUdIVDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBwcm90ZWN0ZWQgb25TY3JvbGxDb250YWluZXJTdGVwKHNjcm9sbERpcjogRHJhZ1Njcm9sbERpcmVjdGlvbikge1xuICAgICAgICBhbmltYXRpb25GcmFtZVNjaGVkdWxlci5zY2hlZHVsZSgoKSA9PiB7XG5cbiAgICAgICAgICAgIGxldCB4RGlyID0gc2Nyb2xsRGlyID09IERyYWdTY3JvbGxEaXJlY3Rpb24uTEVGVCA/IC0xIDogKHNjcm9sbERpciA9PSBEcmFnU2Nyb2xsRGlyZWN0aW9uLlJJR0hUID8gMSA6IDApO1xuICAgICAgICAgICAgbGV0IHlEaXIgPSBzY3JvbGxEaXIgPT0gRHJhZ1Njcm9sbERpcmVjdGlvbi5VUCA/IC0xIDogKHNjcm9sbERpciA9PSBEcmFnU2Nyb2xsRGlyZWN0aW9uLkRPV04gPyAxIDogMCk7XG4gICAgICAgICAgICBpZiAoIXRoaXMuc2Nyb2xsQ29udGFpbmVyKSB7XG4gICAgICAgICAgICAgICAgLy8gQ2FwIHNjcm9sbGluZyBzbyB3ZSBkb24ndCBzY3JvbGwgcGFzdCB0aGUgd2luZG93IG1heCBzY3JvbGwgcG9zaXRpb24uXG4gICAgICAgICAgICAgICAgY29uc3QgbWF4U2Nyb2xsWCA9IHRoaXMuX29yaWdpbmFsU2Nyb2xsQ29udGFpbmVyV2lkdGggLSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xpZW50V2lkdGg7XG4gICAgICAgICAgICAgICAgY29uc3QgbWF4U2Nyb2xsWSA9IHRoaXMuX29yaWdpbmFsU2Nyb2xsQ29udGFpbmVySGVpZ2h0IC0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsaWVudEhlaWdodDtcbiAgICAgICAgICAgICAgICB4RGlyID0gKHRoaXMud2luZG93U2Nyb2xsTGVmdCA8PSAwICYmIHhEaXIgPCAwKSB8fCAodGhpcy53aW5kb3dTY3JvbGxMZWZ0ID49IG1heFNjcm9sbFggJiYgeERpciA+IDApID8gMCA6IHhEaXI7XG4gICAgICAgICAgICAgICAgeURpciA9ICh0aGlzLndpbmRvd1Njcm9sbFRvcCA8PSAwICYmIHlEaXIgPCAwKSB8fCAodGhpcy53aW5kb3dTY3JvbGxUb3AgPj0gbWF4U2Nyb2xsWSAmJiB5RGlyID4gMCkgPyAwIDogeURpcjtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gQ2FwIHNjcm9sbGluZyBzbyB3ZSBkb24ndCBzY3JvbGwgcGFzdCB0aGUgY29udGFpbmVyIG1heCBzY3JvbGwgcG9zaXRpb24uXG4gICAgICAgICAgICAgICAgY29uc3QgbWF4U2Nyb2xsWCA9IHRoaXMuX29yaWdpbmFsU2Nyb2xsQ29udGFpbmVyV2lkdGggLSB0aGlzLnNjcm9sbENvbnRhaW5lci5jbGllbnRXaWR0aDtcbiAgICAgICAgICAgICAgICBjb25zdCBtYXhTY3JvbGxZID0gdGhpcy5fb3JpZ2luYWxTY3JvbGxDb250YWluZXJIZWlnaHQgLSB0aGlzLnNjcm9sbENvbnRhaW5lci5jbGllbnRIZWlnaHQ7XG4gICAgICAgICAgICAgICAgeERpciA9ICh0aGlzLnNjcm9sbENvbnRhaW5lci5zY3JvbGxMZWZ0IDw9IDAgJiYgeERpciA8IDApIHx8ICh0aGlzLnNjcm9sbENvbnRhaW5lci5zY3JvbGxMZWZ0ID49IG1heFNjcm9sbFggJiYgeERpciA+IDApID8gMCA6IHhEaXI7XG4gICAgICAgICAgICAgICAgeURpciA9ICh0aGlzLnNjcm9sbENvbnRhaW5lci5zY3JvbGxUb3AgPD0gMCAmJiB5RGlyIDwgMCkgfHwgKHRoaXMuc2Nyb2xsQ29udGFpbmVyLnNjcm9sbFRvcCA+PSBtYXhTY3JvbGxZICYmIHlEaXIgPiAwKSA/IDAgOiB5RGlyO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjb25zdCBzY3JvbGxCeVggPSB4RGlyICogdGhpcy5fc2Nyb2xsQ29udGFpbmVyU3RlcDtcbiAgICAgICAgICAgIGNvbnN0IHNjcm9sbEJ5WSA9IHlEaXIgKiB0aGlzLl9zY3JvbGxDb250YWluZXJTdGVwO1xuXG4gICAgICAgICAgICAvLyBTY3JvbGwgdGhlIGNvcnJlc3BvbmRpbmcgd2luZG93IG9yIGNvbnRhaW5lci5cbiAgICAgICAgICAgIGlmICghdGhpcy5zY3JvbGxDb250YWluZXIpIHtcbiAgICAgICAgICAgICAgICB3aW5kb3cuc2Nyb2xsQnkoc2Nyb2xsQnlYLCBzY3JvbGxCeVkpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNjcm9sbENvbnRhaW5lci5zY3JvbGxMZWZ0ICs9IHNjcm9sbEJ5WDtcbiAgICAgICAgICAgICAgICB0aGlzLnNjcm9sbENvbnRhaW5lci5zY3JvbGxUb3AgKz0gc2Nyb2xsQnlZO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAodGhpcy5naG9zdCAmJiAhdGhpcy5zY3JvbGxDb250YWluZXIpICB7XG4gICAgICAgICAgICAgICAgLy8gU2Nyb2xsIHRoZSBnaG9zdCBvbmx5IHdoZW4gdGhlcmUgaXMgbm8gY29udGFpbmVyIHNwZWNpZmllcy5cbiAgICAgICAgICAgICAgICAvLyBJZiBpdCBoYXMgY29udGFpbmVyIHRoZSBnaG9zdCBwcmV0dHkgbXVjaCBzdGF5cyBpbiB0aGUgc2FtZSBwb3NpdGlvbiB3aGlsZSB0aGUgY29udGFpbmVyIGlzIHNjcm9sbGVkIHNpbmNlIGUgdXNlIHRvcC9sZWZ0IHBvc2l0aW9uLlxuICAgICAgICAgICAgICAgIC8vIE90aGVyd2lzZSBpbmNyZWFzZSB0aGUgcG9zaXRpb24gdGhlIHNhbWUgYW1vdW50IHdlIGhhdmUgc2Nyb2xsZWQgdGhlIHdpbmRvd1xuICAgICAgICAgICAgICAgIHRoaXMuZ2hvc3RMZWZ0ICs9IHNjcm9sbEJ5WDtcbiAgICAgICAgICAgICAgICB0aGlzLmdob3N0VG9wICs9IHNjcm9sbEJ5WTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoIXRoaXMuZ2hvc3QpIHtcbiAgICAgICAgICAgICAgICAvLyBNb3ZlIHRoZSBiYXNlIGVsZW1lbnQgdGhlIHNhbWUgYW1vdW50IHdlIG1vdmVkIHRoZSB3aW5kb3cvY29udGFpbmVyIGJlY2F1c2Ugd2UgdXNlIHRyYW5zZm9ybWF0aW9ucy5cbiAgICAgICAgICAgICAgICBjb25zdCB0cmFuc2xhdGVYID0gdGhpcy5nZXRUcmFuc2Zvcm1YKHRoaXMuZWxlbWVudC5uYXRpdmVFbGVtZW50KSArIHNjcm9sbEJ5WDtcbiAgICAgICAgICAgICAgICBjb25zdCB0cmFuc2xhdGVZID0gdGhpcy5nZXRUcmFuc2Zvcm1ZKHRoaXMuZWxlbWVudC5uYXRpdmVFbGVtZW50KSArIHNjcm9sbEJ5WTtcbiAgICAgICAgICAgICAgICB0aGlzLnNldFRyYW5zZm9ybVhZKHRyYW5zbGF0ZVgsIHRyYW5zbGF0ZVkpO1xuICAgICAgICAgICAgICAgIGlmICghdGhpcy5zY3JvbGxDb250YWluZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fbGFzdFggKz0gc2Nyb2xsQnlYO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9sYXN0WSArPSBzY3JvbGxCeVk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KVxuICAgIH1cblxuICAgIHByb3RlY3RlZCBvblNjcm9sbENvbnRhaW5lcigpIHtcbiAgICAgICAgY29uc3Qgc2Nyb2xsRGlyID0gdGhpcy5nZXRDb250YWluZXJTY3JvbGxEaXJlY3Rpb24oKTtcbiAgICAgICAgaWYgKHNjcm9sbERpciAhPT0gbnVsbCAmJiBzY3JvbGxEaXIgIT09IHVuZGVmaW5lZCAmJiAhdGhpcy5fY29udGFpbmVyU2Nyb2xsSW50ZXJ2YWxJZCkge1xuICAgICAgICAgICAgLy8gU2F2ZSBvcmlnaW5hbCBjb250YWluZXIgc2l6ZXMgdG8gZW5zdXJlIHRoYXQgd2UgZG9uJ3QgaW5jcmVhc2Ugc2Nyb2xsIHNpemVzIGluZmluaXRlbHkgd2hlbiBvdXQgb2YgYm91bmRzLlxuICAgICAgICAgICAgdGhpcy5fb3JpZ2luYWxTY3JvbGxDb250YWluZXJXaWR0aCA9IHRoaXMuc2Nyb2xsQ29udGFpbmVyID8gdGhpcy5zY3JvbGxDb250YWluZXIuc2Nyb2xsV2lkdGggOiB0aGlzLndpbmRvd1Njcm9sbFdpZHRoO1xuICAgICAgICAgICAgdGhpcy5fb3JpZ2luYWxTY3JvbGxDb250YWluZXJIZWlnaHQgPSB0aGlzLnNjcm9sbENvbnRhaW5lciA/IHRoaXMuc2Nyb2xsQ29udGFpbmVyLnNjcm9sbEhlaWdodCA6IHRoaXMud2luZG93U2Nyb2xsSGVpZ2h0O1xuXG4gICAgICAgICAgICB0aGlzLl9jb250YWluZXJTY3JvbGxJbnRlcnZhbElkID0gc2V0SW50ZXJ2YWwoKCkgPT4gdGhpcy5vblNjcm9sbENvbnRhaW5lclN0ZXAoc2Nyb2xsRGlyKSwgdGhpcy5fc2Nyb2xsQ29udGFpbmVyU3RlcE1zKTtcbiAgICAgICAgfSBlbHNlIGlmICgoc2Nyb2xsRGlyID09PSBudWxsIHx8IHNjcm9sbERpciA9PT0gdW5kZWZpbmVkKSAmJiB0aGlzLl9jb250YWluZXJTY3JvbGxJbnRlcnZhbElkKSB7XG4gICAgICAgICAgICAvLyBXZSBtb3ZlZCBvdXQgb2YgZW5kIGJvdW5kcyBhbmQgdGhlcmUgaXMgaW50ZXJ2YWwgc3RhcnRlZFxuICAgICAgICAgICAgY2xlYXJJbnRlcnZhbCh0aGlzLl9jb250YWluZXJTY3JvbGxJbnRlcnZhbElkKTtcbiAgICAgICAgICAgIHRoaXMuX2NvbnRhaW5lclNjcm9sbEludGVydmFsSWQgPSBudWxsO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5ARGlyZWN0aXZlKHtcbiAgICBleHBvcnRBczogJ2Ryb3AnLFxuICAgIHNlbGVjdG9yOiAnW2lneERyb3BdJ1xufSlcbmV4cG9ydCBjbGFzcyBJZ3hEcm9wRGlyZWN0aXZlIGltcGxlbWVudHMgT25Jbml0LCBPbkRlc3Ryb3kge1xuICAgIC8qKlxuICAgICAqIC0gU2F2ZSBkYXRhIGluc2lkZSB0aGUgYGlneERyb3BgIGRpcmVjdGl2ZS4gVGhpcyBjYW4gYmUgc2V0IHdoZW4gaW5zdGFuY2luZyBgaWd4RHJvcGAgb24gYW4gZWxlbWVudC5cbiAgICAgKiBgYGBodG1sXG4gICAgICogPGRpdiBbaWd4RHJvcF09XCJ7IHNvdXJjZTogbXlFbGVtZW50IH1cIj48L2Rpdj5cbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBJZ3hEcm9wRGlyZWN0aXZlXG4gICAgICovXG4gICAgQElucHV0KCdpZ3hEcm9wJylcbiAgICBwdWJsaWMgc2V0IGRhdGEodjogYW55KSB7XG4gICAgICAgIHRoaXMuX2RhdGEgPSB2O1xuICAgIH1cblxuICAgIHB1YmxpYyBnZXQgZGF0YSgpOiBhbnkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZGF0YTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBbiBASW5wdXQgcHJvcGVydHkgdGhhdCBwcm92aWRlIGEgd2F5IGZvciBpZ3hEcmFnIGFuZCBpZ3hEcm9wIHRvIGJlIGxpbmtlZCB0aHJvdWdoIGNoYW5uZWxzLlxuICAgICAqIEl0IGFjY2VwdHMgc2luZ2xlIHZhbHVlIG9yIGFuIGFycmF5IG9mIHZhbHVlcyBhbmQgZXZhbHVhdGVzIHRoZW4gdXNpbmcgc3RyaWN0IGVxdWFsaXR5LlxuICAgICAqIGBgYGh0bWxcbiAgICAgKiA8ZGl2IGlneERyYWcgW2RyYWdDaGFubmVsXT1cIidvZGQnXCI+XG4gICAgICogICAgICAgICA8c3Bhbj45NTwvc3Bhbj5cbiAgICAgKiA8L2Rpdj5cbiAgICAgKiA8ZGl2IGlneERyb3AgW2Ryb3BDaGFubmVsXT1cIlsnb2RkJywgJ2lycmF0aW9uYWwnXVwiPlxuICAgICAqICAgICAgICAgPHNwYW4+TnVtYmVycyBkcm9wIGFyZWEhPC9zcGFuPlxuICAgICAqIDwvZGl2PlxuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogQG1lbWJlcm9mIElneERyb3BEaXJlY3RpdmVcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIHB1YmxpYyBkcm9wQ2hhbm5lbDogbnVtYmVyIHwgc3RyaW5nIHwgbnVtYmVyW10gfCBzdHJpbmdbXTtcblxuICAgIC8qKlxuICAgICAqIEFuIEBJbnB1dCBwcm9wZXJ0eSB0aGF0IHNwZWNpZmllcyBhIGRyb3Agc3RyYXRlZ3kgdHlwZSB0aGF0IHdpbGwgYmUgZXhlY3V0ZWQgd2hlbiBhbiBgSWd4RHJhZ2AgZWxlbWVudCBpcyByZWxlYXNlZCBpbnNpZGVcbiAgICAgKiAgdGhlIGN1cnJlbnQgZHJvcCBhcmVhLiBUaGUgcHJvdmlkZWQgc3RyYXRlZ2llcyBhcmU6XG4gICAgICogIC0gSWd4RGVmYXVsdERyb3BTdHJhdGVneSAtIFRoaXMgaXMgdGhlIGRlZmF1bHQgYmFzZSBzdHJhdGVneSBhbmQgaXQgZG9lc24ndCBwZXJmb3JtIGFueSBhY3Rpb25zLlxuICAgICAqICAtIElneEFwcGVuZERyb3BTdHJhdGVneSAtIEFwcGVuZHMgdGhlIGRyb3BwZWQgZWxlbWVudCB0byBsYXN0IHBvc2l0aW9uIGFzIGEgZGlyZWN0IGNoaWxkIHRvIHRoZSBgaWd4RHJvcGAuXG4gICAgICogIC0gSWd4UHJlcGVuZERyb3BTdHJhdGVneSAtIFByZXBlbmRzIHRoZSBkcm9wcGVkIGVsZW1lbnQgdG8gZmlyc3QgcG9zaXRpb24gYXMgYSBkaXJlY3QgY2hpbGQgdG8gdGhlIGBpZ3hEcm9wYC5cbiAgICAgKiAgLSBJZ3hJbnNlcnREcm9wU3RyYXRlZ3kgLSBJZiB0aGUgZHJvcHBlZCBlbGVtZW50IGlzIHJlbGVhc2VkIGFib3ZlIGEgY2hpbGQgZWxlbWVudCBvZiB0aGUgYGlneERyb3BgLCBpdCB3aWxsIGJlIGluc2VydGVkXG4gICAgICogICAgICBhdCB0aGF0IHBvc2l0aW9uLiBPdGhlcndpc2UgdGhlIGRyb3BwZWQgZWxlbWVudCB3aWxsIGJlIGFwcGVuZGVkIGlmIHJlbGVhc2VkIG91dHNpZGUgYW55IGNoaWxkIG9mIHRoZSBgaWd4RHJvcGAuXG4gICAgICogYGBgaHRtbFxuICAgICAqIDxkaXYgaWd4RHJhZz5cbiAgICAgKiAgICAgIDxzcGFuPkRyYWdNZTwvc3Bhbj5cbiAgICAgKiA8L2Rpdj5cbiAgICAgKiA8ZGl2IGlneERyb3AgW2Ryb3BTdHJhdGVneV09XCJteURyb3BTdHJhdGVneVwiPlxuICAgICAqICAgICAgICAgPHNwYW4+TnVtYmVycyBkcm9wIGFyZWEhPC9zcGFuPlxuICAgICAqIDwvZGl2PlxuICAgICAqIGBgYFxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiBpbXBvcnQgeyBJZ3hBcHBlbmREcm9wU3RyYXRlZ3kgfSBmcm9tICdpZ25pdGV1aS1hbmd1bGFyJztcbiAgICAgKlxuICAgICAqIGV4cG9ydCBjbGFzcyBBcHAge1xuICAgICAqICAgICAgcHVibGljIG15RHJvcFN0cmF0ZWd5ID0gSWd4QXBwZW5kRHJvcFN0cmF0ZWd5O1xuICAgICAqIH1cbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBJZ3hEcm9wRGlyZWN0aXZlXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBwdWJsaWMgc2V0IGRyb3BTdHJhdGVneShjbGFzc1JlZjogYW55KSB7XG4gICAgICAgIHRoaXMuX2Ryb3BTdHJhdGVneSA9IG5ldyBjbGFzc1JlZih0aGlzLl9yZW5kZXJlcik7XG4gICAgfVxuXG4gICAgcHVibGljIGdldCBkcm9wU3RyYXRlZ3koKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kcm9wU3RyYXRlZ3k7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRXZlbnQgdHJpZ2dlcmVkIHdoZW4gZHJhZ2dlZCBlbGVtZW50IGVudGVycyB0aGUgYXJlYSBvZiB0aGUgZWxlbWVudC5cbiAgICAgKiBgYGBodG1sXG4gICAgICogPGRpdiBjbGFzcz1cImNhZ2VBcmVhXCIgaWd4RHJvcCAoZW50ZXIpPVwiZHJhZ0VudGVyKClcIiAoaWd4RHJhZ0VudGVyKT1cIm9uRHJhZ0NhZ2VFbnRlcigpXCIgKGlneERyYWdMZWF2ZSk9XCJvbkRyYWdDYWdlTGVhdmUoKVwiPlxuICAgICAqIDwvZGl2PlxuICAgICAqIGBgYFxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiBwdWJsaWMgZHJhZ0VudGVyKCl7XG4gICAgICogICAgIGFsZXJ0KFwiQSBkcmFnZ2FibGUgZWxlbWVudCBoYXMgZW50ZXJlZCB0aGUgY2hpcCBhcmVhIVwiKTtcbiAgICAgKiB9XG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgSWd4RHJvcERpcmVjdGl2ZVxuICAgICAqL1xuICAgIEBPdXRwdXQoKVxuICAgIHB1YmxpYyBlbnRlciA9IG5ldyBFdmVudEVtaXR0ZXI8SURyb3BCYXNlRXZlbnRBcmdzPigpO1xuXG4gICAgLyoqXG4gICAgICogRXZlbnQgdHJpZ2dlcmVkIHdoZW4gZHJhZ2dlZCBlbGVtZW50IGVudGVycyB0aGUgYXJlYSBvZiB0aGUgZWxlbWVudC5cbiAgICAgKiBgYGBodG1sXG4gICAgICogPGRpdiBjbGFzcz1cImNhZ2VBcmVhXCIgaWd4RHJvcCAoZW50ZXIpPVwiZHJhZ0VudGVyKClcIiAoaWd4RHJhZ0VudGVyKT1cIm9uRHJhZ0NhZ2VFbnRlcigpXCIgKGlneERyYWdMZWF2ZSk9XCJvbkRyYWdDYWdlTGVhdmUoKVwiPlxuICAgICAqIDwvZGl2PlxuICAgICAqIGBgYFxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiBwdWJsaWMgZHJhZ0VudGVyKCl7XG4gICAgICogICAgIGFsZXJ0KFwiQSBkcmFnZ2FibGUgZWxlbWVudCBoYXMgZW50ZXJlZCB0aGUgY2hpcCBhcmVhIVwiKTtcbiAgICAgKiB9XG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgSWd4RHJvcERpcmVjdGl2ZVxuICAgICAqL1xuICAgIEBPdXRwdXQoKVxuICAgIHB1YmxpYyBvdmVyID0gbmV3IEV2ZW50RW1pdHRlcjxJRHJvcEJhc2VFdmVudEFyZ3M+KCk7XG5cbiAgICAvKipcbiAgICAgKiBFdmVudCB0cmlnZ2VyZWQgd2hlbiBkcmFnZ2VkIGVsZW1lbnQgbGVhdmVzIHRoZSBhcmVhIG9mIHRoZSBlbGVtZW50LlxuICAgICAqIGBgYGh0bWxcbiAgICAgKiA8ZGl2IGNsYXNzPVwiY2FnZUFyZWFcIiBpZ3hEcm9wIChsZWF2ZSk9XCJkcmFnTGVhdmUoKVwiIChpZ3hEcmFnRW50ZXIpPVwib25EcmFnQ2FnZUVudGVyKClcIiAoaWd4RHJhZ0xlYXZlKT1cIm9uRHJhZ0NhZ2VMZWF2ZSgpXCI+XG4gICAgICogPC9kaXY+XG4gICAgICogYGBgXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIHB1YmxpYyBkcmFnTGVhdmUoKXtcbiAgICAgKiAgICAgYWxlcnQoXCJBIGRyYWdnYWJsZSBlbGVtZW50IGhhcyBsZWZ0IHRoZSBjaGlwIGFyZWEhXCIpO1xuICAgICAqIH1cbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBJZ3hEcm9wRGlyZWN0aXZlXG4gICAgICovXG4gICAgQE91dHB1dCgpXG4gICAgcHVibGljIGxlYXZlID0gbmV3IEV2ZW50RW1pdHRlcjxJRHJvcEJhc2VFdmVudEFyZ3M+KCk7XG5cbiAgICAvKipcbiAgICAgKiBFdmVudCB0cmlnZ2VyZWQgd2hlbiBkcmFnZ2VkIGVsZW1lbnQgaXMgZHJvcHBlZCBpbiB0aGUgYXJlYSBvZiB0aGUgZWxlbWVudC5cbiAgICAgKiBTaW5jZSB0aGUgYGlneERyb3BgIGhhcyBkZWZhdWx0IGxvZ2ljIHRoYXQgYXBwZW5kcyB0aGUgZHJvcHBlZCBlbGVtZW50IGFzIGEgY2hpbGQsIGl0IGNhbiBiZSBjYW5jZWxlZCBoZXJlLlxuICAgICAqIFRvIGNhbmNlbCB0aGUgZGVmYXVsdCBsb2dpYyB0aGUgYGNhbmNlbGAgcHJvcGVydHkgb2YgdGhlIGV2ZW50IG5lZWRzIHRvIGJlIHNldCB0byB0cnVlLlxuICAgICAqIGBgYGh0bWxcbiAgICAgKiA8ZGl2IGNsYXNzPVwiY2FnZUFyZWFcIiBpZ3hEcm9wIChkcm9wcGVkKT1cImRyYWdEcm9wKClcIiAoaWd4RHJhZ0VudGVyKT1cIm9uRHJhZ0NhZ2VFbnRlcigpXCIgKGlneERyYWdMZWF2ZSk9XCJvbkRyYWdDYWdlTGVhdmUoKVwiPlxuICAgICAqIDwvZGl2PlxuICAgICAqIGBgYFxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiBwdWJsaWMgZHJhZ0Ryb3AoKXtcbiAgICAgKiAgICAgYWxlcnQoXCJBIGRyYWdnYWJsZSBlbGVtZW50IGhhcyBiZWVuIGRyb3BwZWQgaW4gdGhlIGNoaXAgYXJlYSFcIik7XG4gICAgICogfVxuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogQG1lbWJlcm9mIElneERyb3BEaXJlY3RpdmVcbiAgICAgKi9cbiAgICBAT3V0cHV0KClcbiAgICBwdWJsaWMgZHJvcHBlZCA9IG5ldyBFdmVudEVtaXR0ZXI8SURyb3BEcm9wcGVkRXZlbnRBcmdzPigpO1xuXG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIEBIb3N0QmluZGluZygnYXR0ci5kcm9wcGFibGUnKVxuICAgIHB1YmxpYyBkcm9wcGFibGUgPSB0cnVlO1xuXG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIEBIb3N0QmluZGluZygnY2xhc3MuZHJhZ092ZXInKVxuICAgIHB1YmxpYyBkcmFnb3ZlciA9IGZhbHNlO1xuXG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIHByb3RlY3RlZCBfZGVzdHJveSA9IG5ldyBTdWJqZWN0PGJvb2xlYW4+KCk7XG4gICAgcHJvdGVjdGVkIF9kcm9wU3RyYXRlZ3k6IElEcm9wU3RyYXRlZ3k7XG5cbiAgICBwcml2YXRlIF9kYXRhOiBhbnk7XG5cbiAgICBjb25zdHJ1Y3RvcihwdWJsaWMgZWxlbWVudDogRWxlbWVudFJlZiwgcHJpdmF0ZSBfcmVuZGVyZXI6IFJlbmRlcmVyMiwgcHJpdmF0ZSBfem9uZTogTmdab25lKSB7XG4gICAgICAgIHRoaXMuX2Ryb3BTdHJhdGVneSA9IG5ldyBJZ3hEZWZhdWx0RHJvcFN0cmF0ZWd5KCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIEBIb3N0TGlzdGVuZXIoJ2lneERyb3AnLCBbJyRldmVudCddKVxuICAgIHB1YmxpYyBvbkRyYWdEcm9wKGV2ZW50KSB7XG4gICAgICAgIGlmICghdGhpcy5pc0RyYWdMaW5rZWQoZXZlbnQuZGV0YWlsLm93bmVyKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgZWxlbWVudFBvc1ggPSB0aGlzLmVsZW1lbnQubmF0aXZlRWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5sZWZ0ICsgdGhpcy5nZXRXaW5kb3dTY3JvbGxMZWZ0KCk7XG4gICAgICAgIGNvbnN0IGVsZW1lbnRQb3NZID0gdGhpcy5lbGVtZW50Lm5hdGl2ZUVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkudG9wICsgdGhpcy5nZXRXaW5kb3dTY3JvbGxUb3AoKTtcbiAgICAgICAgY29uc3Qgb2Zmc2V0WCA9IGV2ZW50LmRldGFpbC5wYWdlWCAtIGVsZW1lbnRQb3NYO1xuICAgICAgICBjb25zdCBvZmZzZXRZID0gZXZlbnQuZGV0YWlsLnBhZ2VZIC0gZWxlbWVudFBvc1k7XG4gICAgICAgIGNvbnN0IGFyZ3M6IElEcm9wRHJvcHBlZEV2ZW50QXJncyA9IHtcbiAgICAgICAgICAgIG93bmVyOiB0aGlzLFxuICAgICAgICAgICAgb3JpZ2luYWxFdmVudDogZXZlbnQuZGV0YWlsLm9yaWdpbmFsRXZlbnQsXG4gICAgICAgICAgICBkcmFnOiBldmVudC5kZXRhaWwub3duZXIsXG4gICAgICAgICAgICBkcmFnRGF0YTogZXZlbnQuZGV0YWlsLm93bmVyLmRhdGEsXG4gICAgICAgICAgICBzdGFydFg6IGV2ZW50LmRldGFpbC5zdGFydFgsXG4gICAgICAgICAgICBzdGFydFk6IGV2ZW50LmRldGFpbC5zdGFydFksXG4gICAgICAgICAgICBwYWdlWDogZXZlbnQuZGV0YWlsLnBhZ2VYLFxuICAgICAgICAgICAgcGFnZVk6IGV2ZW50LmRldGFpbC5wYWdlWSxcbiAgICAgICAgICAgIG9mZnNldFgsXG4gICAgICAgICAgICBvZmZzZXRZLFxuICAgICAgICAgICAgY2FuY2VsOiBmYWxzZVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLl96b25lLnJ1bigoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmRyb3BwZWQuZW1pdChhcmdzKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKHRoaXMuX2Ryb3BTdHJhdGVneSAmJiAhYXJncy5jYW5jZWwpIHtcbiAgICAgICAgICAgIGNvbnN0IGVsZW1lbnRzQXRQb2ludCA9IGV2ZW50LmRldGFpbC5vd25lci5nZXRFbGVtZW50c0F0UG9pbnQoZXZlbnQuZGV0YWlsLnBhZ2VYLCBldmVudC5kZXRhaWwucGFnZVkpO1xuICAgICAgICAgICAgY29uc3QgaW5zZXJ0SW5kZXggPSB0aGlzLmdldEluc2VydEluZGV4QXQoZXZlbnQuZGV0YWlsLm93bmVyLCBlbGVtZW50c0F0UG9pbnQpO1xuICAgICAgICAgICAgdGhpcy5fZHJvcFN0cmF0ZWd5LmRyb3BBY3Rpb24oZXZlbnQuZGV0YWlsLm93bmVyLCB0aGlzLCBpbnNlcnRJbmRleCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgcHVibGljIG5nT25Jbml0KCkge1xuICAgICAgICB0aGlzLl96b25lLnJ1bk91dHNpZGVBbmd1bGFyKCgpID0+IHtcbiAgICAgICAgICAgIGZyb21FdmVudCh0aGlzLmVsZW1lbnQubmF0aXZlRWxlbWVudCwgJ2lneERyYWdFbnRlcicpLnBpcGUodGFrZVVudGlsKHRoaXMuX2Rlc3Ryb3kpKVxuICAgICAgICAgICAgICAgIC5zdWJzY3JpYmUoKHJlcykgPT4gdGhpcy5vbkRyYWdFbnRlcihyZXMgYXMgQ3VzdG9tRXZlbnQ8SWd4RHJhZ0N1c3RvbUV2ZW50RGV0YWlscz4pKTtcblxuICAgICAgICAgICAgZnJvbUV2ZW50KHRoaXMuZWxlbWVudC5uYXRpdmVFbGVtZW50LCAnaWd4RHJhZ0xlYXZlJykucGlwZSh0YWtlVW50aWwodGhpcy5fZGVzdHJveSkpLnN1YnNjcmliZSgocmVzKSA9PiB0aGlzLm9uRHJhZ0xlYXZlKHJlcykpO1xuICAgICAgICAgICAgZnJvbUV2ZW50KHRoaXMuZWxlbWVudC5uYXRpdmVFbGVtZW50LCAnaWd4RHJhZ092ZXInKS5waXBlKHRha2VVbnRpbCh0aGlzLl9kZXN0cm95KSkuc3Vic2NyaWJlKChyZXMpID0+IHRoaXMub25EcmFnT3ZlcihyZXMpKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIHB1YmxpYyBuZ09uRGVzdHJveSgpIHtcbiAgICAgICAgdGhpcy5fZGVzdHJveS5uZXh0KHRydWUpO1xuICAgICAgICB0aGlzLl9kZXN0cm95LmNvbXBsZXRlKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIHB1YmxpYyBvbkRyYWdPdmVyKGV2ZW50KSB7XG4gICAgICAgIGNvbnN0IGVsZW1lbnRQb3NYID0gdGhpcy5lbGVtZW50Lm5hdGl2ZUVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkubGVmdCArIHRoaXMuZ2V0V2luZG93U2Nyb2xsTGVmdCgpO1xuICAgICAgICBjb25zdCBlbGVtZW50UG9zWSA9IHRoaXMuZWxlbWVudC5uYXRpdmVFbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLnRvcCArIHRoaXMuZ2V0V2luZG93U2Nyb2xsVG9wKCk7XG4gICAgICAgIGNvbnN0IG9mZnNldFggPSBldmVudC5kZXRhaWwucGFnZVggLSBlbGVtZW50UG9zWDtcbiAgICAgICAgY29uc3Qgb2Zmc2V0WSA9IGV2ZW50LmRldGFpbC5wYWdlWSAtIGVsZW1lbnRQb3NZO1xuICAgICAgICBjb25zdCBldmVudEFyZ3M6IElEcm9wQmFzZUV2ZW50QXJncyA9IHtcbiAgICAgICAgICAgIG9yaWdpbmFsRXZlbnQ6IGV2ZW50LmRldGFpbC5vcmlnaW5hbEV2ZW50LFxuICAgICAgICAgICAgb3duZXI6IHRoaXMsXG4gICAgICAgICAgICBkcmFnOiBldmVudC5kZXRhaWwub3duZXIsXG4gICAgICAgICAgICBkcmFnRGF0YTogZXZlbnQuZGV0YWlsLm93bmVyLmRhdGEsXG4gICAgICAgICAgICBzdGFydFg6IGV2ZW50LmRldGFpbC5zdGFydFgsXG4gICAgICAgICAgICBzdGFydFk6IGV2ZW50LmRldGFpbC5zdGFydFksXG4gICAgICAgICAgICBwYWdlWDogZXZlbnQuZGV0YWlsLnBhZ2VYLFxuICAgICAgICAgICAgcGFnZVk6IGV2ZW50LmRldGFpbC5wYWdlWSxcbiAgICAgICAgICAgIG9mZnNldFgsXG4gICAgICAgICAgICBvZmZzZXRZXG4gICAgICAgIH07XG5cbiAgICAgICAgdGhpcy5vdmVyLmVtaXQoZXZlbnRBcmdzKTtcbiAgICAgfVxuXG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIHB1YmxpYyBvbkRyYWdFbnRlcihldmVudDogQ3VzdG9tRXZlbnQ8SWd4RHJhZ0N1c3RvbUV2ZW50RGV0YWlscz4pIHtcbiAgICAgICAgaWYgKCF0aGlzLmlzRHJhZ0xpbmtlZChldmVudC5kZXRhaWwub3duZXIpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmRyYWdvdmVyID0gdHJ1ZTtcbiAgICAgICAgY29uc3QgZWxlbWVudFBvc1ggPSB0aGlzLmVsZW1lbnQubmF0aXZlRWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5sZWZ0ICsgdGhpcy5nZXRXaW5kb3dTY3JvbGxMZWZ0KCk7XG4gICAgICAgIGNvbnN0IGVsZW1lbnRQb3NZID0gdGhpcy5lbGVtZW50Lm5hdGl2ZUVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkudG9wICsgdGhpcy5nZXRXaW5kb3dTY3JvbGxUb3AoKTtcbiAgICAgICAgY29uc3Qgb2Zmc2V0WCA9IGV2ZW50LmRldGFpbC5wYWdlWCAtIGVsZW1lbnRQb3NYO1xuICAgICAgICBjb25zdCBvZmZzZXRZID0gZXZlbnQuZGV0YWlsLnBhZ2VZIC0gZWxlbWVudFBvc1k7XG4gICAgICAgIGNvbnN0IGV2ZW50QXJnczogSURyb3BCYXNlRXZlbnRBcmdzID0ge1xuICAgICAgICAgICAgb3JpZ2luYWxFdmVudDogZXZlbnQuZGV0YWlsLm9yaWdpbmFsRXZlbnQsXG4gICAgICAgICAgICBvd25lcjogdGhpcyxcbiAgICAgICAgICAgIGRyYWc6IGV2ZW50LmRldGFpbC5vd25lcixcbiAgICAgICAgICAgIGRyYWdEYXRhOiBldmVudC5kZXRhaWwub3duZXIuZGF0YSxcbiAgICAgICAgICAgIHN0YXJ0WDogZXZlbnQuZGV0YWlsLnN0YXJ0WCxcbiAgICAgICAgICAgIHN0YXJ0WTogZXZlbnQuZGV0YWlsLnN0YXJ0WSxcbiAgICAgICAgICAgIHBhZ2VYOiBldmVudC5kZXRhaWwucGFnZVgsXG4gICAgICAgICAgICBwYWdlWTogZXZlbnQuZGV0YWlsLnBhZ2VZLFxuICAgICAgICAgICAgb2Zmc2V0WCxcbiAgICAgICAgICAgIG9mZnNldFlcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5fem9uZS5ydW4oKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5lbnRlci5lbWl0KGV2ZW50QXJncyk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBwdWJsaWMgb25EcmFnTGVhdmUoZXZlbnQpIHtcbiAgICAgICAgaWYgKCF0aGlzLmlzRHJhZ0xpbmtlZChldmVudC5kZXRhaWwub3duZXIpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmRyYWdvdmVyID0gZmFsc2U7XG4gICAgICAgIGNvbnN0IGVsZW1lbnRQb3NYID0gdGhpcy5lbGVtZW50Lm5hdGl2ZUVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkubGVmdCArIHRoaXMuZ2V0V2luZG93U2Nyb2xsTGVmdCgpO1xuICAgICAgICBjb25zdCBlbGVtZW50UG9zWSA9IHRoaXMuZWxlbWVudC5uYXRpdmVFbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLnRvcCArIHRoaXMuZ2V0V2luZG93U2Nyb2xsVG9wKCk7XG4gICAgICAgIGNvbnN0IG9mZnNldFggPSBldmVudC5kZXRhaWwucGFnZVggLSBlbGVtZW50UG9zWDtcbiAgICAgICAgY29uc3Qgb2Zmc2V0WSA9IGV2ZW50LmRldGFpbC5wYWdlWSAtIGVsZW1lbnRQb3NZO1xuICAgICAgICBjb25zdCBldmVudEFyZ3M6IElEcm9wQmFzZUV2ZW50QXJncyA9IHtcbiAgICAgICAgICAgIG9yaWdpbmFsRXZlbnQ6IGV2ZW50LmRldGFpbC5vcmlnaW5hbEV2ZW50LFxuICAgICAgICAgICAgb3duZXI6IHRoaXMsXG4gICAgICAgICAgICBkcmFnOiBldmVudC5kZXRhaWwub3duZXIsXG4gICAgICAgICAgICBkcmFnRGF0YTogZXZlbnQuZGV0YWlsLm93bmVyLmRhdGEsXG4gICAgICAgICAgICBzdGFydFg6IGV2ZW50LmRldGFpbC5zdGFydFgsXG4gICAgICAgICAgICBzdGFydFk6IGV2ZW50LmRldGFpbC5zdGFydFksXG4gICAgICAgICAgICBwYWdlWDogZXZlbnQuZGV0YWlsLnBhZ2VYLFxuICAgICAgICAgICAgcGFnZVk6IGV2ZW50LmRldGFpbC5wYWdlWSxcbiAgICAgICAgICAgIG9mZnNldFgsXG4gICAgICAgICAgICBvZmZzZXRZXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuX3pvbmUucnVuKCgpID0+IHtcbiAgICAgICAgICAgIHRoaXMubGVhdmUuZW1pdChldmVudEFyZ3MpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBwcm90ZWN0ZWQgZ2V0V2luZG93U2Nyb2xsVG9wKCkge1xuICAgICAgICByZXR1cm4gd2luZG93LnNjcm9sbFkgPyB3aW5kb3cuc2Nyb2xsWSA6ICh3aW5kb3cucGFnZVlPZmZzZXQgPyB3aW5kb3cucGFnZVlPZmZzZXQgOiAwKTtcbiAgICB9XG5cbiAgICBwcm90ZWN0ZWQgZ2V0V2luZG93U2Nyb2xsTGVmdCgpIHtcbiAgICAgICAgcmV0dXJuIHdpbmRvdy5zY3JvbGxYID8gd2luZG93LnNjcm9sbFggOiAod2luZG93LnBhZ2VYT2Zmc2V0ID8gd2luZG93LnBhZ2VYT2Zmc2V0IDogMCk7XG4gICAgfVxuXG4gICAgcHJvdGVjdGVkIGlzRHJhZ0xpbmtlZChkcmFnOiBJZ3hEcmFnRGlyZWN0aXZlKTogYm9vbGVhbiB7XG4gICAgICAgIGNvbnN0IGRyYWdMaW5rQXJyYXkgPSBkcmFnLmRyYWdDaGFubmVsIGluc3RhbmNlb2YgQXJyYXk7XG4gICAgICAgIGNvbnN0IGRyb3BMaW5rQXJyYXkgPSB0aGlzLmRyb3BDaGFubmVsIGluc3RhbmNlb2YgQXJyYXk7XG5cbiAgICAgICAgaWYgKCFkcmFnTGlua0FycmF5ICYmICFkcm9wTGlua0FycmF5KSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5kcm9wQ2hhbm5lbCA9PT0gZHJhZy5kcmFnQ2hhbm5lbDtcbiAgICAgICAgfSBlbHNlIGlmICghZHJhZ0xpbmtBcnJheSAmJiBkcm9wTGlua0FycmF5KSB7XG4gICAgICAgICAgICBjb25zdCBkcm9wTGlua3MgPSB0aGlzLmRyb3BDaGFubmVsIGFzIGFueSBbXTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgbGluayBvZiBkcm9wTGlua3MpIHtcbiAgICAgICAgICAgICAgICBpZiAobGluayA9PT0gZHJhZy5kcmFnQ2hhbm5lbCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoZHJhZ0xpbmtBcnJheSAmJiAhZHJvcExpbmtBcnJheSkge1xuICAgICAgICAgICAgY29uc3QgZHJhZ0xpbmtzID0gZHJhZy5kcmFnQ2hhbm5lbCBhcyBhbnkgW107XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGxpbmsgb2YgZHJhZ0xpbmtzKSB7XG4gICAgICAgICAgICAgICAgaWYgKGxpbmsgPT09IHRoaXMuZHJvcENoYW5uZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgZHJhZ0xpbmtzID0gZHJhZy5kcmFnQ2hhbm5lbCBhcyBhbnkgW107XG4gICAgICAgICAgICBjb25zdCBkcm9wTGlua3MgPSB0aGlzLmRyb3BDaGFubmVsIGFzIGFueSBbXTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgZHJhZ2xpbmsgb2YgZHJhZ0xpbmtzKSB7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBkcm9wbGluayBvZiBkcm9wTGlua3MpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRyYWdsaW5rID09PSBkcm9wbGluaykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgcHJvdGVjdGVkIGdldEluc2VydEluZGV4QXQoZHJhZ2dlZERpcjogSWd4RHJhZ0RpcmVjdGl2ZSwgZWxlbWVudHNBdFBvaW50OiBhbnlbXSk6IG51bWJlciB7XG4gICAgICAgIGxldCBpbnNlcnRJbmRleCA9IC0xO1xuICAgICAgICBjb25zdCBkcm9wQ2hpbGRyZW4gPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbCh0aGlzLmVsZW1lbnQubmF0aXZlRWxlbWVudC5jaGlsZHJlbik7XG4gICAgICAgIGlmICghZHJvcENoaWxkcmVuLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIGluc2VydEluZGV4O1xuICAgICAgICB9XG5cbiAgICAgICAgbGV0IGkgPSAwO1xuICAgICAgICBsZXQgY2hpbGRVbmRlciA9IG51bGw7XG4gICAgICAgIHdoaWxlICghY2hpbGRVbmRlciAmJiBpIDwgZWxlbWVudHNBdFBvaW50Lmxlbmd0aCkge1xuICAgICAgICAgICAgaWYgKGVsZW1lbnRzQXRQb2ludFtpXS5wYXJlbnRFbGVtZW50ID09PSB0aGlzLmVsZW1lbnQubmF0aXZlRWxlbWVudCkge1xuICAgICAgICAgICAgICAgIGNoaWxkVW5kZXIgPSBlbGVtZW50c0F0UG9pbnRbaV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpKys7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBkcmFnZ2VkRWxlbUluZGV4ID0gZHJvcENoaWxkcmVuLmluZGV4T2YoZHJhZ2dlZERpci5lbGVtZW50Lm5hdGl2ZUVsZW1lbnQpO1xuICAgICAgICBpbnNlcnRJbmRleCA9IGRyb3BDaGlsZHJlbi5pbmRleE9mKGNoaWxkVW5kZXIpO1xuICAgICAgICBpZiAoZHJhZ2dlZEVsZW1JbmRleCAhPT0gLTEgJiYgZHJhZ2dlZEVsZW1JbmRleCA8IGluc2VydEluZGV4KSB7XG4gICAgICAgICAgICBpbnNlcnRJbmRleCsrO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGluc2VydEluZGV4O1xuICAgIH1cbn1cblxuXG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuQE5nTW9kdWxlKHtcbiAgICBkZWNsYXJhdGlvbnM6IFtJZ3hEcmFnRGlyZWN0aXZlLCBJZ3hEcm9wRGlyZWN0aXZlLCBJZ3hEcmFnSGFuZGxlRGlyZWN0aXZlLCBJZ3hEcmFnSWdub3JlRGlyZWN0aXZlXSxcbiAgICBleHBvcnRzOiBbSWd4RHJhZ0RpcmVjdGl2ZSwgSWd4RHJvcERpcmVjdGl2ZSwgSWd4RHJhZ0hhbmRsZURpcmVjdGl2ZSwgSWd4RHJhZ0lnbm9yZURpcmVjdGl2ZV1cbn0pXG5leHBvcnQgY2xhc3MgSWd4RHJhZ0Ryb3BNb2R1bGUgeyB9XG4iXX0=