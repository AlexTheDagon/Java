import { ChangeDetectionStrategy, Component, HostBinding, Input, TemplateRef, ContentChild, ViewChild, Inject, Optional, LOCALE_ID } from '@angular/core';
import { IgxTreeGridAPIService } from './tree-grid-api.service';
import { IgxGridBaseDirective } from '../grid-base.directive';
import { TransactionType, TransactionEventOrigin } from '../../services/transaction/transaction';
import { IgxFilteringService } from '../filtering/grid-filtering.service';
import { IgxGridSummaryService } from '../summaries/grid-summary.service';
import { IgxGridSelectionService } from '../selection/selection.service';
import { mergeObjects } from '../../core/utils';
import { first, takeUntil } from 'rxjs/operators';
import { IgxRowLoadingIndicatorTemplateDirective } from './tree-grid.directives';
import { IgxForOfSyncService, IgxForOfScrollSyncService } from '../../directives/for-of/for_of.sync.service';
import { IgxGridNavigationService } from '../grid-navigation.service';
import { IGX_GRID_BASE, IGX_GRID_SERVICE_BASE } from '../common/grid.interface';
import { IgxTreeGridSelectionService } from './tree-grid-selection.service';
import { GridInstanceType, GridSelectionMode } from '../common/enums';
import { IgxSummaryRow, IgxTreeGridRow } from '../grid-public-row';
import { IgxGridCRUDService } from '../common/crud.service';
import { IgxTreeGridGroupByAreaComponent } from '../grouping/tree-grid-group-by-area.component';
import { IgxGridCell } from '../grid-public-cell';
import { DOCUMENT } from '@angular/common';
import { DisplayDensityToken } from '../../core/density';
import { IgxOverlayService } from '../../services/overlay/overlay';
import { IgxGridTransaction } from '../common/types';
import { TreeGridFilteringStrategy } from './tree-grid.filtering.strategy';
import * as i0 from "@angular/core";
import * as i1 from "../selection/selection.service";
import * as i2 from "../resizing/resizing.service";
import * as i3 from "../../services/transaction/transaction-factory.service";
import * as i4 from "../grid-navigation.service";
import * as i5 from "../filtering/grid-filtering.service";
import * as i6 from "../summaries/grid-summary.service";
import * as i7 from "../../core/utils";
import * as i8 from "../headers/grid-header-row.component";
import * as i9 from "./tree-grid-row.component";
import * as i10 from "../summaries/summary-row.component";
import * as i11 from "../../progressbar/progressbar.component";
import * as i12 from "../../snackbar/snackbar.component";
import * as i13 from "../../icon/icon.component";
import * as i14 from "../resizing/resizer.component";
import * as i15 from "../grid.common";
import * as i16 from "../selection/drag-select.directive";
import * as i17 from "@angular/common";
import * as i18 from "../moving/moving.drop.directive";
import * as i19 from "../../directives/for-of/for_of.directive";
import * as i20 from "../../directives/template-outlet/template_outlet.directive";
import * as i21 from "../../directives/toggle/toggle.directive";
import * as i22 from "../../directives/button/button.directive";
import * as i23 from "../../directives/ripple/ripple.directive";
import * as i24 from "../grid.rowEdit.directive";
import * as i25 from "./tree-grid.pipes";
import * as i26 from "./tree-grid.filtering.pipe";
import * as i27 from "../common/pipes";
import * as i28 from "./tree-grid.summary.pipe";
import * as i29 from "../summaries/grid-root-summary.pipe";
import * as i30 from "../../services/overlay/overlay";
let NEXT_ID = 0;
/**
 * **Ignite UI for Angular Tree Grid** -
 * [Documentation](https://www.infragistics.com/products/ignite-ui-angular/angular/components/grid/grid)
 *
 * The Ignite UI Tree Grid displays and manipulates hierarchical data with consistent schema formatted as a table and
 * provides features such as sorting, filtering, editing, column pinning, paging, column moving and hiding.
 *
 * Example:
 * ```html
 * <igx-tree-grid [data]="employeeData" primaryKey="employeeID" foreignKey="PID" [autoGenerate]="false">
 *   <igx-column field="first" header="First Name"></igx-column>
 *   <igx-column field="last" header="Last Name"></igx-column>
 *   <igx-column field="role" header="Role"></igx-column>
 * </igx-tree-grid>
 * ```
 */
export class IgxTreeGridComponent extends IgxGridBaseDirective {
    // Kind of stupid
    // private get _gridAPI(): IgxTreeGridAPIService {
    //     return this.gridAPI as IgxTreeGridAPIService;
    // }
    constructor(selectionService, colResizingService, gridAPI, 
    // public gridAPI: GridBaseAPIService<IgxGridBaseDirective & GridType>,
    transactionFactory, _elementRef, _zone, document, cdr, resolver, differs, viewRef, appRef, moduleRef, injector, navigation, filteringService, overlayService, summaryService, _displayDensityOptions, localeId, platform, _diTransactions) {
        super(selectionService, colResizingService, gridAPI, transactionFactory, _elementRef, _zone, document, cdr, resolver, differs, viewRef, appRef, moduleRef, injector, navigation, filteringService, overlayService, summaryService, _displayDensityOptions, localeId, platform);
        this.selectionService = selectionService;
        this.colResizingService = colResizingService;
        this.gridAPI = gridAPI;
        this.transactionFactory = transactionFactory;
        this.document = document;
        this.cdr = cdr;
        this.resolver = resolver;
        this.differs = differs;
        this.viewRef = viewRef;
        this.navigation = navigation;
        this.filteringService = filteringService;
        this.overlayService = overlayService;
        this.summaryService = summaryService;
        this._displayDensityOptions = _displayDensityOptions;
        this.platform = platform;
        this._diTransactions = _diTransactions;
        /**
         * An @Input property indicating whether child records should be deleted when their parent gets deleted.
         * By default it is set to true and deletes all children along with the parent.
         * ```html
         * <igx-tree-grid [data]="employeeData" [primaryKey]="'employeeID'" [foreignKey]="'parentID'" cascadeOnDelete="false">
         * </igx-tree-grid>
         * ```
         *
         * @memberof IgxTreeGridComponent
         */
        this.cascadeOnDelete = true;
        /**
         * @hidden @internal
         */
        this.role = 'treegrid';
        /**
         * An @Input property that sets the value of the `id` attribute. If not provided it will be automatically generated.
         * ```html
         * <igx-tree-grid [id]="'igx-tree-grid-1'"></igx-tree-grid>
         * ```
         *
         * @memberof IgxTreeGridComponent
         */
        this.id = `igx-tree-grid-${NEXT_ID++}`;
        /**
         * Returns a map of all `ITreeGridRecord`s.
         * ```typescript
         * // gets the record with primaryKey=2
         * const states = this.grid.records.get(2);
         * ```
         *
         * @memberof IgxTreeGridComponent
         */
        this.records = new Map();
        /**
         * Returns a map of all processed (filtered and sorted) `ITreeGridRecord`s.
         * ```typescript
         * // gets the processed record with primaryKey=2
         * const states = this.grid.processedRecords.get(2);
         * ```
         *
         * @memberof IgxTreeGridComponent
         */
        this.processedRecords = new Map();
        /**
         * @hidden
         */
        this.loadingRows = new Set();
        this._filterStrategy = new TreeGridFilteringStrategy();
        this._expansionDepth = Infinity;
        this._filteredData = null;
    }
    /**
     * An @Input property that lets you fill the `IgxTreeGridComponent` with an array of data.
     * ```html
     * <igx-tree-grid [data]="Data" [autoGenerate]="true"></igx-tree-grid>
     * ```
     *
     * @memberof IgxTreeGridComponent
     */
    get data() {
        return this._data;
    }
    set data(value) {
        this._data = value || [];
        this.summaryService.clearSummaryCache();
        if (this.shouldGenerate) {
            this.setupColumns();
        }
        this.cdr.markForCheck();
    }
    /**
     * Returns an array of objects containing the filtered data in the `IgxGridComponent`.
     * ```typescript
     * let filteredData = this.grid.filteredData;
     * ```
     *
     * @memberof IgxTreeGridComponent
     */
    get filteredData() {
        return this._filteredData;
    }
    /**
     * Sets an array of objects containing the filtered data in the `IgxGridComponent`.
     * ```typescript
     * this.grid.filteredData = [{
     *       ID: 1,
     *       Name: "A"
     * }];
     * ```
     *
     * @memberof IgxTreeGridComponent
     */
    set filteredData(value) {
        this._filteredData = value;
    }
    /**
     * Get transactions service for the grid.
     *
     * @experimental @hidden
     */
    get transactions() {
        if (this._diTransactions && !this.batchEditing) {
            return this._diTransactions;
        }
        return this._transactions;
    }
    /**
     * An @Input property that sets the count of levels to be expanded in the `IgxTreeGridComponent`. By default it is
     * set to `Infinity` which means all levels would be expanded.
     * ```html
     * <igx-tree-grid #grid [data]="employeeData" [childDataKey]="'employees'" expansionDepth="1" [autoGenerate]="true"></igx-tree-grid>
     * ```
     *
     * @memberof IgxTreeGridComponent
     */
    get expansionDepth() {
        return this._expansionDepth;
    }
    set expansionDepth(value) {
        this._expansionDepth = value;
        this.notifyChanges();
    }
    /**
     * An @Input property that provides a template for the row loading indicator when load on demand is enabled.
     * ```html
     * <ng-template #rowLoadingTemplate>
     *     <igx-icon>loop</igx-icon>
     * </ng-template>
     *
     * <igx-tree-grid #grid [data]="employeeData" [primaryKey]="'ID'" [foreignKey]="'parentID'"
     *                [loadChildrenOnDemand]="loadChildren"
     *                [rowLoadingIndicatorTemplate]="rowLoadingTemplate">
     * </igx-tree-grid>
     * ```
     *
     * @memberof IgxTreeGridComponent
     */
    get rowLoadingIndicatorTemplate() {
        return this._rowLoadingIndicatorTemplate;
    }
    set rowLoadingIndicatorTemplate(value) {
        this._rowLoadingIndicatorTemplate = value;
        this.notifyChanges();
    }
    /**
     * @deprecated in version 12.1.0. Use `getCellByColumn` or `getCellByKey` instead
     *
     * Returns a `CellType` object that matches the conditions.
     *
     * @example
     * ```typescript
     * const myCell = this.grid1.getCellByColumnVisibleIndex(2,"UnitPrice");
     * ```
     * @param rowIndex
     * @param index
     */
    getCellByColumnVisibleIndex(rowIndex, index) {
        const row = this.getRowByIndex(rowIndex);
        const column = this.columnList.find((col) => col.visibleIndex === index);
        if (row && row instanceof IgxTreeGridRow && column) {
            return new IgxGridCell(this, rowIndex, column.field);
        }
    }
    /**
     * @hidden
     */
    ngOnInit() {
        super.ngOnInit();
        this.rowToggle.pipe(takeUntil(this.destroy$)).subscribe((args) => {
            this.loadChildrenOnRowExpansion(args);
        });
        // TODO: cascade selection logic should be refactor to be handled in the already existing subs
        this.rowAddedNotifier.pipe(takeUntil(this.destroy$)).subscribe(args => {
            if (this.rowSelection === GridSelectionMode.multipleCascade) {
                let rec = this.gridAPI.get_rec_by_id(this.primaryKey ? args.data[this.primaryKey] : args.data);
                if (rec && rec.parent) {
                    this.gridAPI.grid.selectionService.updateCascadeSelectionOnFilterAndCRUD(new Set([rec.parent]), rec.parent.key);
                }
                else {
                    // The record is still not available
                    // Wait for the change detection to update records through pipes
                    requestAnimationFrame(() => {
                        rec = this.gridAPI.get_rec_by_id(this.primaryKey ?
                            args.data[this.primaryKey] : args.data);
                        if (rec && rec.parent) {
                            this.gridAPI.grid.selectionService.updateCascadeSelectionOnFilterAndCRUD(new Set([rec.parent]), rec.parent.key);
                        }
                        this.notifyChanges();
                    });
                }
            }
        });
        this.rowDeletedNotifier.pipe(takeUntil(this.destroy$)).subscribe(args => {
            if (this.rowSelection === GridSelectionMode.multipleCascade) {
                if (args.data) {
                    const rec = this.gridAPI.get_rec_by_id(this.primaryKey ? args.data[this.primaryKey] : args.data);
                    this.handleCascadeSelection(args, rec);
                }
                else {
                    // if a row has been added and before commiting the transaction deleted
                    const leafRowsDirectParents = new Set();
                    this.records.forEach(record => {
                        if (record && (!record.children || record.children.length === 0) && record.parent) {
                            leafRowsDirectParents.add(record.parent);
                        }
                    });
                    // Wait for the change detection to update records through pipes
                    requestAnimationFrame(() => {
                        this.gridAPI.grid.selectionService.updateCascadeSelectionOnFilterAndCRUD(leafRowsDirectParents);
                        this.notifyChanges();
                    });
                }
            }
        });
        this.filteringDone.pipe(takeUntil(this.destroy$)).subscribe(() => {
            if (this.rowSelection === GridSelectionMode.multipleCascade) {
                const leafRowsDirectParents = new Set();
                this.records.forEach(record => {
                    if (record && (!record.children || record.children.length === 0) && record.parent) {
                        leafRowsDirectParents.add(record.parent);
                    }
                });
                this.gridAPI.grid.selectionService.updateCascadeSelectionOnFilterAndCRUD(leafRowsDirectParents);
                this.notifyChanges();
            }
        });
    }
    ngDoCheck() {
        super.ngDoCheck();
    }
    /**
     * @hidden
     */
    ngAfterViewInit() {
        super.ngAfterViewInit();
        // TODO: pipesExectured event
        // run after change detection in super triggers pipes for records structure
        if (this.rowSelection === GridSelectionMode.multipleCascade && this.selectedRows.length) {
            const selRows = this.selectedRows;
            this.selectionService.clearRowSelection();
            this.selectRows(selRows, true);
            this.cdr.detectChanges();
        }
    }
    /**
     * @hidden
     */
    ngAfterContentInit() {
        if (this.rowLoadingTemplate) {
            this._rowLoadingIndicatorTemplate = this.rowLoadingTemplate.template;
        }
        super.ngAfterContentInit();
    }
    getDefaultExpandState(record) {
        return record.children && record.children.length && record.level < this.expansionDepth;
    }
    /**
     * Expands all rows.
     * ```typescript
     * this.grid.expandAll();
     * ```
     *
     * @memberof IgxTreeGridComponent
     */
    expandAll() {
        this._expansionDepth = Infinity;
        this.expansionStates = new Map();
    }
    /**
     * Collapses all rows.
     *
     * ```typescript
     * this.grid.collapseAll();
     *  ```
     *
     * @memberof IgxTreeGridComponent
     */
    collapseAll() {
        this._expansionDepth = 0;
        this.expansionStates = new Map();
    }
    /**
     * @hidden
     */
    refreshGridState(args) {
        super.refreshGridState();
        if (this.primaryKey && this.foreignKey && args) {
            const rowID = args.data[this.foreignKey];
            this.summaryService.clearSummaryCache({ rowID });
            this.pipeTrigger++;
            this.cdr.detectChanges();
        }
    }
    /**
     * Creates a new `IgxTreeGridRowComponent` with the given data. If a parentRowID is not specified, the newly created
     * row would be added at the root level. Otherwise, it would be added as a child of the row whose primaryKey matches
     * the specified parentRowID. If the parentRowID does not exist, an error would be thrown.
     * ```typescript
     * const record = {
     *     ID: this.grid.data[this.grid1.data.length - 1].ID + 1,
     *     Name: this.newRecord
     * };
     * this.grid.addRow(record, 1); // Adds a new child row to the row with ID=1.
     * ```
     *
     * @param data
     * @param parentRowID
     * @memberof IgxTreeGridComponent
     */
    // TODO: remove evt emission
    addRow(data, parentRowID) {
        this.crudService.endEdit(true);
        this.gridAPI.addRowToData(data, parentRowID);
        this.rowAddedNotifier.next({ data });
        this.pipeTrigger++;
        this.notifyChanges();
    }
    /**
     * Enters add mode by spawning the UI with the context of the specified row by index.
     *
     * @remarks
     * Accepted values for index are integers from 0 to this.grid.dataView.length
     * @remarks
     * When adding the row as a child, the parent row is the specified row.
     * @remarks
     * To spawn the UI on top, call the function with index = null or a negative number.
     * In this case trying to add this row as a child will result in error.
     * @example
     * ```typescript
     * this.grid.beginAddRowByIndex(10);
     * this.grid.beginAddRowByIndex(10, true);
     * this.grid.beginAddRowByIndex(null);
     * ```
     * @param index - The index to spawn the UI at. Accepts integers from 0 to this.grid.dataView.length
     * @param asChild - Whether the record should be added as a child. Only applicable to igxTreeGrid.
     */
    beginAddRowByIndex(index, asChild) {
        if (index === null || index < 0) {
            return this.beginAddRowById(null, asChild);
        }
        return this._addRowForIndex(index - 1, asChild);
    }
    /**
     * @hidden
     */
    getContext(rowData, rowIndex, pinned) {
        return {
            $implicit: this.isGhostRecord(rowData) ? rowData.recordRef : rowData,
            index: this.getDataViewIndex(rowIndex, pinned),
            templateID: {
                type: this.isSummaryRow(rowData) ? 'summaryRow' : 'dataRow',
                id: null
            },
            disabled: this.isGhostRecord(rowData) ? rowData.recordRef.isFilteredOutParent === undefined : false
        };
    }
    /**
     * @hidden
     * @internal
     */
    getInitialPinnedIndex(rec) {
        const id = this.gridAPI.get_row_id(rec);
        return this._pinnedRecordIDs.indexOf(id);
    }
    /**
     * @hidden
     * @internal
     */
    isRecordPinned(rec) {
        return this.getInitialPinnedIndex(rec.data) !== -1;
    }
    /**
     * @inheritdoc
     */
    getSelectedData(formatters = false, headers = false) {
        let source = [];
        const process = (record) => {
            if (record.summaries) {
                source.push(null);
                return;
            }
            source.push(record.data);
        };
        this.unpinnedDataView.forEach(process);
        source = this.isRowPinningToTop ? [...this.pinnedDataView, ...source] : [...source, ...this.pinnedDataView];
        return this.extractDataFromSelection(source, formatters, headers);
    }
    /**
     * @hidden @internal
     */
    getEmptyRecordObjectFor(inTreeRow) {
        const treeRowRec = inTreeRow?.treeRow || null;
        const row = { ...treeRowRec };
        const data = treeRowRec?.data || {};
        row.data = { ...data };
        Object.keys(row.data).forEach(key => {
            // persist foreign key if one is set.
            if (this.foreignKey && key === this.foreignKey) {
                row.data[key] = treeRowRec.data[key];
            }
            else {
                row.data[key] = undefined;
            }
        });
        let id = this.generateRowID();
        const rootRecPK = this.foreignKey && this.rootRecords && this.rootRecords.length > 0 ?
            this.rootRecords[0].data[this.foreignKey] : null;
        if (id === rootRecPK) {
            // safeguard in case generated id matches the root foreign key.
            id = this.generateRowID();
        }
        row.key = id;
        row.data[this.primaryKey] = id;
        return { rowID: id, data: row.data, recordRef: row };
    }
    /** @hidden */
    deleteRowById(rowId) {
        //  if this is flat self-referencing data, and CascadeOnDelete is set to true
        //  and if we have transactions we should start pending transaction. This allows
        //  us in case of delete action to delete all child rows as single undo action
        return this.gridAPI.deleteRowById(rowId);
    }
    /**
     * Returns the `IgxTreeGridRow` by index.
     *
     * @example
     * ```typescript
     * const myRow = treeGrid.getRowByIndex(1);
     * ```
     * @param index
     */
    getRowByIndex(index) {
        if (index < 0 || index >= this.dataView.length) {
            return undefined;
        }
        return this.createRow(index);
    }
    /**
     * Returns the `RowType` object by the specified primary key.
     *
     * @example
     * ```typescript
     * const myRow = this.treeGrid.getRowByIndex(1);
     * ```
     * @param index
     */
    getRowByKey(key) {
        const rec = this.filteredSortedData ? this.primaryKey ? this.filteredSortedData.find(r => r[this.primaryKey] === key) :
            this.filteredSortedData.find(r => r === key) : undefined;
        const index = this.dataView.findIndex(r => r.data && r.data === rec);
        if (index < 0 || index >= this.filteredSortedData.length) {
            return undefined;
        }
        return new IgxTreeGridRow(this, index, rec);
    }
    /**
     * Returns the collection of all RowType for current page.
     *
     * @hidden @internal
     */
    allRows() {
        return this.dataView.map((rec, index) => this.createRow(index));
    }
    /**
     * Returns the collection of `IgxTreeGridRow`s for current page.
     *
     * @hidden @internal
     */
    dataRows() {
        return this.allRows().filter(row => row instanceof IgxTreeGridRow);
    }
    /**
     * Returns an array of the selected `IgxGridCell`s.
     *
     * @example
     * ```typescript
     * const selectedCells = this.grid.selectedCells;
     * ```
     */
    get selectedCells() {
        return this.dataRows().map((row) => row.cells.filter((cell) => cell.selected))
            .reduce((a, b) => a.concat(b), []);
    }
    /**
     * Returns a `CellType` object that matches the conditions.
     *
     * @example
     * ```typescript
     * const myCell = this.grid1.getCellByColumn(2, "UnitPrice");
     * ```
     * @param rowIndex
     * @param columnField
     */
    getCellByColumn(rowIndex, columnField) {
        const row = this.getRowByIndex(rowIndex);
        const column = this.columnList.find((col) => col.field === columnField);
        if (row && row instanceof IgxTreeGridRow && column) {
            return new IgxGridCell(this, rowIndex, columnField);
        }
    }
    /**
     * Returns a `CellType` object that matches the conditions.
     *
     * @remarks
     * Requires that the primaryKey property is set.
     * @example
     * ```typescript
     * grid.getCellByKey(1, 'index');
     * ```
     * @param rowSelector match any rowID
     * @param columnField
     */
    getCellByKey(rowSelector, columnField) {
        const row = this.getRowByKey(rowSelector);
        const column = this.columnList.find((col) => col.field === columnField);
        if (row && column) {
            return new IgxGridCell(this, row.index, columnField);
        }
    }
    pinRow(rowID, index) {
        const row = this.getRowByKey(rowID);
        return super.pinRow(rowID, index, row);
    }
    unpinRow(rowID) {
        const row = this.getRowByKey(rowID);
        return super.unpinRow(rowID, row);
    }
    /** @hidden */
    generateRowPath(rowId) {
        const path = [];
        let record = this.records.get(rowId);
        while (record.parent) {
            path.push(record.parent.key);
            record = record.parent;
        }
        return path.reverse();
    }
    /** @hidden */
    isTreeRow(record) {
        return record.key !== undefined && record.data;
    }
    /** @hidden */
    getUnpinnedIndexById(id) {
        return this.unpinnedRecords.findIndex(x => x.data[this.primaryKey] === id);
    }
    /**
     * @hidden
     */
    createRow(index, data) {
        let row;
        const dataIndex = this._getDataViewIndex(index);
        const rec = data ?? this.dataView[dataIndex];
        if (this.isSummaryRow(rec)) {
            row = new IgxSummaryRow(this, index, rec.summaries, GridInstanceType.TreeGrid);
        }
        if (!row && rec) {
            const isTreeRow = this.isTreeRow(rec);
            const dataRec = isTreeRow ? rec.data : rec;
            const treeRow = isTreeRow ? rec : undefined;
            row = new IgxTreeGridRow(this, index, dataRec, treeRow);
        }
        return row;
    }
    /**
     * Returns if the `IgxTreeGridComponent` has groupable columns.
     *
     * @example
     * ```typescript
     * const groupableGrid = this.grid.hasGroupableColumns;
     * ```
     */
    get hasGroupableColumns() {
        return this.columnList.some((col) => col.groupable && !col.columnGroup);
    }
    generateDataFields(data) {
        return super.generateDataFields(data).filter(field => field !== this.childDataKey);
    }
    transactionStatusUpdate(event) {
        let actions = [];
        if (event.origin === TransactionEventOrigin.REDO) {
            actions = event.actions ? event.actions.filter(x => x.transaction.type === TransactionType.DELETE) : [];
            if (this.rowSelection === GridSelectionMode.multipleCascade) {
                this.handleCascadeSelection(event);
            }
        }
        else if (event.origin === TransactionEventOrigin.UNDO) {
            actions = event.actions ? event.actions.filter(x => x.transaction.type === TransactionType.ADD) : [];
            if (this.rowSelection === GridSelectionMode.multipleCascade) {
                if (event.actions[0].transaction.type === 'add') {
                    const rec = this.gridAPI.get_rec_by_id(event.actions[0].transaction.id);
                    this.handleCascadeSelection(event, rec);
                }
                else {
                    this.handleCascadeSelection(event);
                }
            }
        }
        if (actions.length) {
            for (const action of actions) {
                this.deselectChildren(action.transaction.id);
            }
        }
        super.transactionStatusUpdate(event);
    }
    ;
    findRecordIndexInView(rec) {
        return this.dataView.findIndex(x => x.data[this.primaryKey] === rec[this.primaryKey]);
    }
    /**
     * @hidden @internal
     */
    getDataBasedBodyHeight() {
        return !this.flatData || (this.flatData.length < this._defaultTargetRecordNumber) ?
            0 : this.defaultTargetBodyHeight;
    }
    /**
     * @hidden
     */
    scrollTo(row, column) {
        let delayScrolling = false;
        let record;
        if (typeof (row) !== 'number') {
            const rowData = row;
            const rowID = this.gridAPI.get_row_id(rowData);
            record = this.processedRecords.get(rowID);
            this.gridAPI.expand_path_to_record(record);
            if (this.paginator) {
                const rowIndex = this.processedExpandedFlatData.indexOf(rowData);
                const page = Math.floor(rowIndex / this.paginator.perPage);
                if (this.paginator.page !== page) {
                    delayScrolling = true;
                    this.paginator.page = page;
                }
            }
        }
        if (delayScrolling) {
            this.verticalScrollContainer.dataChanged.pipe(first()).subscribe(() => {
                this.scrollDirective(this.verticalScrollContainer, typeof (row) === 'number' ? row : this.unpinnedDataView.indexOf(record));
            });
        }
        else {
            this.scrollDirective(this.verticalScrollContainer, typeof (row) === 'number' ? row : this.unpinnedDataView.indexOf(record));
        }
        this.scrollToHorizontally(column);
    }
    writeToData(rowIndex, value) {
        mergeObjects(this.flatData[rowIndex], value);
    }
    /**
     * @hidden
     */
    initColumns(collection, cb = null) {
        if (this.hasColumnLayouts) {
            // invalid configuration - tree grid should not allow column layouts
            // remove column layouts
            const nonColumnLayoutColumns = this.columnList.filter((col) => !col.columnLayout && !col.columnLayoutChild);
            this.columnList.reset(nonColumnLayoutColumns);
        }
        super.initColumns(collection, cb);
    }
    /**
     * @hidden @internal
     */
    getGroupAreaHeight() {
        return this.treeGroupArea ? this.getComputedHeight(this.treeGroupArea.nativeElement) : 0;
    }
    /**
     * @description A recursive way to deselect all selected children of a given record
     * @param recordID ID of the record whose children to deselect
     * @hidden
     * @internal
     */
    deselectChildren(recordID) {
        const selectedChildren = [];
        // G.E. Apr 28, 2021 #9465 Records which are not in view can also be selected so we need to
        // deselect them as well, hence using 'records' map instead of getRowByKey() method which will
        // return only row components (i.e. records in view).
        const rowToDeselect = this.records.get(recordID);
        this.selectionService.deselectRow(recordID);
        this.gridAPI.get_selected_children(rowToDeselect, selectedChildren);
        if (selectedChildren.length > 0) {
            selectedChildren.forEach(x => this.deselectChildren(x));
        }
    }
    addChildRows(children, parentID) {
        if (this.primaryKey && this.foreignKey) {
            for (const child of children) {
                child[this.foreignKey] = parentID;
            }
            this.data.push(...children);
        }
        else if (this.childDataKey) {
            let parent = this.records.get(parentID);
            let parentData = parent.data;
            if (this.transactions.enabled && this.transactions.getAggregatedChanges(true).length) {
                const path = [];
                while (parent) {
                    path.push(parent.key);
                    parent = parent.parent;
                }
                let collection = this.data;
                let record;
                for (let i = path.length - 1; i >= 0; i--) {
                    const pid = path[i];
                    record = collection.find(r => r[this.primaryKey] === pid);
                    if (!record) {
                        break;
                    }
                    collection = record[this.childDataKey];
                }
                if (record) {
                    parentData = record;
                }
            }
            parentData[this.childDataKey] = children;
        }
        this.selectionService.clearHeaderCBState();
        this.pipeTrigger++;
        if (this.rowSelection === GridSelectionMode.multipleCascade) {
            // Force pipe triggering for building the data structure
            this.cdr.detectChanges();
            if (this.selectionService.isRowSelected(parentID)) {
                this.selectionService.rowSelection.delete(parentID);
                this.selectionService.selectRowsWithNoEvent([parentID]);
            }
        }
    }
    loadChildrenOnRowExpansion(args) {
        if (this.loadChildrenOnDemand) {
            const parentID = args.rowID;
            if (args.expanded && !this._expansionStates.has(parentID)) {
                this.loadingRows.add(parentID);
                this.loadChildrenOnDemand(parentID, children => {
                    this.loadingRows.delete(parentID);
                    this.addChildRows(children, parentID);
                    this.notifyChanges();
                });
            }
        }
    }
    handleCascadeSelection(event, rec = null) {
        // Wait for the change detection to update records through the pipes
        requestAnimationFrame(() => {
            if (rec === null) {
                rec = this.gridAPI.get_rec_by_id(event.actions[0].transaction.id);
            }
            if (rec && rec.parent) {
                this.gridAPI.grid.selectionService.updateCascadeSelectionOnFilterAndCRUD(new Set([rec.parent]), rec.parent.key);
                this.notifyChanges();
            }
        });
    }
}
IgxTreeGridComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.2.2", ngImport: i0, type: IgxTreeGridComponent, deps: [{ token: i1.IgxGridSelectionService }, { token: i2.IgxColumnResizingService }, { token: IGX_GRID_SERVICE_BASE }, { token: i3.IgxHierarchicalTransactionFactory }, { token: i0.ElementRef }, { token: i0.NgZone }, { token: DOCUMENT }, { token: i0.ChangeDetectorRef }, { token: i0.ComponentFactoryResolver }, { token: i0.IterableDiffers }, { token: i0.ViewContainerRef }, { token: i0.ApplicationRef }, { token: i0.NgModuleRef }, { token: i0.Injector }, { token: i4.IgxGridNavigationService }, { token: i5.IgxFilteringService }, { token: IgxOverlayService }, { token: i6.IgxGridSummaryService }, { token: DisplayDensityToken, optional: true }, { token: LOCALE_ID }, { token: i7.PlatformUtil }, { token: IgxGridTransaction, optional: true }], target: i0.ɵɵFactoryTarget.Component });
IgxTreeGridComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "13.2.2", type: IgxTreeGridComponent, selector: "igx-tree-grid", inputs: { childDataKey: "childDataKey", foreignKey: "foreignKey", hasChildrenKey: "hasChildrenKey", cascadeOnDelete: "cascadeOnDelete", loadChildrenOnDemand: "loadChildrenOnDemand", id: "id", data: "data", expansionDepth: "expansionDepth", rowLoadingIndicatorTemplate: "rowLoadingIndicatorTemplate" }, host: { properties: { "attr.role": "this.role", "attr.id": "this.id" } }, providers: [
        IgxGridCRUDService,
        IgxGridSummaryService,
        IgxGridNavigationService,
        { provide: IgxGridSelectionService, useClass: IgxTreeGridSelectionService },
        { provide: IGX_GRID_SERVICE_BASE, useClass: IgxTreeGridAPIService },
        { provide: IGX_GRID_BASE, useExisting: IgxTreeGridComponent },
        IgxFilteringService,
        IgxForOfSyncService,
        IgxForOfScrollSyncService
    ], queries: [{ propertyName: "treeGroupArea", first: true, predicate: IgxTreeGridGroupByAreaComponent, descendants: true, read: IgxTreeGridGroupByAreaComponent }, { propertyName: "rowLoadingTemplate", first: true, predicate: IgxRowLoadingIndicatorTemplateDirective, descendants: true, read: IgxRowLoadingIndicatorTemplateDirective }], viewQueries: [{ propertyName: "dragIndicatorIconBase", first: true, predicate: ["dragIndicatorIconBase"], descendants: true, read: TemplateRef, static: true }, { propertyName: "recordTemplate", first: true, predicate: ["record_template"], descendants: true, read: TemplateRef, static: true }, { propertyName: "summaryTemplate", first: true, predicate: ["summary_template"], descendants: true, read: TemplateRef, static: true }], usesInheritance: true, ngImport: i0, template: "<ng-content select=\"igx-grid-toolbar\"></ng-content>\n<ng-content select=\"igx-tree-grid-group-by-area\"></ng-content>\n<igx-grid-header-row class=\"igx-grid-thead\" tabindex=\"0\"\n    [grid]=\"this\"\n    [hasMRL]=\"hasColumnLayouts\"\n    [activeDescendant]=\"activeDescendant\"\n    [width]=\"calcWidth\"\n    [pinnedColumnCollection]=\"pinnedColumns\"\n    [unpinnedColumnCollection]=\"unpinnedColumns\"\n    (keydown.meta.c)=\"copyHandler($event)\"\n    (keydown.control.c)=\"copyHandler($event)\"\n    (copy)=\"copyHandler($event)\"\n    (keydown)=\"navigation.headerNavigation($event)\"\n    (focus)=\"navigation.focusFirstCell()\"\n>\n</igx-grid-header-row>\n\n<div igxGridBody (keydown.control.c)=\"copyHandler($event)\" (copy)=\"copyHandler($event)\" class=\"igx-grid__tbody\" role=\"rowgroup\">\n    <div class=\"igx-grid__tbody-content\"  tabindex=\"0\" (focus)=\"navigation.focusTbody($event)\" (keydown)=\"navigation.handleNavigation($event)\"\n    (dragStop)=\"selectionService.dragMode = $event\" [attr.aria-activedescendant]=\"activeDescendant\" [attr.role]=\"dataView.length ? null : 'row'\"\n        (dragScroll)=\"dragScroll($event)\" [igxGridDragSelect]=\"selectionService.dragMode\"\n        [style.height.px]='totalHeight' [style.width.px]='calcWidth' #tbody (scroll)='preventContainerScroll($event)'>\n        <span *ngIf=\"moving && columnInDrag && pinnedColumns.length <= 0\"\n            [igxColumnMovingDrop]=\"headerContainer\" [attr.droppable]=\"true\" id=\"left\"\n            class=\"igx-grid__scroll-on-drag-left\"></span>\n        <span *ngIf=\"moving && columnInDrag && pinnedColumns.length > 0\"\n            [igxColumnMovingDrop]=\"headerContainer\" [attr.droppable]=\"true\" id=\"left\"\n            class=\"igx-grid__scroll-on-drag-pinned\" [style.left.px]=\"pinnedWidth\"></span>\n        <ng-template #pinnedRecordsTemplate>\n            <ng-container *ngIf='data\n            | treeGridTransaction:pipeTrigger\n            | visibleColumns:hasVisibleColumns\n            | treeGridNormalizeRecord:pipeTrigger\n            | treeGridAddRow:true:pipeTrigger\n            | gridRowPinning:id:true:pipeTrigger\n            | treeGridFiltering:filteringExpressionsTree:filterStrategy:advancedFilteringExpressionsTree:pipeTrigger:filteringPipeTrigger:true\n            | treeGridSorting:sortingExpressions:treeGroupArea?.expressions:sortStrategy:pipeTrigger:true as pinnedData'>\n                <div #pinContainer *ngIf='pinnedData.length > 0'\n                    [ngClass]=\"{\n                        'igx-grid__tr--pinned-bottom':  !isRowPinningToTop,\n                        'igx-grid__tr--pinned-top': isRowPinningToTop\n                    }\"\n                    class='igx-grid__tr--pinned' [style.width.px]='calcWidth'>\n                    <ng-container *ngFor=\"let rowData of pinnedData;let rowIndex = index;\">\n                        <ng-container *ngTemplateOutlet=\"pinned_record_template; context: getContext(rowData, rowIndex, true)\">\n                        </ng-container>\n                    </ng-container>\n                </div>\n            </ng-container>\n        </ng-template>\n        <ng-container *ngTemplateOutlet=\"hasPinnedRecords && isRowPinningToTop ? pinnedRecordsTemplate : null\"></ng-container>\n        <ng-template igxGridFor let-rowData [igxGridForOf]=\"data\n        | treeGridTransaction:pipeTrigger\n        | visibleColumns:hasVisibleColumns\n        | treeGridHierarchizing:primaryKey:foreignKey:childDataKey:pipeTrigger\n        | treeGridFiltering:filteringExpressionsTree:filterStrategy:advancedFilteringExpressionsTree:pipeTrigger:filteringPipeTrigger\n        | treeGridSorting:sortingExpressions:treeGroupArea?.expressions:sortStrategy:pipeTrigger\n        | treeGridFlattening:expansionDepth:expansionStates:pipeTrigger\n        | treeGridPaging:paginator?.page:paginator?.perPage:pipeTrigger\n        | treeGridSummary:hasSummarizedColumns:summaryCalculationMode:summaryPosition:showSummaryOnCollapse:pipeTrigger:summaryPipeTrigger\n        | treeGridAddRow:false:pipeTrigger\n        | gridRowPinning:id:false:pipeTrigger\"\n            let-rowIndex=\"index\" [igxForScrollOrientation]=\"'vertical'\" [igxForScrollContainer]='verticalScroll'\n            [igxForContainerSize]='calcHeight' [igxForItemSize]=\"renderedRowHeight\" #verticalScrollContainer\n            (dataChanging)=\"dataRebinding($event)\" (dataChanged)=\"dataRebound($event)\">\n            <ng-template [igxTemplateOutlet]='isSummaryRow(rowData) ? summary_template : record_template'\n                [igxTemplateOutletContext]='getContext(rowData, rowIndex, false)'\n                (cachedViewLoaded)='cachedViewLoaded($event)'>\n            </ng-template>\n        </ng-template>\n        <ng-container *ngTemplateOutlet=\"hasPinnedRecords && !isRowPinningToTop ? pinnedRecordsTemplate : null\"></ng-container>\n        <ng-template #record_template let-rowIndex=\"index\" let-disabledRow=\"disabled\" let-rowData>\n            <igx-tree-grid-row [gridID]=\"id\" [index]=\"rowIndex\" [treeRow]=\"rowData\" [disabled]=\"disabledRow\"\n                [ngClass]=\"rowClasses | igxGridRowClasses:row:row.inEditMode:row.selected:row.dirty:row.deleted:row.dragging:rowIndex:hasColumnLayouts:row.treeRow.isFilteredOutParent:rowData:pipeTrigger\"\n                [ngStyle]=\"rowStyles | igxGridRowStyles:rowData:rowIndex:pipeTrigger\" #row>\n            </igx-tree-grid-row>\n        </ng-template>\n        <ng-template #pinned_record_template let-rowIndex=\"index\" let-rowData>\n            <igx-tree-grid-row [gridID]=\"id\" [index]=\"rowIndex\" [treeRow]=\"rowData\"\n                [ngClass]=\"rowClasses | igxGridRowClasses:row:row.inEditMode:row.selected:row.dirty:row.deleted:row.dragging:rowIndex:hasColumnLayouts:row.treeRow.isFilteredOutParent:rowData:pipeTrigger\"\n                [ngStyle]=\"rowStyles | igxGridRowStyles:rowData:rowIndex:pipeTrigger\"#row #pinnedRow>\n            </igx-tree-grid-row>\n        </ng-template>\n        <ng-template #summary_template let-rowIndex=\"index\" let-rowData>\n            <igx-grid-summary-row [gridID]=\"id\" [summaries]=\"rowData.summaries\"\n                [firstCellIndentation]=\"rowData.cellIndentation\" [index]=\"rowIndex\"\n                class=\"igx-grid__summaries--body\" role=\"row\" #summaryRow>\n            </igx-grid-summary-row>\n        </ng-template>\n        <ng-container *ngTemplateOutlet=\"template\"></ng-container>\n        <div class=\"igx-grid__row-editing-outlet\" igxOverlayOutlet #igxRowEditingOverlayOutlet></div>\n        <igc-trial-watermark></igc-trial-watermark>\n    </div>\n    <div igxToggle #loadingOverlay>\n        <igx-circular-bar [indeterminate]=\"true\" *ngIf='shouldOverlayLoading'>\n        </igx-circular-bar>\n    </div>\n    <span *ngIf=\"moving && columnInDrag\" [igxColumnMovingDrop]=\"headerContainer\" [attr.droppable]=\"true\"\n        id=\"right\" class=\"igx-grid__scroll-on-drag-right\"></span>\n        <div [hidden]='!hasVerticalScroll()' class=\"igx-grid__tbody-scrollbar\" [style.width.px]=\"scrollSize\"  (pointerdown)=\"$event.preventDefault()\"\n            [style.height.px]='calcHeight'>\n        <div class=\"igx-grid__tbody-scrollbar-start\" [style.height.px]=' isRowPinningToTop ? pinnedRowHeight : 0'></div>\n        <div class=\"igx-grid__tbody-scrollbar-main\" [style.height.px]='calcHeight'>\n            <ng-template igxGridFor [igxGridForOf]='[]' #verticalScrollHolder></ng-template>\n        </div>\n        <div class=\"igx-grid__tbody-scrollbar-end\" [style.height.px]='!isRowPinningToTop ? pinnedRowHeight : 0'></div>\n    </div>\n    <div class=\"igx-grid__addrow-snackbar\">\n        <igx-snackbar #addRowSnackbar [outlet]=\"igxBodyOverlayOutlet\" [actionText]=\"resourceStrings.igx_grid_snackbar_addrow_actiontext\" [displayTime]='snackbarDisplayTime'>{{resourceStrings.igx_grid_snackbar_addrow_label}}</igx-snackbar>\n    </div>\n\n    <div igxOverlayOutlet #igxBodyOverlayOutlet=\"overlay-outlet\"></div>\n</div>\n\n<div class=\"igx-grid__tfoot\" role=\"rowgroup\" [style.height.px]='summaryRowHeight' #tfoot>\n    <div tabindex=\"0\" (focus)=\"navigation.focusFirstCell(false)\"\n    (keydown)=\"navigation.summaryNav($event)\" [attr.aria-activedescendant]=\"activeDescendant\">\n        <igx-grid-summary-row [style.width.px]='calcWidth' [style.height.px]='summaryRowHeight'\n            *ngIf=\"hasSummarizedColumns && rootSummariesEnabled\" [gridID]=\"id\" role=\"row\"\n            [summaries]=\"id | igxGridSummaryDataPipe:summaryService.retriggerRootPipe\" [index]=\"dataView.length\"\n            class=\"igx-grid__summaries\" #summaryRow>\n        </igx-grid-summary-row>\n        <div class=\"igx-grid__tfoot-thumb\" [hidden]='!hasVerticalScroll()' [style.height.px]='summaryRowHeight'\n            [style.width.px]=\"scrollSize\"></div>\n    </div>\n</div>\n\n<div class=\"igx-grid__scroll\" [style.height.px]=\"scrollSize\" #scr [hidden]=\"isHorizontalScrollHidden\" (pointerdown)=\"$event.preventDefault()\">\n    <div class=\"igx-grid__scroll-start\" [style.width.px]='isPinningToStart ? pinnedWidth : headerFeaturesWidth' [style.min-width.px]='isPinningToStart ? pinnedWidth : headerFeaturesWidth'></div>\n    <div class=\"igx-grid__scroll-main\" [style.width.px]='unpinnedWidth'>\n        <ng-template igxGridFor [igxGridForOf]='[]' #scrollContainer>\n        </ng-template>\n    </div>\n    <div class=\"igx-grid__scroll-end\" [style.float]='\"right\"' [style.width.px]='pinnedWidth' [style.min-width.px]='pinnedWidth' [hidden]=\"pinnedWidth === 0 || isPinningToStart\"></div>\n</div>\n\n<div class=\"igx-grid__footer\" #footer>\n    <ng-content select=\"igx-grid-footer\"></ng-content>\n    <ng-container *ngIf=\"totalRecords || pagingMode === 1\">\n        <ng-content select=\"igx-paginator\"></ng-content>\n    </ng-container>\n</div>\n\n<ng-template #emptyFilteredGrid>\n    <span class=\"igx-grid__tbody-message\" role=\"cell\">\n        <span>{{emptyFilteredGridMessage}}</span>\n        <span *ngIf='showAddButton'>\n            <ng-container *ngTemplateOutlet='addRowEmptyTemplate || defaultAddRowEmptyTemplate'></ng-container>\n        </span>\n    </span>\n</ng-template>\n\n<ng-template #defaultEmptyGrid>\n    <span class=\"igx-grid__tbody-message\" role=\"cell\">\n        <span>{{emptyGridMessage}}</span>\n        <span *ngIf='showAddButton'>\n            <ng-container *ngTemplateOutlet='addRowEmptyTemplate || defaultAddRowEmptyTemplate'></ng-container>\n        </span>\n    </span>\n</ng-template>\n\n<ng-template #defaultAddRowEmptyTemplate>\n    <button igxButton=\"raised\" igxRipple (click)=\"this.crudService.enterAddRowMode(null, false, $event)\">\n        {{resourceStrings.igx_grid_add_row_label}}\n    </button>\n</ng-template>\n\n<ng-template #defaultLoadingGrid>\n    <div class=\"igx-grid__loading\">\n        <igx-circular-bar [indeterminate]=\"true\">\n        </igx-circular-bar>\n    </div>\n</ng-template>\n\n<div *ngIf=\"rowEditable\" igxToggle #rowEditingOverlay>\n    <div [className]=\"bannerClass\">\n        <ng-container\n            *ngTemplateOutlet=\"rowEditContainer; context: { rowChangesCount: rowChangesCount, endEdit: this.crudService.endEdit.bind(this) }\">\n        </ng-container>\n    </div>\n</div>\n\n<ng-template #defaultRowEditText>\n    You have {{ rowChangesCount }} changes in this row\n</ng-template>\n\n<ng-template #defaultRowEditActions>\n    <button igxButton igxRowEditTabStop (click)=\"this.endRowEditTabStop(false, $event)\">{{ this.resourceStrings.igx_grid_row_edit_btn_cancel }}</button>\n    <button igxButton igxRowEditTabStop (click)=\"this.endRowEditTabStop(true, $event)\">{{ this.resourceStrings.igx_grid_row_edit_btn_done }}</button>\n</ng-template>\n\n<ng-template #defaultRowEditTemplate>\n    <div class=\"igx-banner__message\">\n        <span class=\"igx-banner__text\">\n            <ng-container\n                *ngTemplateOutlet=\"this.crudService.row?.getClassName() === 'IgxAddRow' ? rowAddText : rowEditText ? rowEditText : defaultRowEditText;\n                context: { $implicit: this.crudService.row?.getClassName() !== 'IgxAddRow' ? rowChangesCount : null }\">\n            </ng-container>\n        </span>\n    </div>\n    <div class=\"igx-banner__actions\">\n        <div class=\"igx-banner__row\">\n            <ng-container\n                *ngTemplateOutlet=\"rowEditActions ? rowEditActions : defaultRowEditActions; context: { $implicit: this.endEdit.bind(this) }\">\n            </ng-container>\n        </div>\n    </div>\n</ng-template>\n\n<ng-template #dragIndicatorIconBase>\n    <igx-icon>drag_indicator</igx-icon>\n</ng-template>\n\n<igx-grid-column-resizer *ngIf=\"colResizingService.showResizer\"></igx-grid-column-resizer>\n<div class=\"igx-grid__loading-outlet\" #igxLoadingOverlayOutlet igxOverlayOutlet></div>\n<div class=\"igx-grid__outlet\" #igxFilteringOverlayOutlet igxOverlayOutlet></div>\n", components: [{ type: i8.IgxGridHeaderRowComponent, selector: "igx-grid-header-row", inputs: ["grid", "pinnedColumnCollection", "unpinnedColumnCollection", "activeDescendant", "hasMRL", "width", "density"] }, { type: i9.IgxTreeGridRowComponent, selector: "igx-tree-grid-row", inputs: ["treeRow"] }, { type: i10.IgxSummaryRowComponent, selector: "igx-grid-summary-row", inputs: ["summaries", "gridID", "index", "firstCellIndentation"] }, { type: i11.IgxCircularProgressBarComponent, selector: "igx-circular-bar", inputs: ["id", "isIndeterminate", "textVisibility", "text"] }, { type: i12.IgxSnackbarComponent, selector: "igx-snackbar", inputs: ["id", "actionText", "positionSettings"], outputs: ["clicked", "animationStarted", "animationDone"] }, { type: i13.IgxIconComponent, selector: "igx-icon", inputs: ["family", "active", "name"] }, { type: i14.IgxGridColumnResizerComponent, selector: "igx-grid-column-resizer", inputs: ["restrictResizerTop"] }], directives: [{ type: i15.IgxGridBodyDirective, selector: "[igxGridBody]" }, { type: i16.IgxGridDragSelectDirective, selector: "[igxGridDragSelect]", inputs: ["igxGridDragSelect"], outputs: ["dragStop", "dragScroll"] }, { type: i17.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { type: i18.IgxColumnMovingDropDirective, selector: "[igxColumnMovingDrop]", inputs: ["igxColumnMovingDrop"] }, { type: i17.NgClass, selector: "[ngClass]", inputs: ["class", "ngClass"] }, { type: i17.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }, { type: i17.NgTemplateOutlet, selector: "[ngTemplateOutlet]", inputs: ["ngTemplateOutletContext", "ngTemplateOutlet"] }, { type: i19.IgxGridForOfDirective, selector: "[igxGridFor][igxGridForOf]", inputs: ["igxGridForOf", "igxGridForOfUniqueSizeCache", "igxGridForOfVariableSizes"], outputs: ["dataChanging"] }, { type: i20.IgxTemplateOutletDirective, selector: "[igxTemplateOutlet]", inputs: ["igxTemplateOutletContext", "igxTemplateOutlet"], outputs: ["viewCreated", "viewMoved", "cachedViewLoaded", "beforeViewDetach"] }, { type: i17.NgStyle, selector: "[ngStyle]", inputs: ["ngStyle"] }, { type: i21.IgxOverlayOutletDirective, selector: "[igxOverlayOutlet]", exportAs: ["overlay-outlet"] }, { type: i21.IgxToggleDirective, selector: "[igxToggle]", inputs: ["id"], outputs: ["opened", "opening", "closed", "closing", "appended"], exportAs: ["toggle"] }, { type: i22.IgxButtonDirective, selector: "[igxButton]", inputs: ["selected", "igxButton", "igxButtonColor", "igxButtonBackground", "igxLabel", "disabled"], outputs: ["buttonClick", "buttonSelected"] }, { type: i23.IgxRippleDirective, selector: "[igxRipple]", inputs: ["igxRippleTarget", "igxRipple", "igxRippleDuration", "igxRippleCentered", "igxRippleDisabled"] }, { type: i24.IgxRowEditTabStopDirective, selector: "[igxRowEditTabStop]" }], pipes: { "treeGridSorting": i25.IgxTreeGridSortingPipe, "treeGridFiltering": i26.IgxTreeGridFilteringPipe, "gridRowPinning": i27.IgxGridRowPinningPipe, "treeGridAddRow": i25.IgxTreeGridAddRowPipe, "treeGridNormalizeRecord": i25.IgxTreeGridNormalizeRecordsPipe, "visibleColumns": i27.IgxHasVisibleColumnsPipe, "treeGridTransaction": i25.IgxTreeGridTransactionPipe, "treeGridSummary": i28.IgxTreeGridSummaryPipe, "treeGridPaging": i25.IgxTreeGridPagingPipe, "treeGridFlattening": i25.IgxTreeGridFlatteningPipe, "treeGridHierarchizing": i25.IgxTreeGridHierarchizingPipe, "igxGridRowClasses": i27.IgxGridRowClassesPipe, "igxGridRowStyles": i27.IgxGridRowStylesPipe, "igxGridSummaryDataPipe": i29.IgxSummaryDataPipe }, changeDetection: i0.ChangeDetectionStrategy.OnPush });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.2.2", ngImport: i0, type: IgxTreeGridComponent, decorators: [{
            type: Component,
            args: [{ changeDetection: ChangeDetectionStrategy.OnPush, selector: 'igx-tree-grid', providers: [
                        IgxGridCRUDService,
                        IgxGridSummaryService,
                        IgxGridNavigationService,
                        { provide: IgxGridSelectionService, useClass: IgxTreeGridSelectionService },
                        { provide: IGX_GRID_SERVICE_BASE, useClass: IgxTreeGridAPIService },
                        { provide: IGX_GRID_BASE, useExisting: IgxTreeGridComponent },
                        IgxFilteringService,
                        IgxForOfSyncService,
                        IgxForOfScrollSyncService
                    ], template: "<ng-content select=\"igx-grid-toolbar\"></ng-content>\n<ng-content select=\"igx-tree-grid-group-by-area\"></ng-content>\n<igx-grid-header-row class=\"igx-grid-thead\" tabindex=\"0\"\n    [grid]=\"this\"\n    [hasMRL]=\"hasColumnLayouts\"\n    [activeDescendant]=\"activeDescendant\"\n    [width]=\"calcWidth\"\n    [pinnedColumnCollection]=\"pinnedColumns\"\n    [unpinnedColumnCollection]=\"unpinnedColumns\"\n    (keydown.meta.c)=\"copyHandler($event)\"\n    (keydown.control.c)=\"copyHandler($event)\"\n    (copy)=\"copyHandler($event)\"\n    (keydown)=\"navigation.headerNavigation($event)\"\n    (focus)=\"navigation.focusFirstCell()\"\n>\n</igx-grid-header-row>\n\n<div igxGridBody (keydown.control.c)=\"copyHandler($event)\" (copy)=\"copyHandler($event)\" class=\"igx-grid__tbody\" role=\"rowgroup\">\n    <div class=\"igx-grid__tbody-content\"  tabindex=\"0\" (focus)=\"navigation.focusTbody($event)\" (keydown)=\"navigation.handleNavigation($event)\"\n    (dragStop)=\"selectionService.dragMode = $event\" [attr.aria-activedescendant]=\"activeDescendant\" [attr.role]=\"dataView.length ? null : 'row'\"\n        (dragScroll)=\"dragScroll($event)\" [igxGridDragSelect]=\"selectionService.dragMode\"\n        [style.height.px]='totalHeight' [style.width.px]='calcWidth' #tbody (scroll)='preventContainerScroll($event)'>\n        <span *ngIf=\"moving && columnInDrag && pinnedColumns.length <= 0\"\n            [igxColumnMovingDrop]=\"headerContainer\" [attr.droppable]=\"true\" id=\"left\"\n            class=\"igx-grid__scroll-on-drag-left\"></span>\n        <span *ngIf=\"moving && columnInDrag && pinnedColumns.length > 0\"\n            [igxColumnMovingDrop]=\"headerContainer\" [attr.droppable]=\"true\" id=\"left\"\n            class=\"igx-grid__scroll-on-drag-pinned\" [style.left.px]=\"pinnedWidth\"></span>\n        <ng-template #pinnedRecordsTemplate>\n            <ng-container *ngIf='data\n            | treeGridTransaction:pipeTrigger\n            | visibleColumns:hasVisibleColumns\n            | treeGridNormalizeRecord:pipeTrigger\n            | treeGridAddRow:true:pipeTrigger\n            | gridRowPinning:id:true:pipeTrigger\n            | treeGridFiltering:filteringExpressionsTree:filterStrategy:advancedFilteringExpressionsTree:pipeTrigger:filteringPipeTrigger:true\n            | treeGridSorting:sortingExpressions:treeGroupArea?.expressions:sortStrategy:pipeTrigger:true as pinnedData'>\n                <div #pinContainer *ngIf='pinnedData.length > 0'\n                    [ngClass]=\"{\n                        'igx-grid__tr--pinned-bottom':  !isRowPinningToTop,\n                        'igx-grid__tr--pinned-top': isRowPinningToTop\n                    }\"\n                    class='igx-grid__tr--pinned' [style.width.px]='calcWidth'>\n                    <ng-container *ngFor=\"let rowData of pinnedData;let rowIndex = index;\">\n                        <ng-container *ngTemplateOutlet=\"pinned_record_template; context: getContext(rowData, rowIndex, true)\">\n                        </ng-container>\n                    </ng-container>\n                </div>\n            </ng-container>\n        </ng-template>\n        <ng-container *ngTemplateOutlet=\"hasPinnedRecords && isRowPinningToTop ? pinnedRecordsTemplate : null\"></ng-container>\n        <ng-template igxGridFor let-rowData [igxGridForOf]=\"data\n        | treeGridTransaction:pipeTrigger\n        | visibleColumns:hasVisibleColumns\n        | treeGridHierarchizing:primaryKey:foreignKey:childDataKey:pipeTrigger\n        | treeGridFiltering:filteringExpressionsTree:filterStrategy:advancedFilteringExpressionsTree:pipeTrigger:filteringPipeTrigger\n        | treeGridSorting:sortingExpressions:treeGroupArea?.expressions:sortStrategy:pipeTrigger\n        | treeGridFlattening:expansionDepth:expansionStates:pipeTrigger\n        | treeGridPaging:paginator?.page:paginator?.perPage:pipeTrigger\n        | treeGridSummary:hasSummarizedColumns:summaryCalculationMode:summaryPosition:showSummaryOnCollapse:pipeTrigger:summaryPipeTrigger\n        | treeGridAddRow:false:pipeTrigger\n        | gridRowPinning:id:false:pipeTrigger\"\n            let-rowIndex=\"index\" [igxForScrollOrientation]=\"'vertical'\" [igxForScrollContainer]='verticalScroll'\n            [igxForContainerSize]='calcHeight' [igxForItemSize]=\"renderedRowHeight\" #verticalScrollContainer\n            (dataChanging)=\"dataRebinding($event)\" (dataChanged)=\"dataRebound($event)\">\n            <ng-template [igxTemplateOutlet]='isSummaryRow(rowData) ? summary_template : record_template'\n                [igxTemplateOutletContext]='getContext(rowData, rowIndex, false)'\n                (cachedViewLoaded)='cachedViewLoaded($event)'>\n            </ng-template>\n        </ng-template>\n        <ng-container *ngTemplateOutlet=\"hasPinnedRecords && !isRowPinningToTop ? pinnedRecordsTemplate : null\"></ng-container>\n        <ng-template #record_template let-rowIndex=\"index\" let-disabledRow=\"disabled\" let-rowData>\n            <igx-tree-grid-row [gridID]=\"id\" [index]=\"rowIndex\" [treeRow]=\"rowData\" [disabled]=\"disabledRow\"\n                [ngClass]=\"rowClasses | igxGridRowClasses:row:row.inEditMode:row.selected:row.dirty:row.deleted:row.dragging:rowIndex:hasColumnLayouts:row.treeRow.isFilteredOutParent:rowData:pipeTrigger\"\n                [ngStyle]=\"rowStyles | igxGridRowStyles:rowData:rowIndex:pipeTrigger\" #row>\n            </igx-tree-grid-row>\n        </ng-template>\n        <ng-template #pinned_record_template let-rowIndex=\"index\" let-rowData>\n            <igx-tree-grid-row [gridID]=\"id\" [index]=\"rowIndex\" [treeRow]=\"rowData\"\n                [ngClass]=\"rowClasses | igxGridRowClasses:row:row.inEditMode:row.selected:row.dirty:row.deleted:row.dragging:rowIndex:hasColumnLayouts:row.treeRow.isFilteredOutParent:rowData:pipeTrigger\"\n                [ngStyle]=\"rowStyles | igxGridRowStyles:rowData:rowIndex:pipeTrigger\"#row #pinnedRow>\n            </igx-tree-grid-row>\n        </ng-template>\n        <ng-template #summary_template let-rowIndex=\"index\" let-rowData>\n            <igx-grid-summary-row [gridID]=\"id\" [summaries]=\"rowData.summaries\"\n                [firstCellIndentation]=\"rowData.cellIndentation\" [index]=\"rowIndex\"\n                class=\"igx-grid__summaries--body\" role=\"row\" #summaryRow>\n            </igx-grid-summary-row>\n        </ng-template>\n        <ng-container *ngTemplateOutlet=\"template\"></ng-container>\n        <div class=\"igx-grid__row-editing-outlet\" igxOverlayOutlet #igxRowEditingOverlayOutlet></div>\n        <igc-trial-watermark></igc-trial-watermark>\n    </div>\n    <div igxToggle #loadingOverlay>\n        <igx-circular-bar [indeterminate]=\"true\" *ngIf='shouldOverlayLoading'>\n        </igx-circular-bar>\n    </div>\n    <span *ngIf=\"moving && columnInDrag\" [igxColumnMovingDrop]=\"headerContainer\" [attr.droppable]=\"true\"\n        id=\"right\" class=\"igx-grid__scroll-on-drag-right\"></span>\n        <div [hidden]='!hasVerticalScroll()' class=\"igx-grid__tbody-scrollbar\" [style.width.px]=\"scrollSize\"  (pointerdown)=\"$event.preventDefault()\"\n            [style.height.px]='calcHeight'>\n        <div class=\"igx-grid__tbody-scrollbar-start\" [style.height.px]=' isRowPinningToTop ? pinnedRowHeight : 0'></div>\n        <div class=\"igx-grid__tbody-scrollbar-main\" [style.height.px]='calcHeight'>\n            <ng-template igxGridFor [igxGridForOf]='[]' #verticalScrollHolder></ng-template>\n        </div>\n        <div class=\"igx-grid__tbody-scrollbar-end\" [style.height.px]='!isRowPinningToTop ? pinnedRowHeight : 0'></div>\n    </div>\n    <div class=\"igx-grid__addrow-snackbar\">\n        <igx-snackbar #addRowSnackbar [outlet]=\"igxBodyOverlayOutlet\" [actionText]=\"resourceStrings.igx_grid_snackbar_addrow_actiontext\" [displayTime]='snackbarDisplayTime'>{{resourceStrings.igx_grid_snackbar_addrow_label}}</igx-snackbar>\n    </div>\n\n    <div igxOverlayOutlet #igxBodyOverlayOutlet=\"overlay-outlet\"></div>\n</div>\n\n<div class=\"igx-grid__tfoot\" role=\"rowgroup\" [style.height.px]='summaryRowHeight' #tfoot>\n    <div tabindex=\"0\" (focus)=\"navigation.focusFirstCell(false)\"\n    (keydown)=\"navigation.summaryNav($event)\" [attr.aria-activedescendant]=\"activeDescendant\">\n        <igx-grid-summary-row [style.width.px]='calcWidth' [style.height.px]='summaryRowHeight'\n            *ngIf=\"hasSummarizedColumns && rootSummariesEnabled\" [gridID]=\"id\" role=\"row\"\n            [summaries]=\"id | igxGridSummaryDataPipe:summaryService.retriggerRootPipe\" [index]=\"dataView.length\"\n            class=\"igx-grid__summaries\" #summaryRow>\n        </igx-grid-summary-row>\n        <div class=\"igx-grid__tfoot-thumb\" [hidden]='!hasVerticalScroll()' [style.height.px]='summaryRowHeight'\n            [style.width.px]=\"scrollSize\"></div>\n    </div>\n</div>\n\n<div class=\"igx-grid__scroll\" [style.height.px]=\"scrollSize\" #scr [hidden]=\"isHorizontalScrollHidden\" (pointerdown)=\"$event.preventDefault()\">\n    <div class=\"igx-grid__scroll-start\" [style.width.px]='isPinningToStart ? pinnedWidth : headerFeaturesWidth' [style.min-width.px]='isPinningToStart ? pinnedWidth : headerFeaturesWidth'></div>\n    <div class=\"igx-grid__scroll-main\" [style.width.px]='unpinnedWidth'>\n        <ng-template igxGridFor [igxGridForOf]='[]' #scrollContainer>\n        </ng-template>\n    </div>\n    <div class=\"igx-grid__scroll-end\" [style.float]='\"right\"' [style.width.px]='pinnedWidth' [style.min-width.px]='pinnedWidth' [hidden]=\"pinnedWidth === 0 || isPinningToStart\"></div>\n</div>\n\n<div class=\"igx-grid__footer\" #footer>\n    <ng-content select=\"igx-grid-footer\"></ng-content>\n    <ng-container *ngIf=\"totalRecords || pagingMode === 1\">\n        <ng-content select=\"igx-paginator\"></ng-content>\n    </ng-container>\n</div>\n\n<ng-template #emptyFilteredGrid>\n    <span class=\"igx-grid__tbody-message\" role=\"cell\">\n        <span>{{emptyFilteredGridMessage}}</span>\n        <span *ngIf='showAddButton'>\n            <ng-container *ngTemplateOutlet='addRowEmptyTemplate || defaultAddRowEmptyTemplate'></ng-container>\n        </span>\n    </span>\n</ng-template>\n\n<ng-template #defaultEmptyGrid>\n    <span class=\"igx-grid__tbody-message\" role=\"cell\">\n        <span>{{emptyGridMessage}}</span>\n        <span *ngIf='showAddButton'>\n            <ng-container *ngTemplateOutlet='addRowEmptyTemplate || defaultAddRowEmptyTemplate'></ng-container>\n        </span>\n    </span>\n</ng-template>\n\n<ng-template #defaultAddRowEmptyTemplate>\n    <button igxButton=\"raised\" igxRipple (click)=\"this.crudService.enterAddRowMode(null, false, $event)\">\n        {{resourceStrings.igx_grid_add_row_label}}\n    </button>\n</ng-template>\n\n<ng-template #defaultLoadingGrid>\n    <div class=\"igx-grid__loading\">\n        <igx-circular-bar [indeterminate]=\"true\">\n        </igx-circular-bar>\n    </div>\n</ng-template>\n\n<div *ngIf=\"rowEditable\" igxToggle #rowEditingOverlay>\n    <div [className]=\"bannerClass\">\n        <ng-container\n            *ngTemplateOutlet=\"rowEditContainer; context: { rowChangesCount: rowChangesCount, endEdit: this.crudService.endEdit.bind(this) }\">\n        </ng-container>\n    </div>\n</div>\n\n<ng-template #defaultRowEditText>\n    You have {{ rowChangesCount }} changes in this row\n</ng-template>\n\n<ng-template #defaultRowEditActions>\n    <button igxButton igxRowEditTabStop (click)=\"this.endRowEditTabStop(false, $event)\">{{ this.resourceStrings.igx_grid_row_edit_btn_cancel }}</button>\n    <button igxButton igxRowEditTabStop (click)=\"this.endRowEditTabStop(true, $event)\">{{ this.resourceStrings.igx_grid_row_edit_btn_done }}</button>\n</ng-template>\n\n<ng-template #defaultRowEditTemplate>\n    <div class=\"igx-banner__message\">\n        <span class=\"igx-banner__text\">\n            <ng-container\n                *ngTemplateOutlet=\"this.crudService.row?.getClassName() === 'IgxAddRow' ? rowAddText : rowEditText ? rowEditText : defaultRowEditText;\n                context: { $implicit: this.crudService.row?.getClassName() !== 'IgxAddRow' ? rowChangesCount : null }\">\n            </ng-container>\n        </span>\n    </div>\n    <div class=\"igx-banner__actions\">\n        <div class=\"igx-banner__row\">\n            <ng-container\n                *ngTemplateOutlet=\"rowEditActions ? rowEditActions : defaultRowEditActions; context: { $implicit: this.endEdit.bind(this) }\">\n            </ng-container>\n        </div>\n    </div>\n</ng-template>\n\n<ng-template #dragIndicatorIconBase>\n    <igx-icon>drag_indicator</igx-icon>\n</ng-template>\n\n<igx-grid-column-resizer *ngIf=\"colResizingService.showResizer\"></igx-grid-column-resizer>\n<div class=\"igx-grid__loading-outlet\" #igxLoadingOverlayOutlet igxOverlayOutlet></div>\n<div class=\"igx-grid__outlet\" #igxFilteringOverlayOutlet igxOverlayOutlet></div>\n" }]
        }], ctorParameters: function () { return [{ type: i1.IgxGridSelectionService }, { type: i2.IgxColumnResizingService }, { type: undefined, decorators: [{
                    type: Inject,
                    args: [IGX_GRID_SERVICE_BASE]
                }] }, { type: i3.IgxHierarchicalTransactionFactory }, { type: i0.ElementRef }, { type: i0.NgZone }, { type: undefined, decorators: [{
                    type: Inject,
                    args: [DOCUMENT]
                }] }, { type: i0.ChangeDetectorRef }, { type: i0.ComponentFactoryResolver }, { type: i0.IterableDiffers }, { type: i0.ViewContainerRef }, { type: i0.ApplicationRef }, { type: i0.NgModuleRef }, { type: i0.Injector }, { type: i4.IgxGridNavigationService }, { type: i5.IgxFilteringService }, { type: i30.IgxOverlayService, decorators: [{
                    type: Inject,
                    args: [IgxOverlayService]
                }] }, { type: i6.IgxGridSummaryService }, { type: undefined, decorators: [{
                    type: Optional
                }, {
                    type: Inject,
                    args: [DisplayDensityToken]
                }] }, { type: undefined, decorators: [{
                    type: Inject,
                    args: [LOCALE_ID]
                }] }, { type: i7.PlatformUtil }, { type: undefined, decorators: [{
                    type: Optional
                }, {
                    type: Inject,
                    args: [IgxGridTransaction]
                }] }]; }, propDecorators: { childDataKey: [{
                type: Input
            }], foreignKey: [{
                type: Input
            }], hasChildrenKey: [{
                type: Input
            }], cascadeOnDelete: [{
                type: Input
            }], loadChildrenOnDemand: [{
                type: Input
            }], role: [{
                type: HostBinding,
                args: ['attr.role']
            }], id: [{
                type: HostBinding,
                args: ['attr.id']
            }, {
                type: Input
            }], treeGroupArea: [{
                type: ContentChild,
                args: [IgxTreeGridGroupByAreaComponent, { read: IgxTreeGridGroupByAreaComponent }]
            }], dragIndicatorIconBase: [{
                type: ViewChild,
                args: ['dragIndicatorIconBase', { read: TemplateRef, static: true }]
            }], recordTemplate: [{
                type: ViewChild,
                args: ['record_template', { read: TemplateRef, static: true }]
            }], summaryTemplate: [{
                type: ViewChild,
                args: ['summary_template', { read: TemplateRef, static: true }]
            }], rowLoadingTemplate: [{
                type: ContentChild,
                args: [IgxRowLoadingIndicatorTemplateDirective, { read: IgxRowLoadingIndicatorTemplateDirective }]
            }], data: [{
                type: Input
            }], expansionDepth: [{
                type: Input
            }], rowLoadingIndicatorTemplate: [{
                type: Input
            }] } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidHJlZS1ncmlkLmNvbXBvbmVudC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uLy4uL3Byb2plY3RzL2lnbml0ZXVpLWFuZ3VsYXIvc3JjL2xpYi9ncmlkcy90cmVlLWdyaWQvdHJlZS1ncmlkLmNvbXBvbmVudC50cyIsIi4uLy4uLy4uLy4uLy4uLy4uL3Byb2plY3RzL2lnbml0ZXVpLWFuZ3VsYXIvc3JjL2xpYi9ncmlkcy90cmVlLWdyaWQvdHJlZS1ncmlkLmNvbXBvbmVudC5odG1sIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLE9BQU8sRUFDSCx1QkFBdUIsRUFDdkIsU0FBUyxFQUNULFdBQVcsRUFDWCxLQUFLLEVBRUwsV0FBVyxFQUVYLFlBQVksRUFFWixTQUFTLEVBS1QsTUFBTSxFQUtOLFFBQVEsRUFDUixTQUFTLEVBSVosTUFBTSxlQUFlLENBQUM7QUFDdkIsT0FBTyxFQUFFLHFCQUFxQixFQUFFLE1BQU0seUJBQXlCLENBQUM7QUFDaEUsT0FBTyxFQUFFLG9CQUFvQixFQUFFLE1BQU0sd0JBQXdCLENBQUM7QUFHOUQsT0FBTyxFQUdILGVBQWUsRUFDZixzQkFBc0IsRUFFekIsTUFBTSx3Q0FBd0MsQ0FBQztBQUNoRCxPQUFPLEVBQUUsbUJBQW1CLEVBQUUsTUFBTSxxQ0FBcUMsQ0FBQztBQUMxRSxPQUFPLEVBQUUscUJBQXFCLEVBQUUsTUFBTSxtQ0FBbUMsQ0FBQztBQUMxRSxPQUFPLEVBQUUsdUJBQXVCLEVBQUUsTUFBTSxnQ0FBZ0MsQ0FBQztBQUN6RSxPQUFPLEVBQUUsWUFBWSxFQUFnQixNQUFNLGtCQUFrQixDQUFDO0FBQzlELE9BQU8sRUFBRSxLQUFLLEVBQUUsU0FBUyxFQUFFLE1BQU0sZ0JBQWdCLENBQUM7QUFDbEQsT0FBTyxFQUFFLHVDQUF1QyxFQUFFLE1BQU0sd0JBQXdCLENBQUM7QUFDakYsT0FBTyxFQUFFLG1CQUFtQixFQUFFLHlCQUF5QixFQUFFLE1BQU0sNkNBQTZDLENBQUM7QUFD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RUFBRSxJQUFJLEVBQUUsdUNBQXVDLEVBQUU7Z0JBOEU3RixJQUFJO3NCQURkLEtBQUs7Z0JBK0RLLGNBQWM7c0JBRHhCLEtBQUs7Z0JBMEJLLDJCQUEyQjtzQkFEckMsS0FBSyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7XG4gICAgQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3ksXG4gICAgQ29tcG9uZW50LFxuICAgIEhvc3RCaW5kaW5nLFxuICAgIElucHV0LFxuICAgIE9uSW5pdCxcbiAgICBUZW1wbGF0ZVJlZixcbiAgICBRdWVyeUxpc3QsXG4gICAgQ29udGVudENoaWxkLFxuICAgIEFmdGVyQ29udGVudEluaXQsXG4gICAgVmlld0NoaWxkLFxuICAgIERvQ2hlY2ssXG4gICAgQWZ0ZXJWaWV3SW5pdCxcbiAgICBFbGVtZW50UmVmLFxuICAgIE5nWm9uZSxcbiAgICBJbmplY3QsXG4gICAgQ2hhbmdlRGV0ZWN0b3JSZWYsXG4gICAgQ29tcG9uZW50RmFjdG9yeVJlc29sdmVyLFxuICAgIEl0ZXJhYmxlRGlmZmVycyxcbiAgICBWaWV3Q29udGFpbmVyUmVmLFxuICAgIE9wdGlvbmFsLFxuICAgIExPQ0FMRV9JRCxcbiAgICBBcHBsaWNhdGlvblJlZixcbiAgICBOZ01vZHVsZVJlZixcbiAgICBJbmplY3RvclxufSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IElneFRyZWVHcmlkQVBJU2VydmljZSB9IGZyb20gJy4vdHJlZS1ncmlkLWFwaS5zZXJ2aWNlJztcbmltcG9ydCB7IElneEdyaWRCYXNlRGlyZWN0aXZlIH0gZnJvbSAnLi4vZ3JpZC1iYXNlLmRpcmVjdGl2ZSc7XG5pbXBvcnQgeyBJVHJlZUdyaWRSZWNvcmQgfSBmcm9tICcuL3RyZWUtZ3JpZC5pbnRlcmZhY2VzJztcbmltcG9ydCB7IElSb3dEYXRhRXZlbnRBcmdzLCBJUm93VG9nZ2xlRXZlbnRBcmdzIH0gZnJvbSAnLi4vY29tbW9uL2V2ZW50cyc7XG5pbXBvcnQge1xuICAgIEhpZXJhcmNoaWNhbFRyYW5zYWN0aW9uLFxuICAgIEhpZXJhcmNoaWNhbFN0YXRlLFxuICAgIFRyYW5zYWN0aW9uVHlwZSxcbiAgICBUcmFuc2FjdGlvbkV2ZW50T3JpZ2luLFxuICAgIFN0YXRlVXBkYXRlRXZlbnRcbn0gZnJvbSAnLi4vLi4vc2VydmljZXMvdHJhbnNhY3Rpb24vdHJhbnNhY3Rpb24nO1xuaW1wb3J0IHsgSWd4RmlsdGVyaW5nU2VydmljZSB9IGZyb20gJy4uL2ZpbHRlcmluZy9ncmlkLWZpbHRlcmluZy5zZXJ2aWNlJztcbmltcG9ydCB7IElneEdyaWRTdW1tYXJ5U2VydmljZSB9IGZyb20gJy4uL3N1bW1hcmllcy9ncmlkLXN1bW1hcnkuc2VydmljZSc7XG5pbXBvcnQgeyBJZ3hHcmlkU2VsZWN0aW9uU2VydmljZSB9IGZyb20gJy4uL3NlbGVjdGlvbi9zZWxlY3Rpb24uc2VydmljZSc7XG5pbXBvcnQgeyBtZXJnZU9iamVjdHMsIFBsYXRmb3JtVXRpbCB9IGZyb20gJy4uLy4uL2NvcmUvdXRpbHMnO1xuaW1wb3J0IHsgZmlyc3QsIHRha2VVbnRpbCB9IGZyb20gJ3J4anMvb3BlcmF0b3JzJztcbmltcG9ydCB7IElneFJvd0xvYWRpbmdJbmRpY2F0b3JUZW1wbGF0ZURpcmVjdGl2ZSB9IGZyb20gJy4vdHJlZS1ncmlkLmRpcmVjdGl2ZXMnO1xuaW1wb3J0IHsgSWd4Rm9yT2ZTeW5jU2VydmljZSwgSWd4Rm9yT2ZTY3JvbGxTeW5jU2VydmljZSB9IGZyb20gJy4uLy4uL2RpcmVjdGl2ZXMvZm9yLW9mL2Zvcl9vZi5zeW5jLnNlcnZpY2UnO1xuaW1wb3J0IHsgSWd4R3JpZE5hdmlnYXRpb25TZXJ2aWNlIH0gZnJvbSAnLi4vZ3JpZC1uYXZpZ2F0aW9uLnNlcnZpY2UnO1xuaW1wb3J0IHsgQ2VsbFR5cGUsIEdyaWRTZXJ2aWNlVHlwZSwgR3JpZFR5cGUsIElHWF9HUklEX0JBU0UsIElHWF9HUklEX1NFUlZJQ0VfQkFTRSwgUm93VHlwZSB9IGZyb20gJy4uL2NvbW1vbi9ncmlkLmludGVyZmFjZSc7XG5pbXBvcnQgeyBJZ3hDb2x1bW5Db21wb25lbnQgfSBmcm9tICcuLi9jb2x1bW5zL2NvbHVtbi5jb21wb25lbnQnO1xuaW1wb3J0IHsgSWd4VHJlZUdyaWRTZWxlY3Rpb25TZXJ2aWNlIH0gZnJvbSAnLi90cmVlLWdyaWQtc2VsZWN0aW9uLnNlcnZpY2UnO1xuaW1wb3J0IHsgR3JpZEluc3RhbmNlVHlwZSwgR3JpZFNlbGVjdGlvbk1vZGUgfSBmcm9tICcuLi9jb21tb24vZW51bXMnO1xuaW1wb3J0IHsgSWd4U3VtbWFyeVJvdywgSWd4VHJlZUdyaWRSb3cgfSBmcm9tICcuLi9ncmlkLXB1YmxpYy1yb3cnO1xuaW1wb3J0IHsgSWd4R3JpZENSVURTZXJ2aWNlIH0gZnJvbSAnLi4vY29tbW9uL2NydWQuc2VydmljZSc7XG5pbXBvcnQgeyBJZ3hUcmVlR3JpZEdyb3VwQnlBcmVhQ29tcG9uZW50IH0gZnJvbSAnLi4vZ3JvdXBpbmcvdHJlZS1ncmlkLWdyb3VwLWJ5LWFyZWEuY29tcG9uZW50JztcbmltcG9ydCB7IElneEdyaWRDZWxsIH0gZnJvbSAnLi4vZ3JpZC1wdWJsaWMtY2VsbCc7XG5pbXBvcnQgeyBJZ3hIaWVyYXJjaGljYWxUcmFuc2FjdGlvbkZhY3RvcnkgfSBmcm9tICcuLi8uLi9zZXJ2aWNlcy90cmFuc2FjdGlvbi90cmFuc2FjdGlvbi1mYWN0b3J5LnNlcnZpY2UnO1xuaW1wb3J0IHsgSWd4Q29sdW1uUmVzaXppbmdTZXJ2aWNlIH0gZnJvbSAnLi4vcmVzaXppbmcvcmVzaXppbmcuc2VydmljZSc7XG5pbXBvcnQgeyBET0NVTUVOVCB9IGZyb20gJ0Bhbmd1bGFyL2NvbW1vbic7XG5pbXBvcnQgeyBEaXNwbGF5RGVuc2l0eVRva2VuLCBJRGlzcGxheURlbnNpdHlPcHRpb25zIH0gZnJvbSAnLi4vLi4vY29yZS9kZW5zaXR5JztcbmltcG9ydCB7IEhpZXJhcmNoaWNhbFRyYW5zYWN0aW9uU2VydmljZSB9IGZyb20gJy4uLy4uL3NlcnZpY2VzL3RyYW5zYWN0aW9uL2hpZXJhcmNoaWNhbC10cmFuc2FjdGlvbic7XG5pbXBvcnQgeyBJZ3hPdmVybGF5U2VydmljZSB9IGZyb20gJy4uLy4uL3NlcnZpY2VzL292ZXJsYXkvb3ZlcmxheSc7XG5pbXBvcnQgeyBJZ3hHcmlkVHJhbnNhY3Rpb24gfSBmcm9tICcuLi9jb21tb24vdHlwZXMnO1xuaW1wb3J0IHsgVHJlZUdyaWRGaWx0ZXJpbmdTdHJhdGVneSB9IGZyb20gJy4vdHJlZS1ncmlkLmZpbHRlcmluZy5zdHJhdGVneSc7XG5cbmxldCBORVhUX0lEID0gMDtcblxuLyoqXG4gKiAqKklnbml0ZSBVSSBmb3IgQW5ndWxhciBUcmVlIEdyaWQqKiAtXG4gKiBbRG9jdW1lbnRhdGlvbl0oaHR0cHM6Ly93d3cuaW5mcmFnaXN0aWNzLmNvbS9wcm9kdWN0cy9pZ25pdGUtdWktYW5ndWxhci9hbmd1bGFyL2NvbXBvbmVudHMvZ3JpZC9ncmlkKVxuICpcbiAqIFRoZSBJZ25pdGUgVUkgVHJlZSBHcmlkIGRpc3BsYXlzIGFuZCBtYW5pcHVsYXRlcyBoaWVyYXJjaGljYWwgZGF0YSB3aXRoIGNvbnNpc3RlbnQgc2NoZW1hIGZvcm1hdHRlZCBhcyBhIHRhYmxlIGFuZFxuICogcHJvdmlkZXMgZmVhdHVyZXMgc3VjaCBhcyBzb3J0aW5nLCBmaWx0ZXJpbmcsIGVkaXRpbmcsIGNvbHVtbiBwaW5uaW5nLCBwYWdpbmcsIGNvbHVtbiBtb3ZpbmcgYW5kIGhpZGluZy5cbiAqXG4gKiBFeGFtcGxlOlxuICogYGBgaHRtbFxuICogPGlneC10cmVlLWdyaWQgW2RhdGFdPVwiZW1wbG95ZWVEYXRhXCIgcHJpbWFyeUtleT1cImVtcGxveWVlSURcIiBmb3JlaWduS2V5PVwiUElEXCIgW2F1dG9HZW5lcmF0ZV09XCJmYWxzZVwiPlxuICogICA8aWd4LWNvbHVtbiBmaWVsZD1cImZpcnN0XCIgaGVhZGVyPVwiRmlyc3QgTmFtZVwiPjwvaWd4LWNvbHVtbj5cbiAqICAgPGlneC1jb2x1bW4gZmllbGQ9XCJsYXN0XCIgaGVhZGVyPVwiTGFzdCBOYW1lXCI+PC9pZ3gtY29sdW1uPlxuICogICA8aWd4LWNvbHVtbiBmaWVsZD1cInJvbGVcIiBoZWFkZXI9XCJSb2xlXCI+PC9pZ3gtY29sdW1uPlxuICogPC9pZ3gtdHJlZS1ncmlkPlxuICogYGBgXG4gKi9cbkBDb21wb25lbnQoe1xuICAgIGNoYW5nZURldGVjdGlvbjogQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuT25QdXNoLFxuICAgIHNlbGVjdG9yOiAnaWd4LXRyZWUtZ3JpZCcsXG4gICAgdGVtcGxhdGVVcmw6ICd0cmVlLWdyaWQuY29tcG9uZW50Lmh0bWwnLFxuICAgIHByb3ZpZGVyczogW1xuICAgICAgICBJZ3hHcmlkQ1JVRFNlcnZpY2UsXG4gICAgICAgIElneEdyaWRTdW1tYXJ5U2VydmljZSxcbiAgICAgICAgSWd4R3JpZE5hdmlnYXRpb25TZXJ2aWNlLFxuICAgICAgICB7IHByb3ZpZGU6IElneEdyaWRTZWxlY3Rpb25TZXJ2aWNlLCB1c2VDbGFzczogSWd4VHJlZUdyaWRTZWxlY3Rpb25TZXJ2aWNlIH0sXG4gICAgICAgIHsgcHJvdmlkZTogSUdYX0dSSURfU0VSVklDRV9CQVNFLCB1c2VDbGFzczogSWd4VHJlZUdyaWRBUElTZXJ2aWNlIH0sXG4gICAgICAgIHsgcHJvdmlkZTogSUdYX0dSSURfQkFTRSwgdXNlRXhpc3Rpbmc6IElneFRyZWVHcmlkQ29tcG9uZW50IH0sXG4gICAgICAgIElneEZpbHRlcmluZ1NlcnZpY2UsXG4gICAgICAgIElneEZvck9mU3luY1NlcnZpY2UsXG4gICAgICAgIElneEZvck9mU2Nyb2xsU3luY1NlcnZpY2VcbiAgICBdXG59KVxuZXhwb3J0IGNsYXNzIElneFRyZWVHcmlkQ29tcG9uZW50IGV4dGVuZHMgSWd4R3JpZEJhc2VEaXJlY3RpdmUgaW1wbGVtZW50cyBHcmlkVHlwZSwgT25Jbml0LCBBZnRlclZpZXdJbml0LCBEb0NoZWNrLCBBZnRlckNvbnRlbnRJbml0IHtcbiAgICAvKipcbiAgICAgKiBBbiBASW5wdXQgcHJvcGVydHkgdGhhdCBzZXRzIHRoZSBjaGlsZCBkYXRhIGtleSBvZiB0aGUgYElneFRyZWVHcmlkQ29tcG9uZW50YC5cbiAgICAgKiBgYGBodG1sXG4gICAgICogPGlneC10cmVlLWdyaWQgI2dyaWQgW2RhdGFdPVwiZW1wbG95ZWVEYXRhXCIgW2NoaWxkRGF0YUtleV09XCInZW1wbG95ZWVzJ1wiIFthdXRvR2VuZXJhdGVdPVwidHJ1ZVwiPjwvaWd4LXRyZWUtZ3JpZD5cbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBJZ3hUcmVlR3JpZENvbXBvbmVudFxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgcHVibGljIGNoaWxkRGF0YUtleTtcblxuICAgIC8qKlxuICAgICAqIEFuIEBJbnB1dCBwcm9wZXJ0eSB0aGF0IHNldHMgdGhlIGZvcmVpZ24ga2V5IG9mIHRoZSBgSWd4VHJlZUdyaWRDb21wb25lbnRgLlxuICAgICAqIGBgYGh0bWxcbiAgICAgKiA8aWd4LXRyZWUtZ3JpZCAjZ3JpZCBbZGF0YV09XCJlbXBsb3llZURhdGFcIiBbcHJpbWFyeUtleV09XCInZW1wbG95ZWVJRCdcIiBbZm9yZWlnbktleV09XCIncGFyZW50SUQnXCIgW2F1dG9HZW5lcmF0ZV09XCJ0cnVlXCI+XG4gICAgICogPC9pZ3gtdHJlZS1ncmlkPlxuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogQG1lbWJlcm9mIElneFRyZWVHcmlkQ29tcG9uZW50XG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBwdWJsaWMgZm9yZWlnbktleTtcblxuICAgIC8qKlxuICAgICAqIEFuIEBJbnB1dCBwcm9wZXJ0eSB0aGF0IHNldHMgdGhlIGtleSBpbmRpY2F0aW5nIHdoZXRoZXIgYSByb3cgaGFzIGNoaWxkcmVuLlxuICAgICAqIFRoaXMgcHJvcGVydHkgaXMgb25seSB1c2VkIGZvciBsb2FkIG9uIGRlbWFuZCBzY2VuYXJpb3MuXG4gICAgICogYGBgaHRtbFxuICAgICAqIDxpZ3gtdHJlZS1ncmlkICNncmlkIFtkYXRhXT1cImVtcGxveWVlRGF0YVwiIFtwcmltYXJ5S2V5XT1cIidlbXBsb3llZUlEJ1wiIFtmb3JlaWduS2V5XT1cIidwYXJlbnRJRCdcIlxuICAgICAqICAgICAgICAgICAgICAgIFtsb2FkQ2hpbGRyZW5PbkRlbWFuZF09XCJsb2FkQ2hpbGRyZW5cIlxuICAgICAqICAgICAgICAgICAgICAgIFtoYXNDaGlsZHJlbktleV09XCInaGFzRW1wbG95ZWVzJ1wiPlxuICAgICAqIDwvaWd4LXRyZWUtZ3JpZD5cbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBJZ3hUcmVlR3JpZENvbXBvbmVudFxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgcHVibGljIGhhc0NoaWxkcmVuS2V5O1xuXG4gICAgLyoqXG4gICAgICogQW4gQElucHV0IHByb3BlcnR5IGluZGljYXRpbmcgd2hldGhlciBjaGlsZCByZWNvcmRzIHNob3VsZCBiZSBkZWxldGVkIHdoZW4gdGhlaXIgcGFyZW50IGdldHMgZGVsZXRlZC5cbiAgICAgKiBCeSBkZWZhdWx0IGl0IGlzIHNldCB0byB0cnVlIGFuZCBkZWxldGVzIGFsbCBjaGlsZHJlbiBhbG9uZyB3aXRoIHRoZSBwYXJlbnQuXG4gICAgICogYGBgaHRtbFxuICAgICAqIDxpZ3gtdHJlZS1ncmlkIFtkYXRhXT1cImVtcGxveWVlRGF0YVwiIFtwcmltYXJ5S2V5XT1cIidlbXBsb3llZUlEJ1wiIFtmb3JlaWduS2V5XT1cIidwYXJlbnRJRCdcIiBjYXNjYWRlT25EZWxldGU9XCJmYWxzZVwiPlxuICAgICAqIDwvaWd4LXRyZWUtZ3JpZD5cbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBJZ3hUcmVlR3JpZENvbXBvbmVudFxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgcHVibGljIGNhc2NhZGVPbkRlbGV0ZSA9IHRydWU7XG5cbiAgICAvKipcbiAgICAgKiBBbiBASW5wdXQgcHJvcGVydHkgdGhhdCBwcm92aWRlcyBhIGNhbGxiYWNrIGZvciBsb2FkaW5nIGNoaWxkIHJvd3Mgb24gZGVtYW5kLlxuICAgICAqIGBgYGh0bWxcbiAgICAgKiA8aWd4LXRyZWUtZ3JpZCBbZGF0YV09XCJlbXBsb3llZURhdGFcIiBbcHJpbWFyeUtleV09XCInZW1wbG95ZWVJRCdcIiBbZm9yZWlnbktleV09XCIncGFyZW50SUQnXCIgW2xvYWRDaGlsZHJlbk9uRGVtYW5kXT1cImxvYWRDaGlsZHJlblwiPlxuICAgICAqIDwvaWd4LXRyZWUtZ3JpZD5cbiAgICAgKiBgYGBcbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogcHVibGljIGxvYWRDaGlsZHJlbiA9IChwYXJlbnRJRDogYW55LCBkb25lOiAoY2hpbGRyZW46IGFueVtdKSA9PiB2b2lkKSA9PiB7XG4gICAgICogICAgIHRoaXMuZGF0YVNlcnZpY2UuZ2V0RGF0YShwYXJlbnRJRCwgY2hpbGRyZW4gPT4gZG9uZShjaGlsZHJlbikpO1xuICAgICAqIH1cbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBJZ3hUcmVlR3JpZENvbXBvbmVudFxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgcHVibGljIGxvYWRDaGlsZHJlbk9uRGVtYW5kOiAocGFyZW50SUQ6IGFueSwgZG9uZTogKGNoaWxkcmVuOiBhbnlbXSkgPT4gdm9pZCkgPT4gdm9pZDtcblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW4gQGludGVybmFsXG4gICAgICovXG4gICAgQEhvc3RCaW5kaW5nKCdhdHRyLnJvbGUnKVxuICAgIHB1YmxpYyByb2xlID0gJ3RyZWVncmlkJztcblxuICAgIC8qKlxuICAgICAqIEFuIEBJbnB1dCBwcm9wZXJ0eSB0aGF0IHNldHMgdGhlIHZhbHVlIG9mIHRoZSBgaWRgIGF0dHJpYnV0ZS4gSWYgbm90IHByb3ZpZGVkIGl0IHdpbGwgYmUgYXV0b21hdGljYWxseSBnZW5lcmF0ZWQuXG4gICAgICogYGBgaHRtbFxuICAgICAqIDxpZ3gtdHJlZS1ncmlkIFtpZF09XCInaWd4LXRyZWUtZ3JpZC0xJ1wiPjwvaWd4LXRyZWUtZ3JpZD5cbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBJZ3hUcmVlR3JpZENvbXBvbmVudFxuICAgICAqL1xuICAgIEBIb3N0QmluZGluZygnYXR0ci5pZCcpXG4gICAgQElucHV0KClcbiAgICBwdWJsaWMgaWQgPSBgaWd4LXRyZWUtZ3JpZC0ke05FWFRfSUQrK31gO1xuXG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIEBDb250ZW50Q2hpbGQoSWd4VHJlZUdyaWRHcm91cEJ5QXJlYUNvbXBvbmVudCwgeyByZWFkOiBJZ3hUcmVlR3JpZEdyb3VwQnlBcmVhQ29tcG9uZW50IH0pXG4gICAgcHVibGljIHRyZWVHcm91cEFyZWE6IElneFRyZWVHcmlkR3JvdXBCeUFyZWFDb21wb25lbnQ7XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgQFZpZXdDaGlsZCgnZHJhZ0luZGljYXRvckljb25CYXNlJywgeyByZWFkOiBUZW1wbGF0ZVJlZiwgc3RhdGljOiB0cnVlIH0pXG4gICAgcHVibGljIGRyYWdJbmRpY2F0b3JJY29uQmFzZTogVGVtcGxhdGVSZWY8YW55PjtcblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW4gQGludGVybmFsXG4gICAgICovXG4gICAgQFZpZXdDaGlsZCgncmVjb3JkX3RlbXBsYXRlJywgeyByZWFkOiBUZW1wbGF0ZVJlZiwgc3RhdGljOiB0cnVlIH0pXG4gICAgcHJvdGVjdGVkIHJlY29yZFRlbXBsYXRlOiBUZW1wbGF0ZVJlZjxhbnk+O1xuXG4gICAgLyoqXG4gICAgICogQGhpZGRlbiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICBAVmlld0NoaWxkKCdzdW1tYXJ5X3RlbXBsYXRlJywgeyByZWFkOiBUZW1wbGF0ZVJlZiwgc3RhdGljOiB0cnVlIH0pXG4gICAgcHJvdGVjdGVkIHN1bW1hcnlUZW1wbGF0ZTogVGVtcGxhdGVSZWY8YW55PjtcblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBAQ29udGVudENoaWxkKElneFJvd0xvYWRpbmdJbmRpY2F0b3JUZW1wbGF0ZURpcmVjdGl2ZSwgeyByZWFkOiBJZ3hSb3dMb2FkaW5nSW5kaWNhdG9yVGVtcGxhdGVEaXJlY3RpdmUgfSlcbiAgICBwcm90ZWN0ZWQgcm93TG9hZGluZ1RlbXBsYXRlOiBJZ3hSb3dMb2FkaW5nSW5kaWNhdG9yVGVtcGxhdGVEaXJlY3RpdmU7XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgcHVibGljIGZsYXREYXRhOiBhbnlbXSB8IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgcHVibGljIHByb2Nlc3NlZEV4cGFuZGVkRmxhdERhdGE6IGFueVtdIHwgbnVsbDtcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYW4gYXJyYXkgb2YgdGhlIHJvb3QgbGV2ZWwgYElUcmVlR3JpZFJlY29yZGBzLlxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiAvLyBnZXRzIHRoZSByb290IHJlY29yZCB3aXRoIGluZGV4PTJcbiAgICAgKiBjb25zdCBzdGF0ZXMgPSB0aGlzLmdyaWQucm9vdFJlY29yZHNbMl07XG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgSWd4VHJlZUdyaWRDb21wb25lbnRcbiAgICAgKi9cbiAgICBwdWJsaWMgcm9vdFJlY29yZHM6IElUcmVlR3JpZFJlY29yZFtdO1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIG1hcCBvZiBhbGwgYElUcmVlR3JpZFJlY29yZGBzLlxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiAvLyBnZXRzIHRoZSByZWNvcmQgd2l0aCBwcmltYXJ5S2V5PTJcbiAgICAgKiBjb25zdCBzdGF0ZXMgPSB0aGlzLmdyaWQucmVjb3Jkcy5nZXQoMik7XG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgSWd4VHJlZUdyaWRDb21wb25lbnRcbiAgICAgKi9cbiAgICBwdWJsaWMgcmVjb3JkczogTWFwPGFueSwgSVRyZWVHcmlkUmVjb3JkPiA9IG5ldyBNYXA8YW55LCBJVHJlZUdyaWRSZWNvcmQ+KCk7XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGFuIGFycmF5IG9mIHByb2Nlc3NlZCAoZmlsdGVyZWQgYW5kIHNvcnRlZCkgcm9vdCBgSVRyZWVHcmlkUmVjb3JkYHMuXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIC8vIGdldHMgdGhlIHByb2Nlc3NlZCByb290IHJlY29yZCB3aXRoIGluZGV4PTJcbiAgICAgKiBjb25zdCBzdGF0ZXMgPSB0aGlzLmdyaWQucHJvY2Vzc2VkUm9vdFJlY29yZHNbMl07XG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgSWd4VHJlZUdyaWRDb21wb25lbnRcbiAgICAgKi9cbiAgICBwdWJsaWMgcHJvY2Vzc2VkUm9vdFJlY29yZHM6IElUcmVlR3JpZFJlY29yZFtdO1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIG1hcCBvZiBhbGwgcHJvY2Vzc2VkIChmaWx0ZXJlZCBhbmQgc29ydGVkKSBgSVRyZWVHcmlkUmVjb3JkYHMuXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIC8vIGdldHMgdGhlIHByb2Nlc3NlZCByZWNvcmQgd2l0aCBwcmltYXJ5S2V5PTJcbiAgICAgKiBjb25zdCBzdGF0ZXMgPSB0aGlzLmdyaWQucHJvY2Vzc2VkUmVjb3Jkcy5nZXQoMik7XG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgSWd4VHJlZUdyaWRDb21wb25lbnRcbiAgICAgKi9cbiAgICBwdWJsaWMgcHJvY2Vzc2VkUmVjb3JkczogTWFwPGFueSwgSVRyZWVHcmlkUmVjb3JkPiA9IG5ldyBNYXA8YW55LCBJVHJlZUdyaWRSZWNvcmQ+KCk7XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgcHVibGljIGxvYWRpbmdSb3dzID0gbmV3IFNldDxhbnk+KCk7XG5cbiAgICBwcm90ZWN0ZWQgX2ZpbHRlclN0cmF0ZWd5ID0gbmV3IFRyZWVHcmlkRmlsdGVyaW5nU3RyYXRlZ3koKTtcbiAgICBwcm90ZWN0ZWQgX3RyYW5zYWN0aW9uczogSGllcmFyY2hpY2FsVHJhbnNhY3Rpb25TZXJ2aWNlPEhpZXJhcmNoaWNhbFRyYW5zYWN0aW9uLCBIaWVyYXJjaGljYWxTdGF0ZT47XG4gICAgcHJpdmF0ZSBfZGF0YTtcbiAgICBwcml2YXRlIF9yb3dMb2FkaW5nSW5kaWNhdG9yVGVtcGxhdGU6IFRlbXBsYXRlUmVmPGFueT47XG4gICAgcHJpdmF0ZSBfZXhwYW5zaW9uRGVwdGggPSBJbmZpbml0eTtcbiAgICBwcml2YXRlIF9maWx0ZXJlZERhdGEgPSBudWxsO1xuXG4gICAgLyoqXG4gICAgICogQW4gQElucHV0IHByb3BlcnR5IHRoYXQgbGV0cyB5b3UgZmlsbCB0aGUgYElneFRyZWVHcmlkQ29tcG9uZW50YCB3aXRoIGFuIGFycmF5IG9mIGRhdGEuXG4gICAgICogYGBgaHRtbFxuICAgICAqIDxpZ3gtdHJlZS1ncmlkIFtkYXRhXT1cIkRhdGFcIiBbYXV0b0dlbmVyYXRlXT1cInRydWVcIj48L2lneC10cmVlLWdyaWQ+XG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgSWd4VHJlZUdyaWRDb21wb25lbnRcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIHB1YmxpYyBnZXQgZGF0YSgpOiBhbnlbXSB8IG51bGwge1xuICAgICAgICByZXR1cm4gdGhpcy5fZGF0YTtcbiAgICB9XG5cbiAgICBwdWJsaWMgc2V0IGRhdGEodmFsdWU6IGFueVtdIHwgbnVsbCkge1xuICAgICAgICB0aGlzLl9kYXRhID0gdmFsdWUgfHwgW107XG4gICAgICAgIHRoaXMuc3VtbWFyeVNlcnZpY2UuY2xlYXJTdW1tYXJ5Q2FjaGUoKTtcbiAgICAgICAgaWYgKHRoaXMuc2hvdWxkR2VuZXJhdGUpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0dXBDb2x1bW5zKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jZHIubWFya0ZvckNoZWNrKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhbiBhcnJheSBvZiBvYmplY3RzIGNvbnRhaW5pbmcgdGhlIGZpbHRlcmVkIGRhdGEgaW4gdGhlIGBJZ3hHcmlkQ29tcG9uZW50YC5cbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogbGV0IGZpbHRlcmVkRGF0YSA9IHRoaXMuZ3JpZC5maWx0ZXJlZERhdGE7XG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgSWd4VHJlZUdyaWRDb21wb25lbnRcbiAgICAgKi9cbiAgICBwdWJsaWMgZ2V0IGZpbHRlcmVkRGF0YSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2ZpbHRlcmVkRGF0YTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXRzIGFuIGFycmF5IG9mIG9iamVjdHMgY29udGFpbmluZyB0aGUgZmlsdGVyZWQgZGF0YSBpbiB0aGUgYElneEdyaWRDb21wb25lbnRgLlxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiB0aGlzLmdyaWQuZmlsdGVyZWREYXRhID0gW3tcbiAgICAgKiAgICAgICBJRDogMSxcbiAgICAgKiAgICAgICBOYW1lOiBcIkFcIlxuICAgICAqIH1dO1xuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogQG1lbWJlcm9mIElneFRyZWVHcmlkQ29tcG9uZW50XG4gICAgICovXG4gICAgcHVibGljIHNldCBmaWx0ZXJlZERhdGEodmFsdWUpIHtcbiAgICAgICAgdGhpcy5fZmlsdGVyZWREYXRhID0gdmFsdWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0IHRyYW5zYWN0aW9ucyBzZXJ2aWNlIGZvciB0aGUgZ3JpZC5cbiAgICAgKlxuICAgICAqIEBleHBlcmltZW50YWwgQGhpZGRlblxuICAgICAqL1xuICAgIHB1YmxpYyBnZXQgdHJhbnNhY3Rpb25zKCkge1xuICAgICAgICBpZiAodGhpcy5fZGlUcmFuc2FjdGlvbnMgJiYgIXRoaXMuYmF0Y2hFZGl0aW5nKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZGlUcmFuc2FjdGlvbnM7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX3RyYW5zYWN0aW9ucztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBbiBASW5wdXQgcHJvcGVydHkgdGhhdCBzZXRzIHRoZSBjb3VudCBvZiBsZXZlbHMgdG8gYmUgZXhwYW5kZWQgaW4gdGhlIGBJZ3hUcmVlR3JpZENvbXBvbmVudGAuIEJ5IGRlZmF1bHQgaXQgaXNcbiAgICAgKiBzZXQgdG8gYEluZmluaXR5YCB3aGljaCBtZWFucyBhbGwgbGV2ZWxzIHdvdWxkIGJlIGV4cGFuZGVkLlxuICAgICAqIGBgYGh0bWxcbiAgICAgKiA8aWd4LXRyZWUtZ3JpZCAjZ3JpZCBbZGF0YV09XCJlbXBsb3llZURhdGFcIiBbY2hpbGREYXRhS2V5XT1cIidlbXBsb3llZXMnXCIgZXhwYW5zaW9uRGVwdGg9XCIxXCIgW2F1dG9HZW5lcmF0ZV09XCJ0cnVlXCI+PC9pZ3gtdHJlZS1ncmlkPlxuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogQG1lbWJlcm9mIElneFRyZWVHcmlkQ29tcG9uZW50XG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBwdWJsaWMgZ2V0IGV4cGFuc2lvbkRlcHRoKCk6IG51bWJlciB7XG4gICAgICAgIHJldHVybiB0aGlzLl9leHBhbnNpb25EZXB0aDtcbiAgICB9XG5cbiAgICBwdWJsaWMgc2V0IGV4cGFuc2lvbkRlcHRoKHZhbHVlOiBudW1iZXIpIHtcbiAgICAgICAgdGhpcy5fZXhwYW5zaW9uRGVwdGggPSB2YWx1ZTtcbiAgICAgICAgdGhpcy5ub3RpZnlDaGFuZ2VzKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQW4gQElucHV0IHByb3BlcnR5IHRoYXQgcHJvdmlkZXMgYSB0ZW1wbGF0ZSBmb3IgdGhlIHJvdyBsb2FkaW5nIGluZGljYXRvciB3aGVuIGxvYWQgb24gZGVtYW5kIGlzIGVuYWJsZWQuXG4gICAgICogYGBgaHRtbFxuICAgICAqIDxuZy10ZW1wbGF0ZSAjcm93TG9hZGluZ1RlbXBsYXRlPlxuICAgICAqICAgICA8aWd4LWljb24+bG9vcDwvaWd4LWljb24+XG4gICAgICogPC9uZy10ZW1wbGF0ZT5cbiAgICAgKlxuICAgICAqIDxpZ3gtdHJlZS1ncmlkICNncmlkIFtkYXRhXT1cImVtcGxveWVlRGF0YVwiIFtwcmltYXJ5S2V5XT1cIidJRCdcIiBbZm9yZWlnbktleV09XCIncGFyZW50SUQnXCJcbiAgICAgKiAgICAgICAgICAgICAgICBbbG9hZENoaWxkcmVuT25EZW1hbmRdPVwibG9hZENoaWxkcmVuXCJcbiAgICAgKiAgICAgICAgICAgICAgICBbcm93TG9hZGluZ0luZGljYXRvclRlbXBsYXRlXT1cInJvd0xvYWRpbmdUZW1wbGF0ZVwiPlxuICAgICAqIDwvaWd4LXRyZWUtZ3JpZD5cbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBJZ3hUcmVlR3JpZENvbXBvbmVudFxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgcHVibGljIGdldCByb3dMb2FkaW5nSW5kaWNhdG9yVGVtcGxhdGUoKTogVGVtcGxhdGVSZWY8YW55PiB7XG4gICAgICAgIHJldHVybiB0aGlzLl9yb3dMb2FkaW5nSW5kaWNhdG9yVGVtcGxhdGU7XG4gICAgfVxuXG4gICAgcHVibGljIHNldCByb3dMb2FkaW5nSW5kaWNhdG9yVGVtcGxhdGUodmFsdWU6IFRlbXBsYXRlUmVmPGFueT4pIHtcbiAgICAgICAgdGhpcy5fcm93TG9hZGluZ0luZGljYXRvclRlbXBsYXRlID0gdmFsdWU7XG4gICAgICAgIHRoaXMubm90aWZ5Q2hhbmdlcygpO1xuICAgIH1cblxuICAgIC8vIEtpbmQgb2Ygc3R1cGlkXG4gICAgLy8gcHJpdmF0ZSBnZXQgX2dyaWRBUEkoKTogSWd4VHJlZUdyaWRBUElTZXJ2aWNlIHtcbiAgICAvLyAgICAgcmV0dXJuIHRoaXMuZ3JpZEFQSSBhcyBJZ3hUcmVlR3JpZEFQSVNlcnZpY2U7XG4gICAgLy8gfVxuXG4gICAgY29uc3RydWN0b3IoXG4gICAgICAgIHB1YmxpYyBzZWxlY3Rpb25TZXJ2aWNlOiBJZ3hHcmlkU2VsZWN0aW9uU2VydmljZSxcbiAgICAgICAgcHVibGljIGNvbFJlc2l6aW5nU2VydmljZTogSWd4Q29sdW1uUmVzaXppbmdTZXJ2aWNlLFxuICAgICAgICBASW5qZWN0KElHWF9HUklEX1NFUlZJQ0VfQkFTRSkgcHVibGljIGdyaWRBUEk6IEdyaWRTZXJ2aWNlVHlwZSxcbiAgICAgICAgLy8gcHVibGljIGdyaWRBUEk6IEdyaWRCYXNlQVBJU2VydmljZTxJZ3hHcmlkQmFzZURpcmVjdGl2ZSAmIEdyaWRUeXBlPixcbiAgICAgICAgcHJvdGVjdGVkIHRyYW5zYWN0aW9uRmFjdG9yeTogSWd4SGllcmFyY2hpY2FsVHJhbnNhY3Rpb25GYWN0b3J5LFxuICAgICAgICBfZWxlbWVudFJlZjogRWxlbWVudFJlZjxIVE1MRWxlbWVudD4sXG4gICAgICAgIF96b25lOiBOZ1pvbmUsXG4gICAgICAgIEBJbmplY3QoRE9DVU1FTlQpIHB1YmxpYyBkb2N1bWVudDogYW55LFxuICAgICAgICBwdWJsaWMgY2RyOiBDaGFuZ2VEZXRlY3RvclJlZixcbiAgICAgICAgcHJvdGVjdGVkIHJlc29sdmVyOiBDb21wb25lbnRGYWN0b3J5UmVzb2x2ZXIsXG4gICAgICAgIHByb3RlY3RlZCBkaWZmZXJzOiBJdGVyYWJsZURpZmZlcnMsXG4gICAgICAgIHByb3RlY3RlZCB2aWV3UmVmOiBWaWV3Q29udGFpbmVyUmVmLFxuICAgICAgICBhcHBSZWY6IEFwcGxpY2F0aW9uUmVmLFxuICAgICAgICBtb2R1bGVSZWY6IE5nTW9kdWxlUmVmPGFueT4sXG4gICAgICAgIGluamVjdG9yOiBJbmplY3RvcixcbiAgICAgICAgcHVibGljIG5hdmlnYXRpb246IElneEdyaWROYXZpZ2F0aW9uU2VydmljZSxcbiAgICAgICAgcHVibGljIGZpbHRlcmluZ1NlcnZpY2U6IElneEZpbHRlcmluZ1NlcnZpY2UsXG4gICAgICAgIEBJbmplY3QoSWd4T3ZlcmxheVNlcnZpY2UpIHByb3RlY3RlZCBvdmVybGF5U2VydmljZTogSWd4T3ZlcmxheVNlcnZpY2UsXG4gICAgICAgIHB1YmxpYyBzdW1tYXJ5U2VydmljZTogSWd4R3JpZFN1bW1hcnlTZXJ2aWNlLFxuICAgICAgICBAT3B0aW9uYWwoKSBASW5qZWN0KERpc3BsYXlEZW5zaXR5VG9rZW4pIHByb3RlY3RlZCBfZGlzcGxheURlbnNpdHlPcHRpb25zOiBJRGlzcGxheURlbnNpdHlPcHRpb25zLFxuICAgICAgICBASW5qZWN0KExPQ0FMRV9JRCkgbG9jYWxlSWQ6IHN0cmluZyxcbiAgICAgICAgcHJvdGVjdGVkIHBsYXRmb3JtOiBQbGF0Zm9ybVV0aWwsXG4gICAgICAgIEBPcHRpb25hbCgpIEBJbmplY3QoSWd4R3JpZFRyYW5zYWN0aW9uKSBwcm90ZWN0ZWQgX2RpVHJhbnNhY3Rpb25zPzpcbiAgICAgICAgICAgIEhpZXJhcmNoaWNhbFRyYW5zYWN0aW9uU2VydmljZTxIaWVyYXJjaGljYWxUcmFuc2FjdGlvbiwgSGllcmFyY2hpY2FsU3RhdGU+LFxuICAgICkge1xuICAgICAgICBzdXBlcihzZWxlY3Rpb25TZXJ2aWNlLCBjb2xSZXNpemluZ1NlcnZpY2UsIGdyaWRBUEksIHRyYW5zYWN0aW9uRmFjdG9yeSxcbiAgICAgICAgICAgIF9lbGVtZW50UmVmLCBfem9uZSwgZG9jdW1lbnQsIGNkciwgcmVzb2x2ZXIsIGRpZmZlcnMsIHZpZXdSZWYsIGFwcFJlZiwgbW9kdWxlUmVmLCBpbmplY3RvciwgbmF2aWdhdGlvbixcbiAgICAgICAgICAgIGZpbHRlcmluZ1NlcnZpY2UsIG92ZXJsYXlTZXJ2aWNlLCBzdW1tYXJ5U2VydmljZSwgX2Rpc3BsYXlEZW5zaXR5T3B0aW9ucywgbG9jYWxlSWQsIHBsYXRmb3JtKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAZGVwcmVjYXRlZCBpbiB2ZXJzaW9uIDEyLjEuMC4gVXNlIGBnZXRDZWxsQnlDb2x1bW5gIG9yIGBnZXRDZWxsQnlLZXlgIGluc3RlYWRcbiAgICAgKlxuICAgICAqIFJldHVybnMgYSBgQ2VsbFR5cGVgIG9iamVjdCB0aGF0IG1hdGNoZXMgdGhlIGNvbmRpdGlvbnMuXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiBjb25zdCBteUNlbGwgPSB0aGlzLmdyaWQxLmdldENlbGxCeUNvbHVtblZpc2libGVJbmRleCgyLFwiVW5pdFByaWNlXCIpO1xuICAgICAqIGBgYFxuICAgICAqIEBwYXJhbSByb3dJbmRleFxuICAgICAqIEBwYXJhbSBpbmRleFxuICAgICAqL1xuICAgIHB1YmxpYyBnZXRDZWxsQnlDb2x1bW5WaXNpYmxlSW5kZXgocm93SW5kZXg6IG51bWJlciwgaW5kZXg6IG51bWJlcik6IENlbGxUeXBlIHtcbiAgICAgICAgY29uc3Qgcm93ID0gdGhpcy5nZXRSb3dCeUluZGV4KHJvd0luZGV4KTtcbiAgICAgICAgY29uc3QgY29sdW1uID0gdGhpcy5jb2x1bW5MaXN0LmZpbmQoKGNvbCkgPT4gY29sLnZpc2libGVJbmRleCA9PT0gaW5kZXgpO1xuICAgICAgICBpZiAocm93ICYmIHJvdyBpbnN0YW5jZW9mIElneFRyZWVHcmlkUm93ICYmIGNvbHVtbikge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBJZ3hHcmlkQ2VsbCh0aGlzIGFzIGFueSwgcm93SW5kZXgsIGNvbHVtbi5maWVsZCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgcHVibGljIG5nT25Jbml0KCkge1xuICAgICAgICBzdXBlci5uZ09uSW5pdCgpO1xuXG4gICAgICAgIHRoaXMucm93VG9nZ2xlLnBpcGUodGFrZVVudGlsKHRoaXMuZGVzdHJveSQpKS5zdWJzY3JpYmUoKGFyZ3MpID0+IHtcbiAgICAgICAgICAgIHRoaXMubG9hZENoaWxkcmVuT25Sb3dFeHBhbnNpb24oYXJncyk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIFRPRE86IGNhc2NhZGUgc2VsZWN0aW9uIGxvZ2ljIHNob3VsZCBiZSByZWZhY3RvciB0byBiZSBoYW5kbGVkIGluIHRoZSBhbHJlYWR5IGV4aXN0aW5nIHN1YnNcbiAgICAgICAgdGhpcy5yb3dBZGRlZE5vdGlmaWVyLnBpcGUodGFrZVVudGlsKHRoaXMuZGVzdHJveSQpKS5zdWJzY3JpYmUoYXJncyA9PiB7XG4gICAgICAgICAgICBpZiAodGhpcy5yb3dTZWxlY3Rpb24gPT09IEdyaWRTZWxlY3Rpb25Nb2RlLm11bHRpcGxlQ2FzY2FkZSkge1xuICAgICAgICAgICAgICAgIGxldCByZWMgPSB0aGlzLmdyaWRBUEkuZ2V0X3JlY19ieV9pZCh0aGlzLnByaW1hcnlLZXkgPyBhcmdzLmRhdGFbdGhpcy5wcmltYXJ5S2V5XSA6IGFyZ3MuZGF0YSk7XG4gICAgICAgICAgICAgICAgaWYgKHJlYyAmJiByZWMucGFyZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZ3JpZEFQSS5ncmlkLnNlbGVjdGlvblNlcnZpY2UudXBkYXRlQ2FzY2FkZVNlbGVjdGlvbk9uRmlsdGVyQW5kQ1JVRChcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ldyBTZXQoW3JlYy5wYXJlbnRdKSwgcmVjLnBhcmVudC5rZXkpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFRoZSByZWNvcmQgaXMgc3RpbGwgbm90IGF2YWlsYWJsZVxuICAgICAgICAgICAgICAgICAgICAvLyBXYWl0IGZvciB0aGUgY2hhbmdlIGRldGVjdGlvbiB0byB1cGRhdGUgcmVjb3JkcyB0aHJvdWdoIHBpcGVzXG4gICAgICAgICAgICAgICAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZWMgPSB0aGlzLmdyaWRBUEkuZ2V0X3JlY19ieV9pZCh0aGlzLnByaW1hcnlLZXkgP1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFyZ3MuZGF0YVt0aGlzLnByaW1hcnlLZXldIDogYXJncy5kYXRhKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZWMgJiYgcmVjLnBhcmVudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZ3JpZEFQSS5ncmlkLnNlbGVjdGlvblNlcnZpY2UudXBkYXRlQ2FzY2FkZVNlbGVjdGlvbk9uRmlsdGVyQW5kQ1JVRChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3IFNldChbcmVjLnBhcmVudF0pLCByZWMucGFyZW50LmtleSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm5vdGlmeUNoYW5nZXMoKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICB0aGlzLnJvd0RlbGV0ZWROb3RpZmllci5waXBlKHRha2VVbnRpbCh0aGlzLmRlc3Ryb3kkKSkuc3Vic2NyaWJlKGFyZ3MgPT4ge1xuICAgICAgICAgICAgaWYgKHRoaXMucm93U2VsZWN0aW9uID09PSBHcmlkU2VsZWN0aW9uTW9kZS5tdWx0aXBsZUNhc2NhZGUpIHtcbiAgICAgICAgICAgICAgICBpZiAoYXJncy5kYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlYyA9IHRoaXMuZ3JpZEFQSS5nZXRfcmVjX2J5X2lkKFxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5wcmltYXJ5S2V5ID8gYXJncy5kYXRhW3RoaXMucHJpbWFyeUtleV0gOiBhcmdzLmRhdGEpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmhhbmRsZUNhc2NhZGVTZWxlY3Rpb24oYXJncywgcmVjKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBpZiBhIHJvdyBoYXMgYmVlbiBhZGRlZCBhbmQgYmVmb3JlIGNvbW1pdGluZyB0aGUgdHJhbnNhY3Rpb24gZGVsZXRlZFxuICAgICAgICAgICAgICAgICAgICBjb25zdCBsZWFmUm93c0RpcmVjdFBhcmVudHMgPSBuZXcgU2V0PGFueT4oKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZWNvcmRzLmZvckVhY2gocmVjb3JkID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZWNvcmQgJiYgKCFyZWNvcmQuY2hpbGRyZW4gfHwgcmVjb3JkLmNoaWxkcmVuLmxlbmd0aCA9PT0gMCkgJiYgcmVjb3JkLnBhcmVudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxlYWZSb3dzRGlyZWN0UGFyZW50cy5hZGQocmVjb3JkLnBhcmVudCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAvLyBXYWl0IGZvciB0aGUgY2hhbmdlIGRldGVjdGlvbiB0byB1cGRhdGUgcmVjb3JkcyB0aHJvdWdoIHBpcGVzXG4gICAgICAgICAgICAgICAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmdyaWRBUEkuZ3JpZC5zZWxlY3Rpb25TZXJ2aWNlLnVwZGF0ZUNhc2NhZGVTZWxlY3Rpb25PbkZpbHRlckFuZENSVUQobGVhZlJvd3NEaXJlY3RQYXJlbnRzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubm90aWZ5Q2hhbmdlcygpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHRoaXMuZmlsdGVyaW5nRG9uZS5waXBlKHRha2VVbnRpbCh0aGlzLmRlc3Ryb3kkKSkuc3Vic2NyaWJlKCgpID0+IHtcbiAgICAgICAgICAgIGlmICh0aGlzLnJvd1NlbGVjdGlvbiA9PT0gR3JpZFNlbGVjdGlvbk1vZGUubXVsdGlwbGVDYXNjYWRlKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbGVhZlJvd3NEaXJlY3RQYXJlbnRzID0gbmV3IFNldDxhbnk+KCk7XG4gICAgICAgICAgICAgICAgdGhpcy5yZWNvcmRzLmZvckVhY2gocmVjb3JkID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlY29yZCAmJiAoIXJlY29yZC5jaGlsZHJlbiB8fCByZWNvcmQuY2hpbGRyZW4ubGVuZ3RoID09PSAwKSAmJiByZWNvcmQucGFyZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZWFmUm93c0RpcmVjdFBhcmVudHMuYWRkKHJlY29yZC5wYXJlbnQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgdGhpcy5ncmlkQVBJLmdyaWQuc2VsZWN0aW9uU2VydmljZS51cGRhdGVDYXNjYWRlU2VsZWN0aW9uT25GaWx0ZXJBbmRDUlVEKGxlYWZSb3dzRGlyZWN0UGFyZW50cyk7XG4gICAgICAgICAgICAgICAgdGhpcy5ub3RpZnlDaGFuZ2VzKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIHB1YmxpYyBuZ0RvQ2hlY2soKSB7XG4gICAgICAgIHN1cGVyLm5nRG9DaGVjaygpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBwdWJsaWMgbmdBZnRlclZpZXdJbml0KCkge1xuICAgICAgICBzdXBlci5uZ0FmdGVyVmlld0luaXQoKTtcbiAgICAgICAgLy8gVE9ETzogcGlwZXNFeGVjdHVyZWQgZXZlbnRcbiAgICAgICAgLy8gcnVuIGFmdGVyIGNoYW5nZSBkZXRlY3Rpb24gaW4gc3VwZXIgdHJpZ2dlcnMgcGlwZXMgZm9yIHJlY29yZHMgc3RydWN0dXJlXG4gICAgICAgIGlmICh0aGlzLnJvd1NlbGVjdGlvbiA9PT0gR3JpZFNlbGVjdGlvbk1vZGUubXVsdGlwbGVDYXNjYWRlICYmIHRoaXMuc2VsZWN0ZWRSb3dzLmxlbmd0aCkge1xuICAgICAgICAgICAgY29uc3Qgc2VsUm93cyA9IHRoaXMuc2VsZWN0ZWRSb3dzO1xuICAgICAgICAgICAgdGhpcy5zZWxlY3Rpb25TZXJ2aWNlLmNsZWFyUm93U2VsZWN0aW9uKCk7XG4gICAgICAgICAgICB0aGlzLnNlbGVjdFJvd3Moc2VsUm93cywgdHJ1ZSk7XG4gICAgICAgICAgICB0aGlzLmNkci5kZXRlY3RDaGFuZ2VzKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgcHVibGljIG5nQWZ0ZXJDb250ZW50SW5pdCgpIHtcbiAgICAgICAgaWYgKHRoaXMucm93TG9hZGluZ1RlbXBsYXRlKSB7XG4gICAgICAgICAgICB0aGlzLl9yb3dMb2FkaW5nSW5kaWNhdG9yVGVtcGxhdGUgPSB0aGlzLnJvd0xvYWRpbmdUZW1wbGF0ZS50ZW1wbGF0ZTtcbiAgICAgICAgfVxuICAgICAgICBzdXBlci5uZ0FmdGVyQ29udGVudEluaXQoKTtcbiAgICB9XG5cbiAgICBwdWJsaWMgZ2V0RGVmYXVsdEV4cGFuZFN0YXRlKHJlY29yZDogSVRyZWVHcmlkUmVjb3JkKSB7XG4gICAgICAgIHJldHVybiByZWNvcmQuY2hpbGRyZW4gJiYgcmVjb3JkLmNoaWxkcmVuLmxlbmd0aCAmJiByZWNvcmQubGV2ZWwgPCB0aGlzLmV4cGFuc2lvbkRlcHRoO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEV4cGFuZHMgYWxsIHJvd3MuXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIHRoaXMuZ3JpZC5leHBhbmRBbGwoKTtcbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBJZ3hUcmVlR3JpZENvbXBvbmVudFxuICAgICAqL1xuICAgIHB1YmxpYyBleHBhbmRBbGwoKSB7XG4gICAgICAgIHRoaXMuX2V4cGFuc2lvbkRlcHRoID0gSW5maW5pdHk7XG4gICAgICAgIHRoaXMuZXhwYW5zaW9uU3RhdGVzID0gbmV3IE1hcDxhbnksIGJvb2xlYW4+KCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29sbGFwc2VzIGFsbCByb3dzLlxuICAgICAqXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIHRoaXMuZ3JpZC5jb2xsYXBzZUFsbCgpO1xuICAgICAqICBgYGBcbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBJZ3hUcmVlR3JpZENvbXBvbmVudFxuICAgICAqL1xuICAgIHB1YmxpYyBjb2xsYXBzZUFsbCgpIHtcbiAgICAgICAgdGhpcy5fZXhwYW5zaW9uRGVwdGggPSAwO1xuICAgICAgICB0aGlzLmV4cGFuc2lvblN0YXRlcyA9IG5ldyBNYXA8YW55LCBib29sZWFuPigpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBwdWJsaWMgcmVmcmVzaEdyaWRTdGF0ZShhcmdzPzogSVJvd0RhdGFFdmVudEFyZ3MpIHtcbiAgICAgICAgc3VwZXIucmVmcmVzaEdyaWRTdGF0ZSgpO1xuICAgICAgICBpZiAodGhpcy5wcmltYXJ5S2V5ICYmIHRoaXMuZm9yZWlnbktleSAmJiBhcmdzKSB7XG4gICAgICAgICAgICBjb25zdCByb3dJRCA9IGFyZ3MuZGF0YVt0aGlzLmZvcmVpZ25LZXldO1xuICAgICAgICAgICAgdGhpcy5zdW1tYXJ5U2VydmljZS5jbGVhclN1bW1hcnlDYWNoZSh7IHJvd0lEIH0pO1xuICAgICAgICAgICAgdGhpcy5waXBlVHJpZ2dlcisrO1xuICAgICAgICAgICAgdGhpcy5jZHIuZGV0ZWN0Q2hhbmdlcygpO1xuICAgICAgICB9XG4gICAgfVxuXG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IGBJZ3hUcmVlR3JpZFJvd0NvbXBvbmVudGAgd2l0aCB0aGUgZ2l2ZW4gZGF0YS4gSWYgYSBwYXJlbnRSb3dJRCBpcyBub3Qgc3BlY2lmaWVkLCB0aGUgbmV3bHkgY3JlYXRlZFxuICAgICAqIHJvdyB3b3VsZCBiZSBhZGRlZCBhdCB0aGUgcm9vdCBsZXZlbC4gT3RoZXJ3aXNlLCBpdCB3b3VsZCBiZSBhZGRlZCBhcyBhIGNoaWxkIG9mIHRoZSByb3cgd2hvc2UgcHJpbWFyeUtleSBtYXRjaGVzXG4gICAgICogdGhlIHNwZWNpZmllZCBwYXJlbnRSb3dJRC4gSWYgdGhlIHBhcmVudFJvd0lEIGRvZXMgbm90IGV4aXN0LCBhbiBlcnJvciB3b3VsZCBiZSB0aHJvd24uXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIGNvbnN0IHJlY29yZCA9IHtcbiAgICAgKiAgICAgSUQ6IHRoaXMuZ3JpZC5kYXRhW3RoaXMuZ3JpZDEuZGF0YS5sZW5ndGggLSAxXS5JRCArIDEsXG4gICAgICogICAgIE5hbWU6IHRoaXMubmV3UmVjb3JkXG4gICAgICogfTtcbiAgICAgKiB0aGlzLmdyaWQuYWRkUm93KHJlY29yZCwgMSk7IC8vIEFkZHMgYSBuZXcgY2hpbGQgcm93IHRvIHRoZSByb3cgd2l0aCBJRD0xLlxuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogQHBhcmFtIGRhdGFcbiAgICAgKiBAcGFyYW0gcGFyZW50Um93SURcbiAgICAgKiBAbWVtYmVyb2YgSWd4VHJlZUdyaWRDb21wb25lbnRcbiAgICAgKi9cbiAgICAvLyBUT0RPOiByZW1vdmUgZXZ0IGVtaXNzaW9uXG4gICAgcHVibGljIGFkZFJvdyhkYXRhOiBhbnksIHBhcmVudFJvd0lEPzogYW55KSB7XG4gICAgICAgIHRoaXMuY3J1ZFNlcnZpY2UuZW5kRWRpdCh0cnVlKTtcbiAgICAgICAgdGhpcy5ncmlkQVBJLmFkZFJvd1RvRGF0YShkYXRhLCBwYXJlbnRSb3dJRCk7XG5cbiAgICAgICAgdGhpcy5yb3dBZGRlZE5vdGlmaWVyLm5leHQoeyBkYXRhIH0pO1xuICAgICAgICB0aGlzLnBpcGVUcmlnZ2VyKys7XG4gICAgICAgIHRoaXMubm90aWZ5Q2hhbmdlcygpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEVudGVycyBhZGQgbW9kZSBieSBzcGF3bmluZyB0aGUgVUkgd2l0aCB0aGUgY29udGV4dCBvZiB0aGUgc3BlY2lmaWVkIHJvdyBieSBpbmRleC5cbiAgICAgKlxuICAgICAqIEByZW1hcmtzXG4gICAgICogQWNjZXB0ZWQgdmFsdWVzIGZvciBpbmRleCBhcmUgaW50ZWdlcnMgZnJvbSAwIHRvIHRoaXMuZ3JpZC5kYXRhVmlldy5sZW5ndGhcbiAgICAgKiBAcmVtYXJrc1xuICAgICAqIFdoZW4gYWRkaW5nIHRoZSByb3cgYXMgYSBjaGlsZCwgdGhlIHBhcmVudCByb3cgaXMgdGhlIHNwZWNpZmllZCByb3cuXG4gICAgICogQHJlbWFya3NcbiAgICAgKiBUbyBzcGF3biB0aGUgVUkgb24gdG9wLCBjYWxsIHRoZSBmdW5jdGlvbiB3aXRoIGluZGV4ID0gbnVsbCBvciBhIG5lZ2F0aXZlIG51bWJlci5cbiAgICAgKiBJbiB0aGlzIGNhc2UgdHJ5aW5nIHRvIGFkZCB0aGlzIHJvdyBhcyBhIGNoaWxkIHdpbGwgcmVzdWx0IGluIGVycm9yLlxuICAgICAqIEBleGFtcGxlXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIHRoaXMuZ3JpZC5iZWdpbkFkZFJvd0J5SW5kZXgoMTApO1xuICAgICAqIHRoaXMuZ3JpZC5iZWdpbkFkZFJvd0J5SW5kZXgoMTAsIHRydWUpO1xuICAgICAqIHRoaXMuZ3JpZC5iZWdpbkFkZFJvd0J5SW5kZXgobnVsbCk7XG4gICAgICogYGBgXG4gICAgICogQHBhcmFtIGluZGV4IC0gVGhlIGluZGV4IHRvIHNwYXduIHRoZSBVSSBhdC4gQWNjZXB0cyBpbnRlZ2VycyBmcm9tIDAgdG8gdGhpcy5ncmlkLmRhdGFWaWV3Lmxlbmd0aFxuICAgICAqIEBwYXJhbSBhc0NoaWxkIC0gV2hldGhlciB0aGUgcmVjb3JkIHNob3VsZCBiZSBhZGRlZCBhcyBhIGNoaWxkLiBPbmx5IGFwcGxpY2FibGUgdG8gaWd4VHJlZUdyaWQuXG4gICAgICovXG4gICAgcHVibGljIGJlZ2luQWRkUm93QnlJbmRleChpbmRleDogbnVtYmVyLCBhc0NoaWxkPzogYm9vbGVhbik6IHZvaWQge1xuICAgICAgICBpZiAoaW5kZXggPT09IG51bGwgfHwgaW5kZXggPCAwKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5iZWdpbkFkZFJvd0J5SWQobnVsbCwgYXNDaGlsZCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX2FkZFJvd0ZvckluZGV4KGluZGV4IC0gMSwgYXNDaGlsZCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIHB1YmxpYyBnZXRDb250ZXh0KHJvd0RhdGE6IGFueSwgcm93SW5kZXg6IG51bWJlciwgcGlubmVkPzogYm9vbGVhbik6IGFueSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAkaW1wbGljaXQ6IHRoaXMuaXNHaG9zdFJlY29yZChyb3dEYXRhKSA/IHJvd0RhdGEucmVjb3JkUmVmIDogcm93RGF0YSxcbiAgICAgICAgICAgIGluZGV4OiB0aGlzLmdldERhdGFWaWV3SW5kZXgocm93SW5kZXgsIHBpbm5lZCksXG4gICAgICAgICAgICB0ZW1wbGF0ZUlEOiB7XG4gICAgICAgICAgICAgICAgdHlwZTogdGhpcy5pc1N1bW1hcnlSb3cocm93RGF0YSkgPyAnc3VtbWFyeVJvdycgOiAnZGF0YVJvdycsXG4gICAgICAgICAgICAgICAgaWQ6IG51bGxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBkaXNhYmxlZDogdGhpcy5pc0dob3N0UmVjb3JkKHJvd0RhdGEpID8gcm93RGF0YS5yZWNvcmRSZWYuaXNGaWx0ZXJlZE91dFBhcmVudCA9PT0gdW5kZWZpbmVkIDogZmFsc2VcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgcHVibGljIGdldEluaXRpYWxQaW5uZWRJbmRleChyZWMpIHtcbiAgICAgICAgY29uc3QgaWQgPSB0aGlzLmdyaWRBUEkuZ2V0X3Jvd19pZChyZWMpO1xuICAgICAgICByZXR1cm4gdGhpcy5fcGlubmVkUmVjb3JkSURzLmluZGV4T2YoaWQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICBwdWJsaWMgaXNSZWNvcmRQaW5uZWQocmVjKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldEluaXRpYWxQaW5uZWRJbmRleChyZWMuZGF0YSkgIT09IC0xO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBpbmhlcml0ZG9jXG4gICAgICovXG4gICAgcHVibGljIGdldFNlbGVjdGVkRGF0YShmb3JtYXR0ZXJzID0gZmFsc2UsIGhlYWRlcnMgPSBmYWxzZSk6IGFueVtdIHtcbiAgICAgICAgbGV0IHNvdXJjZSA9IFtdO1xuXG4gICAgICAgIGNvbnN0IHByb2Nlc3MgPSAocmVjb3JkKSA9PiB7XG4gICAgICAgICAgICBpZiAocmVjb3JkLnN1bW1hcmllcykge1xuICAgICAgICAgICAgICAgIHNvdXJjZS5wdXNoKG51bGwpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNvdXJjZS5wdXNoKHJlY29yZC5kYXRhKTtcbiAgICAgICAgfTtcblxuICAgICAgICB0aGlzLnVucGlubmVkRGF0YVZpZXcuZm9yRWFjaChwcm9jZXNzKTtcbiAgICAgICAgc291cmNlID0gdGhpcy5pc1Jvd1Bpbm5pbmdUb1RvcCA/IFsuLi50aGlzLnBpbm5lZERhdGFWaWV3LCAuLi5zb3VyY2VdIDogWy4uLnNvdXJjZSwgLi4udGhpcy5waW5uZWREYXRhVmlld107XG4gICAgICAgIHJldHVybiB0aGlzLmV4dHJhY3REYXRhRnJvbVNlbGVjdGlvbihzb3VyY2UsIGZvcm1hdHRlcnMsIGhlYWRlcnMpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW4gQGludGVybmFsXG4gICAgICovXG4gICAgcHVibGljIGdldEVtcHR5UmVjb3JkT2JqZWN0Rm9yKGluVHJlZVJvdzogUm93VHlwZSkge1xuICAgICAgICBjb25zdCB0cmVlUm93UmVjID0gaW5UcmVlUm93Py50cmVlUm93IHx8IG51bGw7XG4gICAgICAgIGNvbnN0IHJvdyA9IHsgLi4udHJlZVJvd1JlYyB9O1xuICAgICAgICBjb25zdCBkYXRhID0gdHJlZVJvd1JlYz8uZGF0YSB8fCB7fTtcbiAgICAgICAgcm93LmRhdGEgPSB7IC4uLmRhdGEgfTtcbiAgICAgICAgT2JqZWN0LmtleXMocm93LmRhdGEpLmZvckVhY2goa2V5ID0+IHtcbiAgICAgICAgICAgIC8vIHBlcnNpc3QgZm9yZWlnbiBrZXkgaWYgb25lIGlzIHNldC5cbiAgICAgICAgICAgIGlmICh0aGlzLmZvcmVpZ25LZXkgJiYga2V5ID09PSB0aGlzLmZvcmVpZ25LZXkpIHtcbiAgICAgICAgICAgICAgICByb3cuZGF0YVtrZXldID0gdHJlZVJvd1JlYy5kYXRhW2tleV07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJvdy5kYXRhW2tleV0gPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBsZXQgaWQgPSB0aGlzLmdlbmVyYXRlUm93SUQoKTtcbiAgICAgICAgY29uc3Qgcm9vdFJlY1BLID0gdGhpcy5mb3JlaWduS2V5ICYmIHRoaXMucm9vdFJlY29yZHMgJiYgdGhpcy5yb290UmVjb3Jkcy5sZW5ndGggPiAwID9cbiAgICAgICAgICAgIHRoaXMucm9vdFJlY29yZHNbMF0uZGF0YVt0aGlzLmZvcmVpZ25LZXldIDogbnVsbDtcbiAgICAgICAgaWYgKGlkID09PSByb290UmVjUEspIHtcbiAgICAgICAgICAgIC8vIHNhZmVndWFyZCBpbiBjYXNlIGdlbmVyYXRlZCBpZCBtYXRjaGVzIHRoZSByb290IGZvcmVpZ24ga2V5LlxuICAgICAgICAgICAgaWQgPSB0aGlzLmdlbmVyYXRlUm93SUQoKTtcbiAgICAgICAgfVxuICAgICAgICByb3cua2V5ID0gaWQ7XG4gICAgICAgIHJvdy5kYXRhW3RoaXMucHJpbWFyeUtleV0gPSBpZDtcbiAgICAgICAgcmV0dXJuIHsgcm93SUQ6IGlkLCBkYXRhOiByb3cuZGF0YSwgcmVjb3JkUmVmOiByb3cgfTtcbiAgICB9XG5cbiAgICAvKiogQGhpZGRlbiAqL1xuICAgIHB1YmxpYyBkZWxldGVSb3dCeUlkKHJvd0lkOiBhbnkpOiBhbnkge1xuICAgICAgICAvLyAgaWYgdGhpcyBpcyBmbGF0IHNlbGYtcmVmZXJlbmNpbmcgZGF0YSwgYW5kIENhc2NhZGVPbkRlbGV0ZSBpcyBzZXQgdG8gdHJ1ZVxuICAgICAgICAvLyAgYW5kIGlmIHdlIGhhdmUgdHJhbnNhY3Rpb25zIHdlIHNob3VsZCBzdGFydCBwZW5kaW5nIHRyYW5zYWN0aW9uLiBUaGlzIGFsbG93c1xuICAgICAgICAvLyAgdXMgaW4gY2FzZSBvZiBkZWxldGUgYWN0aW9uIHRvIGRlbGV0ZSBhbGwgY2hpbGQgcm93cyBhcyBzaW5nbGUgdW5kbyBhY3Rpb25cbiAgICAgICAgcmV0dXJuIHRoaXMuZ3JpZEFQSS5kZWxldGVSb3dCeUlkKHJvd0lkKTtcblxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGBJZ3hUcmVlR3JpZFJvd2AgYnkgaW5kZXguXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiBjb25zdCBteVJvdyA9IHRyZWVHcmlkLmdldFJvd0J5SW5kZXgoMSk7XG4gICAgICogYGBgXG4gICAgICogQHBhcmFtIGluZGV4XG4gICAgICovXG4gICAgcHVibGljIGdldFJvd0J5SW5kZXgoaW5kZXg6IG51bWJlcik6IFJvd1R5cGUge1xuICAgICAgICBpZiAoaW5kZXggPCAwIHx8IGluZGV4ID49IHRoaXMuZGF0YVZpZXcubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmNyZWF0ZVJvdyhpbmRleCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgYFJvd1R5cGVgIG9iamVjdCBieSB0aGUgc3BlY2lmaWVkIHByaW1hcnkga2V5LlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogY29uc3QgbXlSb3cgPSB0aGlzLnRyZWVHcmlkLmdldFJvd0J5SW5kZXgoMSk7XG4gICAgICogYGBgXG4gICAgICogQHBhcmFtIGluZGV4XG4gICAgICovXG4gICAgcHVibGljIGdldFJvd0J5S2V5KGtleTogYW55KTogUm93VHlwZSB7XG4gICAgICAgIGNvbnN0IHJlYyA9IHRoaXMuZmlsdGVyZWRTb3J0ZWREYXRhID8gdGhpcy5wcmltYXJ5S2V5ID8gdGhpcy5maWx0ZXJlZFNvcnRlZERhdGEuZmluZChyID0+IHJbdGhpcy5wcmltYXJ5S2V5XSA9PT0ga2V5KSA6XG4gICAgICAgICAgICB0aGlzLmZpbHRlcmVkU29ydGVkRGF0YS5maW5kKHIgPT4gciA9PT0ga2V5KSA6IHVuZGVmaW5lZDtcbiAgICAgICAgY29uc3QgaW5kZXggPSB0aGlzLmRhdGFWaWV3LmZpbmRJbmRleChyID0+IHIuZGF0YSAmJiByLmRhdGEgPT09IHJlYyk7XG4gICAgICAgIGlmIChpbmRleCA8IDAgfHwgaW5kZXggPj0gdGhpcy5maWx0ZXJlZFNvcnRlZERhdGEubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgSWd4VHJlZUdyaWRSb3codGhpcyBhcyBhbnksIGluZGV4LCByZWMpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGNvbGxlY3Rpb24gb2YgYWxsIFJvd1R5cGUgZm9yIGN1cnJlbnQgcGFnZS5cbiAgICAgKlxuICAgICAqIEBoaWRkZW4gQGludGVybmFsXG4gICAgICovXG4gICAgcHVibGljIGFsbFJvd3MoKTogUm93VHlwZVtdIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGF0YVZpZXcubWFwKChyZWMsIGluZGV4KSA9PiB0aGlzLmNyZWF0ZVJvdyhpbmRleCkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGNvbGxlY3Rpb24gb2YgYElneFRyZWVHcmlkUm93YHMgZm9yIGN1cnJlbnQgcGFnZS5cbiAgICAgKlxuICAgICAqIEBoaWRkZW4gQGludGVybmFsXG4gICAgICovXG4gICAgcHVibGljIGRhdGFSb3dzKCk6IFJvd1R5cGVbXSB7XG4gICAgICAgIHJldHVybiB0aGlzLmFsbFJvd3MoKS5maWx0ZXIocm93ID0+IHJvdyBpbnN0YW5jZW9mIElneFRyZWVHcmlkUm93KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGFuIGFycmF5IG9mIHRoZSBzZWxlY3RlZCBgSWd4R3JpZENlbGxgcy5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIGNvbnN0IHNlbGVjdGVkQ2VsbHMgPSB0aGlzLmdyaWQuc2VsZWN0ZWRDZWxscztcbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBwdWJsaWMgZ2V0IHNlbGVjdGVkQ2VsbHMoKTogQ2VsbFR5cGVbXSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRhdGFSb3dzKCkubWFwKChyb3cpID0+IHJvdy5jZWxscy5maWx0ZXIoKGNlbGwpID0+IGNlbGwuc2VsZWN0ZWQpKVxuICAgICAgICAgICAgLnJlZHVjZSgoYSwgYikgPT4gYS5jb25jYXQoYiksIFtdKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgYENlbGxUeXBlYCBvYmplY3QgdGhhdCBtYXRjaGVzIHRoZSBjb25kaXRpb25zLlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogY29uc3QgbXlDZWxsID0gdGhpcy5ncmlkMS5nZXRDZWxsQnlDb2x1bW4oMiwgXCJVbml0UHJpY2VcIik7XG4gICAgICogYGBgXG4gICAgICogQHBhcmFtIHJvd0luZGV4XG4gICAgICogQHBhcmFtIGNvbHVtbkZpZWxkXG4gICAgICovXG4gICAgcHVibGljIGdldENlbGxCeUNvbHVtbihyb3dJbmRleDogbnVtYmVyLCBjb2x1bW5GaWVsZDogc3RyaW5nKTogQ2VsbFR5cGUge1xuICAgICAgICBjb25zdCByb3cgPSB0aGlzLmdldFJvd0J5SW5kZXgocm93SW5kZXgpO1xuICAgICAgICBjb25zdCBjb2x1bW4gPSB0aGlzLmNvbHVtbkxpc3QuZmluZCgoY29sKSA9PiBjb2wuZmllbGQgPT09IGNvbHVtbkZpZWxkKTtcbiAgICAgICAgaWYgKHJvdyAmJiByb3cgaW5zdGFuY2VvZiBJZ3hUcmVlR3JpZFJvdyAmJiBjb2x1bW4pIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgSWd4R3JpZENlbGwodGhpcyBhcyBhbnksIHJvd0luZGV4LCBjb2x1bW5GaWVsZCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgYENlbGxUeXBlYCBvYmplY3QgdGhhdCBtYXRjaGVzIHRoZSBjb25kaXRpb25zLlxuICAgICAqXG4gICAgICogQHJlbWFya3NcbiAgICAgKiBSZXF1aXJlcyB0aGF0IHRoZSBwcmltYXJ5S2V5IHByb3BlcnR5IGlzIHNldC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiBncmlkLmdldENlbGxCeUtleSgxLCAnaW5kZXgnKTtcbiAgICAgKiBgYGBcbiAgICAgKiBAcGFyYW0gcm93U2VsZWN0b3IgbWF0Y2ggYW55IHJvd0lEXG4gICAgICogQHBhcmFtIGNvbHVtbkZpZWxkXG4gICAgICovXG4gICAgcHVibGljIGdldENlbGxCeUtleShyb3dTZWxlY3RvcjogYW55LCBjb2x1bW5GaWVsZDogc3RyaW5nKTogQ2VsbFR5cGUge1xuICAgICAgICBjb25zdCByb3cgPSB0aGlzLmdldFJvd0J5S2V5KHJvd1NlbGVjdG9yKTtcbiAgICAgICAgY29uc3QgY29sdW1uID0gdGhpcy5jb2x1bW5MaXN0LmZpbmQoKGNvbCkgPT4gY29sLmZpZWxkID09PSBjb2x1bW5GaWVsZCk7XG4gICAgICAgIGlmIChyb3cgJiYgY29sdW1uKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IElneEdyaWRDZWxsKHRoaXMgYXMgYW55LCByb3cuaW5kZXgsIGNvbHVtbkZpZWxkKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHB1YmxpYyBwaW5Sb3cocm93SUQ6IGFueSwgaW5kZXg/OiBudW1iZXIpOiBib29sZWFuIHtcbiAgICAgICAgY29uc3Qgcm93ID0gdGhpcy5nZXRSb3dCeUtleShyb3dJRCk7XG4gICAgICAgIHJldHVybiBzdXBlci5waW5Sb3cocm93SUQsIGluZGV4LCByb3cpO1xuICAgIH1cblxuICAgIHB1YmxpYyB1bnBpblJvdyhyb3dJRDogYW55KTogYm9vbGVhbiB7XG4gICAgICAgIGNvbnN0IHJvdyA9IHRoaXMuZ2V0Um93QnlLZXkocm93SUQpO1xuICAgICAgICByZXR1cm4gc3VwZXIudW5waW5Sb3cocm93SUQsIHJvdyk7XG4gICAgfVxuXG4gICAgLyoqIEBoaWRkZW4gKi9cbiAgICBwdWJsaWMgZ2VuZXJhdGVSb3dQYXRoKHJvd0lkOiBhbnkpOiBhbnlbXSB7XG4gICAgICAgIGNvbnN0IHBhdGg6IGFueVtdID0gW107XG4gICAgICAgIGxldCByZWNvcmQgPSB0aGlzLnJlY29yZHMuZ2V0KHJvd0lkKTtcblxuICAgICAgICB3aGlsZSAocmVjb3JkLnBhcmVudCkge1xuICAgICAgICAgICAgcGF0aC5wdXNoKHJlY29yZC5wYXJlbnQua2V5KTtcbiAgICAgICAgICAgIHJlY29yZCA9IHJlY29yZC5wYXJlbnQ7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcGF0aC5yZXZlcnNlKCk7XG4gICAgfVxuXG4gICAgLyoqIEBoaWRkZW4gKi9cbiAgICBwdWJsaWMgaXNUcmVlUm93KHJlY29yZDogYW55KTogYm9vbGVhbiB7XG4gICAgICAgIHJldHVybiByZWNvcmQua2V5ICE9PSB1bmRlZmluZWQgJiYgcmVjb3JkLmRhdGE7XG4gICAgfVxuXG4gICAgLyoqIEBoaWRkZW4gKi9cbiAgICBwdWJsaWMgZ2V0VW5waW5uZWRJbmRleEJ5SWQoaWQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudW5waW5uZWRSZWNvcmRzLmZpbmRJbmRleCh4ID0+IHguZGF0YVt0aGlzLnByaW1hcnlLZXldID09PSBpZCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIHB1YmxpYyBjcmVhdGVSb3coaW5kZXg6IG51bWJlciwgZGF0YT86IGFueSk6IFJvd1R5cGUge1xuICAgICAgICBsZXQgcm93OiBSb3dUeXBlO1xuICAgICAgICBjb25zdCBkYXRhSW5kZXggPSB0aGlzLl9nZXREYXRhVmlld0luZGV4KGluZGV4KTtcbiAgICAgICAgY29uc3QgcmVjOiBhbnkgPSBkYXRhID8/IHRoaXMuZGF0YVZpZXdbZGF0YUluZGV4XTtcblxuICAgICAgICBpZiAodGhpcy5pc1N1bW1hcnlSb3cocmVjKSkge1xuICAgICAgICAgICAgcm93ID0gbmV3IElneFN1bW1hcnlSb3codGhpcyBhcyBhbnksIGluZGV4LCByZWMuc3VtbWFyaWVzLCBHcmlkSW5zdGFuY2VUeXBlLlRyZWVHcmlkKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghcm93ICYmIHJlYykge1xuICAgICAgICAgICAgY29uc3QgaXNUcmVlUm93ID0gdGhpcy5pc1RyZWVSb3cocmVjKTtcbiAgICAgICAgICAgIGNvbnN0IGRhdGFSZWMgPSBpc1RyZWVSb3cgPyByZWMuZGF0YSA6IHJlYztcbiAgICAgICAgICAgIGNvbnN0IHRyZWVSb3cgPSBpc1RyZWVSb3cgPyByZWMgOiB1bmRlZmluZWQ7XG4gICAgICAgICAgICByb3cgPSBuZXcgSWd4VHJlZUdyaWRSb3codGhpcyBhcyBhbnksIGluZGV4LCBkYXRhUmVjLCB0cmVlUm93KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByb3c7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBpZiB0aGUgYElneFRyZWVHcmlkQ29tcG9uZW50YCBoYXMgZ3JvdXBhYmxlIGNvbHVtbnMuXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiBjb25zdCBncm91cGFibGVHcmlkID0gdGhpcy5ncmlkLmhhc0dyb3VwYWJsZUNvbHVtbnM7XG4gICAgICogYGBgXG4gICAgICovXG4gICAgcHVibGljIGdldCBoYXNHcm91cGFibGVDb2x1bW5zKCk6IGJvb2xlYW4ge1xuICAgICAgICByZXR1cm4gdGhpcy5jb2x1bW5MaXN0LnNvbWUoKGNvbCkgPT4gY29sLmdyb3VwYWJsZSAmJiAhY29sLmNvbHVtbkdyb3VwKTtcbiAgICB9XG5cbiAgICBwcm90ZWN0ZWQgZ2VuZXJhdGVEYXRhRmllbGRzKGRhdGE6IGFueVtdKTogc3RyaW5nW10ge1xuICAgICAgICByZXR1cm4gc3VwZXIuZ2VuZXJhdGVEYXRhRmllbGRzKGRhdGEpLmZpbHRlcihmaWVsZCA9PiBmaWVsZCAhPT0gdGhpcy5jaGlsZERhdGFLZXkpO1xuICAgIH1cblxuICAgIHByb3RlY3RlZCB0cmFuc2FjdGlvblN0YXR1c1VwZGF0ZShldmVudDogU3RhdGVVcGRhdGVFdmVudCkge1xuICAgICAgICBsZXQgYWN0aW9ucyA9IFtdO1xuICAgICAgICBpZiAoZXZlbnQub3JpZ2luID09PSBUcmFuc2FjdGlvbkV2ZW50T3JpZ2luLlJFRE8pIHtcbiAgICAgICAgICAgIGFjdGlvbnMgPSBldmVudC5hY3Rpb25zID8gZXZlbnQuYWN0aW9ucy5maWx0ZXIoeCA9PiB4LnRyYW5zYWN0aW9uLnR5cGUgPT09IFRyYW5zYWN0aW9uVHlwZS5ERUxFVEUpIDogW107XG4gICAgICAgICAgICBpZiAodGhpcy5yb3dTZWxlY3Rpb24gPT09IEdyaWRTZWxlY3Rpb25Nb2RlLm11bHRpcGxlQ2FzY2FkZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuaGFuZGxlQ2FzY2FkZVNlbGVjdGlvbihldmVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoZXZlbnQub3JpZ2luID09PSBUcmFuc2FjdGlvbkV2ZW50T3JpZ2luLlVORE8pIHtcbiAgICAgICAgICAgIGFjdGlvbnMgPSBldmVudC5hY3Rpb25zID8gZXZlbnQuYWN0aW9ucy5maWx0ZXIoeCA9PiB4LnRyYW5zYWN0aW9uLnR5cGUgPT09IFRyYW5zYWN0aW9uVHlwZS5BREQpIDogW107XG4gICAgICAgICAgICBpZiAodGhpcy5yb3dTZWxlY3Rpb24gPT09IEdyaWRTZWxlY3Rpb25Nb2RlLm11bHRpcGxlQ2FzY2FkZSkge1xuICAgICAgICAgICAgICAgIGlmIChldmVudC5hY3Rpb25zWzBdLnRyYW5zYWN0aW9uLnR5cGUgPT09ICdhZGQnKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlYyA9IHRoaXMuZ3JpZEFQSS5nZXRfcmVjX2J5X2lkKGV2ZW50LmFjdGlvbnNbMF0udHJhbnNhY3Rpb24uaWQpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmhhbmRsZUNhc2NhZGVTZWxlY3Rpb24oZXZlbnQsIHJlYyk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5oYW5kbGVDYXNjYWRlU2VsZWN0aW9uKGV2ZW50KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGFjdGlvbnMubGVuZ3RoKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGFjdGlvbiBvZiBhY3Rpb25zKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5kZXNlbGVjdENoaWxkcmVuKGFjdGlvbi50cmFuc2FjdGlvbi5pZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgc3VwZXIudHJhbnNhY3Rpb25TdGF0dXNVcGRhdGUoZXZlbnQpO1xuICAgIH07XG5cbiAgICBwcm90ZWN0ZWQgZmluZFJlY29yZEluZGV4SW5WaWV3KHJlYykge1xuICAgICAgICByZXR1cm4gdGhpcy5kYXRhVmlldy5maW5kSW5kZXgoeCA9PiB4LmRhdGFbdGhpcy5wcmltYXJ5S2V5XSA9PT0gcmVjW3RoaXMucHJpbWFyeUtleV0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW4gQGludGVybmFsXG4gICAgICovXG4gICAgcHJvdGVjdGVkIGdldERhdGFCYXNlZEJvZHlIZWlnaHQoKTogbnVtYmVyIHtcbiAgICAgICAgcmV0dXJuICF0aGlzLmZsYXREYXRhIHx8ICh0aGlzLmZsYXREYXRhLmxlbmd0aCA8IHRoaXMuX2RlZmF1bHRUYXJnZXRSZWNvcmROdW1iZXIpID9cbiAgICAgICAgICAgIDAgOiB0aGlzLmRlZmF1bHRUYXJnZXRCb2R5SGVpZ2h0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBwcm90ZWN0ZWQgc2Nyb2xsVG8ocm93OiBhbnkgfCBudW1iZXIsIGNvbHVtbjogYW55IHwgbnVtYmVyKTogdm9pZCB7XG4gICAgICAgIGxldCBkZWxheVNjcm9sbGluZyA9IGZhbHNlO1xuICAgICAgICBsZXQgcmVjb3JkOiBJVHJlZUdyaWRSZWNvcmQ7XG5cbiAgICAgICAgaWYgKHR5cGVvZiAocm93KSAhPT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIGNvbnN0IHJvd0RhdGEgPSByb3c7XG4gICAgICAgICAgICBjb25zdCByb3dJRCA9IHRoaXMuZ3JpZEFQSS5nZXRfcm93X2lkKHJvd0RhdGEpO1xuICAgICAgICAgICAgcmVjb3JkID0gdGhpcy5wcm9jZXNzZWRSZWNvcmRzLmdldChyb3dJRCk7XG4gICAgICAgICAgICB0aGlzLmdyaWRBUEkuZXhwYW5kX3BhdGhfdG9fcmVjb3JkKHJlY29yZCk7XG5cbiAgICAgICAgICAgIGlmICh0aGlzLnBhZ2luYXRvcikge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJvd0luZGV4ID0gdGhpcy5wcm9jZXNzZWRFeHBhbmRlZEZsYXREYXRhLmluZGV4T2Yocm93RGF0YSk7XG4gICAgICAgICAgICAgICAgY29uc3QgcGFnZSA9IE1hdGguZmxvb3Iocm93SW5kZXggLyB0aGlzLnBhZ2luYXRvci5wZXJQYWdlKTtcblxuICAgICAgICAgICAgICAgIGlmICh0aGlzLnBhZ2luYXRvci5wYWdlICE9PSBwYWdlKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlbGF5U2Nyb2xsaW5nID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wYWdpbmF0b3IucGFnZSA9IHBhZ2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGRlbGF5U2Nyb2xsaW5nKSB7XG4gICAgICAgICAgICB0aGlzLnZlcnRpY2FsU2Nyb2xsQ29udGFpbmVyLmRhdGFDaGFuZ2VkLnBpcGUoZmlyc3QoKSkuc3Vic2NyaWJlKCgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLnNjcm9sbERpcmVjdGl2ZSh0aGlzLnZlcnRpY2FsU2Nyb2xsQ29udGFpbmVyLFxuICAgICAgICAgICAgICAgICAgICB0eXBlb2YgKHJvdykgPT09ICdudW1iZXInID8gcm93IDogdGhpcy51bnBpbm5lZERhdGFWaWV3LmluZGV4T2YocmVjb3JkKSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuc2Nyb2xsRGlyZWN0aXZlKHRoaXMudmVydGljYWxTY3JvbGxDb250YWluZXIsXG4gICAgICAgICAgICAgICAgdHlwZW9mIChyb3cpID09PSAnbnVtYmVyJyA/IHJvdyA6IHRoaXMudW5waW5uZWREYXRhVmlldy5pbmRleE9mKHJlY29yZCkpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5zY3JvbGxUb0hvcml6b250YWxseShjb2x1bW4pO1xuICAgIH1cblxuICAgIHByb3RlY3RlZCB3cml0ZVRvRGF0YShyb3dJbmRleDogbnVtYmVyLCB2YWx1ZTogYW55KSB7XG4gICAgICAgIG1lcmdlT2JqZWN0cyh0aGlzLmZsYXREYXRhW3Jvd0luZGV4XSwgdmFsdWUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBwcm90ZWN0ZWQgaW5pdENvbHVtbnMoY29sbGVjdGlvbjogUXVlcnlMaXN0PElneENvbHVtbkNvbXBvbmVudD4sIGNiOiAoYXJnczogYW55KSA9PiB2b2lkID0gbnVsbCkge1xuICAgICAgICBpZiAodGhpcy5oYXNDb2x1bW5MYXlvdXRzKSB7XG4gICAgICAgICAgICAvLyBpbnZhbGlkIGNvbmZpZ3VyYXRpb24gLSB0cmVlIGdyaWQgc2hvdWxkIG5vdCBhbGxvdyBjb2x1bW4gbGF5b3V0c1xuICAgICAgICAgICAgLy8gcmVtb3ZlIGNvbHVtbiBsYXlvdXRzXG4gICAgICAgICAgICBjb25zdCBub25Db2x1bW5MYXlvdXRDb2x1bW5zID0gdGhpcy5jb2x1bW5MaXN0LmZpbHRlcigoY29sKSA9PiAhY29sLmNvbHVtbkxheW91dCAmJiAhY29sLmNvbHVtbkxheW91dENoaWxkKTtcbiAgICAgICAgICAgIHRoaXMuY29sdW1uTGlzdC5yZXNldChub25Db2x1bW5MYXlvdXRDb2x1bW5zKTtcbiAgICAgICAgfVxuICAgICAgICBzdXBlci5pbml0Q29sdW1ucyhjb2xsZWN0aW9uLCBjYik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGhpZGRlbiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICBwcm90ZWN0ZWQgZ2V0R3JvdXBBcmVhSGVpZ2h0KCk6IG51bWJlciB7XG4gICAgICAgIHJldHVybiB0aGlzLnRyZWVHcm91cEFyZWEgPyB0aGlzLmdldENvbXB1dGVkSGVpZ2h0KHRoaXMudHJlZUdyb3VwQXJlYS5uYXRpdmVFbGVtZW50KSA6IDA7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGRlc2NyaXB0aW9uIEEgcmVjdXJzaXZlIHdheSB0byBkZXNlbGVjdCBhbGwgc2VsZWN0ZWQgY2hpbGRyZW4gb2YgYSBnaXZlbiByZWNvcmRcbiAgICAgKiBAcGFyYW0gcmVjb3JkSUQgSUQgb2YgdGhlIHJlY29yZCB3aG9zZSBjaGlsZHJlbiB0byBkZXNlbGVjdFxuICAgICAqIEBoaWRkZW5cbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICBwcml2YXRlIGRlc2VsZWN0Q2hpbGRyZW4ocmVjb3JkSUQpOiB2b2lkIHtcbiAgICAgICAgY29uc3Qgc2VsZWN0ZWRDaGlsZHJlbiA9IFtdO1xuICAgICAgICAvLyBHLkUuIEFwciAyOCwgMjAyMSAjOTQ2NSBSZWNvcmRzIHdoaWNoIGFyZSBub3QgaW4gdmlldyBjYW4gYWxzbyBiZSBzZWxlY3RlZCBzbyB3ZSBuZWVkIHRvXG4gICAgICAgIC8vIGRlc2VsZWN0IHRoZW0gYXMgd2VsbCwgaGVuY2UgdXNpbmcgJ3JlY29yZHMnIG1hcCBpbnN0ZWFkIG9mIGdldFJvd0J5S2V5KCkgbWV0aG9kIHdoaWNoIHdpbGxcbiAgICAgICAgLy8gcmV0dXJuIG9ubHkgcm93IGNvbXBvbmVudHMgKGkuZS4gcmVjb3JkcyBpbiB2aWV3KS5cbiAgICAgICAgY29uc3Qgcm93VG9EZXNlbGVjdCA9IHRoaXMucmVjb3Jkcy5nZXQocmVjb3JkSUQpO1xuICAgICAgICB0aGlzLnNlbGVjdGlvblNlcnZpY2UuZGVzZWxlY3RSb3cocmVjb3JkSUQpO1xuICAgICAgICB0aGlzLmdyaWRBUEkuZ2V0X3NlbGVjdGVkX2NoaWxkcmVuKHJvd1RvRGVzZWxlY3QsIHNlbGVjdGVkQ2hpbGRyZW4pO1xuICAgICAgICBpZiAoc2VsZWN0ZWRDaGlsZHJlbi5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBzZWxlY3RlZENoaWxkcmVuLmZvckVhY2goeCA9PiB0aGlzLmRlc2VsZWN0Q2hpbGRyZW4oeCkpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBhZGRDaGlsZFJvd3MoY2hpbGRyZW46IGFueVtdLCBwYXJlbnRJRDogYW55KSB7XG4gICAgICAgIGlmICh0aGlzLnByaW1hcnlLZXkgJiYgdGhpcy5mb3JlaWduS2V5KSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGNoaWxkIG9mIGNoaWxkcmVuKSB7XG4gICAgICAgICAgICAgICAgY2hpbGRbdGhpcy5mb3JlaWduS2V5XSA9IHBhcmVudElEO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5kYXRhLnB1c2goLi4uY2hpbGRyZW4pO1xuICAgICAgICB9IGVsc2UgaWYgKHRoaXMuY2hpbGREYXRhS2V5KSB7XG4gICAgICAgICAgICBsZXQgcGFyZW50ID0gdGhpcy5yZWNvcmRzLmdldChwYXJlbnRJRCk7XG4gICAgICAgICAgICBsZXQgcGFyZW50RGF0YSA9IHBhcmVudC5kYXRhO1xuXG4gICAgICAgICAgICBpZiAodGhpcy50cmFuc2FjdGlvbnMuZW5hYmxlZCAmJiB0aGlzLnRyYW5zYWN0aW9ucy5nZXRBZ2dyZWdhdGVkQ2hhbmdlcyh0cnVlKS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBwYXRoID0gW107XG4gICAgICAgICAgICAgICAgd2hpbGUgKHBhcmVudCkge1xuICAgICAgICAgICAgICAgICAgICBwYXRoLnB1c2gocGFyZW50LmtleSk7XG4gICAgICAgICAgICAgICAgICAgIHBhcmVudCA9IHBhcmVudC5wYXJlbnQ7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgbGV0IGNvbGxlY3Rpb24gPSB0aGlzLmRhdGE7XG4gICAgICAgICAgICAgICAgbGV0IHJlY29yZDogYW55O1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSBwYXRoLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHBpZCA9IHBhdGhbaV07XG4gICAgICAgICAgICAgICAgICAgIHJlY29yZCA9IGNvbGxlY3Rpb24uZmluZChyID0+IHJbdGhpcy5wcmltYXJ5S2V5XSA9PT0gcGlkKTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoIXJlY29yZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY29sbGVjdGlvbiA9IHJlY29yZFt0aGlzLmNoaWxkRGF0YUtleV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChyZWNvcmQpIHtcbiAgICAgICAgICAgICAgICAgICAgcGFyZW50RGF0YSA9IHJlY29yZDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHBhcmVudERhdGFbdGhpcy5jaGlsZERhdGFLZXldID0gY2hpbGRyZW47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zZWxlY3Rpb25TZXJ2aWNlLmNsZWFySGVhZGVyQ0JTdGF0ZSgpO1xuICAgICAgICB0aGlzLnBpcGVUcmlnZ2VyKys7XG4gICAgICAgIGlmICh0aGlzLnJvd1NlbGVjdGlvbiA9PT0gR3JpZFNlbGVjdGlvbk1vZGUubXVsdGlwbGVDYXNjYWRlKSB7XG4gICAgICAgICAgICAvLyBGb3JjZSBwaXBlIHRyaWdnZXJpbmcgZm9yIGJ1aWxkaW5nIHRoZSBkYXRhIHN0cnVjdHVyZVxuICAgICAgICAgICAgdGhpcy5jZHIuZGV0ZWN0Q2hhbmdlcygpO1xuICAgICAgICAgICAgaWYgKHRoaXMuc2VsZWN0aW9uU2VydmljZS5pc1Jvd1NlbGVjdGVkKHBhcmVudElEKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuc2VsZWN0aW9uU2VydmljZS5yb3dTZWxlY3Rpb24uZGVsZXRlKHBhcmVudElEKTtcbiAgICAgICAgICAgICAgICB0aGlzLnNlbGVjdGlvblNlcnZpY2Uuc2VsZWN0Um93c1dpdGhOb0V2ZW50KFtwYXJlbnRJRF0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBsb2FkQ2hpbGRyZW5PblJvd0V4cGFuc2lvbihhcmdzOiBJUm93VG9nZ2xlRXZlbnRBcmdzKSB7XG4gICAgICAgIGlmICh0aGlzLmxvYWRDaGlsZHJlbk9uRGVtYW5kKSB7XG4gICAgICAgICAgICBjb25zdCBwYXJlbnRJRCA9IGFyZ3Mucm93SUQ7XG5cbiAgICAgICAgICAgIGlmIChhcmdzLmV4cGFuZGVkICYmICF0aGlzLl9leHBhbnNpb25TdGF0ZXMuaGFzKHBhcmVudElEKSkge1xuICAgICAgICAgICAgICAgIHRoaXMubG9hZGluZ1Jvd3MuYWRkKHBhcmVudElEKTtcblxuICAgICAgICAgICAgICAgIHRoaXMubG9hZENoaWxkcmVuT25EZW1hbmQocGFyZW50SUQsIGNoaWxkcmVuID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5sb2FkaW5nUm93cy5kZWxldGUocGFyZW50SUQpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmFkZENoaWxkUm93cyhjaGlsZHJlbiwgcGFyZW50SUQpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm5vdGlmeUNoYW5nZXMoKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHByaXZhdGUgaGFuZGxlQ2FzY2FkZVNlbGVjdGlvbihldmVudDogSVJvd0RhdGFFdmVudEFyZ3MgfCBTdGF0ZVVwZGF0ZUV2ZW50LCByZWM6IElUcmVlR3JpZFJlY29yZCA9IG51bGwpIHtcbiAgICAgICAgLy8gV2FpdCBmb3IgdGhlIGNoYW5nZSBkZXRlY3Rpb24gdG8gdXBkYXRlIHJlY29yZHMgdGhyb3VnaCB0aGUgcGlwZXNcbiAgICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcbiAgICAgICAgICAgIGlmIChyZWMgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZWMgPSB0aGlzLmdyaWRBUEkuZ2V0X3JlY19ieV9pZCgoZXZlbnQgYXMgU3RhdGVVcGRhdGVFdmVudCkuYWN0aW9uc1swXS50cmFuc2FjdGlvbi5pZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocmVjICYmIHJlYy5wYXJlbnQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmdyaWRBUEkuZ3JpZC5zZWxlY3Rpb25TZXJ2aWNlLnVwZGF0ZUNhc2NhZGVTZWxlY3Rpb25PbkZpbHRlckFuZENSVUQoXG4gICAgICAgICAgICAgICAgICAgIG5ldyBTZXQoW3JlYy5wYXJlbnRdKSwgcmVjLnBhcmVudC5rZXlcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIHRoaXMubm90aWZ5Q2hhbmdlcygpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG59XG4iLCI8bmctY29udGVudCBzZWxlY3Q9XCJpZ3gtZ3JpZC10b29sYmFyXCI+PC9uZy1jb250ZW50PlxuPG5nLWNvbnRlbnQgc2VsZWN0PVwiaWd4LXRyZWUtZ3JpZC1ncm91cC1ieS1hcmVhXCI+PC9uZy1jb250ZW50PlxuPGlneC1ncmlkLWhlYWRlci1yb3cgY2xhc3M9XCJpZ3gtZ3JpZC10aGVhZFwiIHRhYmluZGV4PVwiMFwiXG4gICAgW2dyaWRdPVwidGhpc1wiXG4gICAgW2hhc01STF09XCJoYXNDb2x1bW5MYXlvdXRzXCJcbiAgICBbYWN0aXZlRGVzY2VuZGFudF09XCJhY3RpdmVEZXNjZW5kYW50XCJcbiAgICBbd2lkdGhdPVwiY2FsY1dpZHRoXCJcbiAgICBbcGlubmVkQ29sdW1uQ29sbGVjdGlvbl09XCJwaW5uZWRDb2x1bW5zXCJcbiAgICBbdW5waW5uZWRDb2x1bW5Db2xsZWN0aW9uXT1cInVucGlubmVkQ29sdW1uc1wiXG4gICAgKGtleWRvd24ubWV0YS5jKT1cImNvcHlIYW5kbGVyKCRldmVudClcIlxuICAgIChrZXlkb3duLmNvbnRyb2wuYyk9XCJjb3B5SGFuZGxlcigkZXZlbnQpXCJcbiAgICAoY29weSk9XCJjb3B5SGFuZGxlcigkZXZlbnQpXCJcbiAgICAoa2V5ZG93bik9XCJuYXZpZ2F0aW9uLmhlYWRlck5hdmlnYXRpb24oJGV2ZW50KVwiXG4gICAgKGZvY3VzKT1cIm5hdmlnYXRpb24uZm9jdXNGaXJzdENlbGwoKVwiXG4+XG48L2lneC1ncmlkLWhlYWRlci1yb3c+XG5cbjxkaXYgaWd4R3JpZEJvZHkgKGtleWRvd24uY29udHJvbC5jKT1cImNvcHlIYW5kbGVyKCRldmVudClcIiAoY29weSk9XCJjb3B5SGFuZGxlcigkZXZlbnQpXCIgY2xhc3M9XCJpZ3gtZ3JpZF9fdGJvZHlcIiByb2xlPVwicm93Z3JvdXBcIj5cbiAgICA8ZGl2IGNsYXNzPVwiaWd4LWdyaWRfX3Rib2R5LWNvbnRlbnRcIiAgdGFiaW5kZXg9XCIwXCIgKGZvY3VzKT1cIm5hdmlnYXRpb24uZm9jdXNUYm9keSgkZXZlbnQpXCIgKGtleWRvd24pPVwibmF2aWdhdGlvbi5oYW5kbGVOYXZpZ2F0aW9uKCRldmVudClcIlxuICAgIChkcmFnU3RvcCk9XCJzZWxlY3Rpb25TZXJ2aWNlLmRyYWdNb2RlID0gJGV2ZW50XCIgW2F0dHIuYXJpYS1hY3RpdmVkZXNjZW5kYW50XT1cImFjdGl2ZURlc2NlbmRhbnRcIiBbYXR0ci5yb2xlXT1cImRhdGFWaWV3Lmxlbmd0aCA/IG51bGwgOiAncm93J1wiXG4gICAgICAgIChkcmFnU2Nyb2xsKT1cImRyYWdTY3JvbGwoJGV2ZW50KVwiIFtpZ3hHcmlkRHJhZ1NlbGVjdF09XCJzZWxlY3Rpb25TZXJ2aWNlLmRyYWdNb2RlXCJcbiAgICAgICAgW3N0eWxlLmhlaWdodC5weF09J3RvdGFsSGVpZ2h0JyBbc3R5bGUud2lkdGgucHhdPSdjYWxjV2lkdGgnICN0Ym9keSAoc2Nyb2xsKT0ncHJldmVudENvbnRhaW5lclNjcm9sbCgkZXZlbnQpJz5cbiAgICAgICAgPHNwYW4gKm5nSWY9XCJtb3ZpbmcgJiYgY29sdW1uSW5EcmFnICYmIHBpbm5lZENvbHVtbnMubGVuZ3RoIDw9IDBcIlxuICAgICAgICAgICAgW2lneENvbHVtbk1vdmluZ0Ryb3BdPVwiaGVhZGVyQ29udGFpbmVyXCIgW2F0dHIuZHJvcHBhYmxlXT1cInRydWVcIiBpZD1cImxlZnRcIlxuICAgICAgICAgICAgY2xhc3M9XCJpZ3gtZ3JpZF9fc2Nyb2xsLW9uLWRyYWctbGVmdFwiPjwvc3Bhbj5cbiAgICAgICAgPHNwYW4gKm5nSWY9XCJtb3ZpbmcgJiYgY29sdW1uSW5EcmFnICYmIHBpbm5lZENvbHVtbnMubGVuZ3RoID4gMFwiXG4gICAgICAgICAgICBbaWd4Q29sdW1uTW92aW5nRHJvcF09XCJoZWFkZXJDb250YWluZXJcIiBbYXR0ci5kcm9wcGFibGVdPVwidHJ1ZVwiIGlkPVwibGVmdFwiXG4gICAgICAgICAgICBjbGFzcz1cImlneC1ncmlkX19zY3JvbGwtb24tZHJhZy1waW5uZWRcIiBbc3R5bGUubGVmdC5weF09XCJwaW5uZWRXaWR0aFwiPjwvc3Bhbj5cbiAgICAgICAgPG5nLXRlbXBsYXRlICNwaW5uZWRSZWNvcmRzVGVtcGxhdGU+XG4gICAgICAgICAgICA8bmctY29udGFpbmVyICpuZ0lmPSdkYXRhXG4gICAgICAgICAgICB8IHRyZWVHcmlkVHJhbnNhY3Rpb246cGlwZVRyaWdnZXJcbiAgICAgICAgICAgIHwgdmlzaWJsZUNvbHVtbnM6aGFzVmlzaWJsZUNvbHVtbnNcbiAgICAgICAgICAgIHwgdHJlZUdyaWROb3JtYWxpemVSZWNvcmQ6cGlwZVRyaWdnZXJcbiAgICAgICAgICAgIHwgdHJlZUdyaWRBZGRSb3c6dHJ1ZTpwaXBlVHJpZ2dlclxuICAgICAgICAgICAgfCBncmlkUm93UGlubmluZzppZDp0cnVlOnBpcGVUcmlnZ2VyXG4gICAgICAgICAgICB8IHRyZWVHcmlkRmlsdGVyaW5nOmZpbHRlcmluZ0V4cHJlc3Npb25zVHJlZTpmaWx0ZXJTdHJhdGVneTphZHZhbmNlZEZpbHRlcmluZ0V4cHJlc3Npb25zVHJlZTpwaXBlVHJpZ2dlcjpmaWx0ZXJpbmdQaXBlVHJpZ2dlcjp0cnVlXG4gICAgICAgICAgICB8IHRyZWVHcmlkU29ydGluZzpzb3J0aW5nRXhwcmVzc2lvbnM6dHJlZUdyb3VwQXJlYT8uZXhwcmVzc2lvbnM6c29ydFN0cmF0ZWd5OnBpcGVUcmlnZ2VyOnRydWUgYXMgcGlubmVkRGF0YSc+XG4gICAgICAgICAgICAgICAgPGRpdiAjcGluQ29udGFpbmVyICpuZ0lmPSdwaW5uZWREYXRhLmxlbmd0aCA+IDAnXG4gICAgICAgICAgICAgICAgICAgIFtuZ0NsYXNzXT1cIntcbiAgICAgICAgICAgICAgICAgICAgICAgICdpZ3gtZ3JpZF9fdHItLXBpbm5lZC1ib3R0b20nOiAgIWlzUm93UGlubmluZ1RvVG9wLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2lneC1ncmlkX190ci0tcGlubmVkLXRvcCc6IGlzUm93UGlubmluZ1RvVG9wXG4gICAgICAgICAgICAgICAgICAgIH1cIlxuICAgICAgICAgICAgICAgICAgICBjbGFzcz0naWd4LWdyaWRfX3RyLS1waW5uZWQnIFtzdHlsZS53aWR0aC5weF09J2NhbGNXaWR0aCc+XG4gICAgICAgICAgICAgICAgICAgIDxuZy1jb250YWluZXIgKm5nRm9yPVwibGV0IHJvd0RhdGEgb2YgcGlubmVkRGF0YTtsZXQgcm93SW5kZXggPSBpbmRleDtcIj5cbiAgICAgICAgICAgICAgICAgICAgICAgIDxuZy1jb250YWluZXIgKm5nVGVtcGxhdGVPdXRsZXQ9XCJwaW5uZWRfcmVjb3JkX3RlbXBsYXRlOyBjb250ZXh0OiBnZXRDb250ZXh0KHJvd0RhdGEsIHJvd0luZGV4LCB0cnVlKVwiPlxuICAgICAgICAgICAgICAgICAgICAgICAgPC9uZy1jb250YWluZXI+XG4gICAgICAgICAgICAgICAgICAgIDwvbmctY29udGFpbmVyPlxuICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgPC9uZy1jb250YWluZXI+XG4gICAgICAgIDwvbmctdGVtcGxhdGU+XG4gICAgICAgIDxuZy1jb250YWluZXIgKm5nVGVtcGxhdGVPdXRsZXQ9XCJoYXNQaW5uZWRSZWNvcmRzICYmIGlzUm93UGlubmluZ1RvVG9wID8gcGlubmVkUmVjb3Jkc1RlbXBsYXRlIDogbnVsbFwiPjwvbmctY29udGFpbmVyPlxuICAgICAgICA8bmctdGVtcGxhdGUgaWd4R3JpZEZvciBsZXQtcm93RGF0YSBbaWd4R3JpZEZvck9mXT1cImRhdGFcbiAgICAgICAgfCB0cmVlR3JpZFRyYW5zYWN0aW9uOnBpcGVUcmlnZ2VyXG4gICAgICAgIHwgdmlzaWJsZUNvbHVtbnM6aGFzVmlzaWJsZUNvbHVtbnNcbiAgICAgICAgfCB0cmVlR3JpZEhpZXJhcmNoaXppbmc6cHJpbWFyeUtleTpmb3JlaWduS2V5OmNoaWxkRGF0YUtleTpwaXBlVHJpZ2dlclxuICAgICAgICB8IHRyZWVHcmlkRmlsdGVyaW5nOmZpbHRlcmluZ0V4cHJlc3Npb25zVHJlZTpmaWx0ZXJTdHJhdGVneTphZHZhbmNlZEZpbHRlcmluZ0V4cHJlc3Npb25zVHJlZTpwaXBlVHJpZ2dlcjpmaWx0ZXJpbmdQaXBlVHJpZ2dlclxuICAgICAgICB8IHRyZWVHcmlkU29ydGluZzpzb3J0aW5nRXhwcmVzc2lvbnM6dHJlZUdyb3VwQXJlYT8uZXhwcmVzc2lvbnM6c29ydFN0cmF0ZWd5OnBpcGVUcmlnZ2VyXG4gICAgICAgIHwgdHJlZUdyaWRGbGF0dGVuaW5nOmV4cGFuc2lvbkRlcHRoOmV4cGFuc2lvblN0YXRlczpwaXBlVHJpZ2dlclxuICAgICAgICB8IHRyZWVHcmlkUGFnaW5nOnBhZ2luYXRvcj8ucGFnZTpwYWdpbmF0b3I/LnBlclBhZ2U6cGlwZVRyaWdnZXJcbiAgICAgICAgfCB0cmVlR3JpZFN1bW1hcnk6aGFzU3VtbWFyaXplZENvbHVtbnM6c3VtbWFyeUNhbGN1bGF0aW9uTW9kZTpzdW1tYXJ5UG9zaXRpb246c2hvd1N1bW1hcnlPbkNvbGxhcHNlOnBpcGVUcmlnZ2VyOnN1bW1hcnlQaXBlVHJpZ2dlclxuICAgICAgICB8IHRyZWVHcmlkQWRkUm93OmZhbHNlOnBpcGVUcmlnZ2VyXG4gICAgICAgIHwgZ3JpZFJvd1Bpbm5pbmc6aWQ6ZmFsc2U6cGlwZVRyaWdnZXJcIlxuICAgICAgICAgICAgbGV0LXJvd0luZGV4PVwiaW5kZXhcIiBbaWd4Rm9yU2Nyb2xsT3JpZW50YXRpb25dPVwiJ3ZlcnRpY2FsJ1wiIFtpZ3hGb3JTY3JvbGxDb250YWluZXJdPSd2ZXJ0aWNhbFNjcm9sbCdcbiAgICAgICAgICAgIFtpZ3hGb3JDb250YWluZXJTaXplXT0nY2FsY0hlaWdodCcgW2lneEZvckl0ZW1TaXplXT1cInJlbmRlcmVkUm93SGVpZ2h0XCIgI3ZlcnRpY2FsU2Nyb2xsQ29udGFpbmVyXG4gICAgICAgICAgICAoZGF0YUNoYW5naW5nKT1cImRhdGFSZWJpbmRpbmcoJGV2ZW50KVwiIChkYXRhQ2hhbmdlZCk9XCJkYXRhUmVib3VuZCgkZXZlbnQpXCI+XG4gICAgICAgICAgICA8bmctdGVtcGxhdGUgW2lneFRlbXBsYXRlT3V0bGV0XT0naXNTdW1tYXJ5Um93KHJvd0RhdGEpID8gc3VtbWFyeV90ZW1wbGF0ZSA6IHJlY29yZF90ZW1wbGF0ZSdcbiAgICAgICAgICAgICAgICBbaWd4VGVtcGxhdGVPdXRsZXRDb250ZXh0XT0nZ2V0Q29udGV4dChyb3dEYXRhLCByb3dJbmRleCwgZmFsc2UpJ1xuICAgICAgICAgICAgICAgIChjYWNoZWRWaWV3TG9hZGVkKT0nY2FjaGVkVmlld0xvYWRlZCgkZXZlbnQpJz5cbiAgICAgICAgICAgIDwvbmctdGVtcGxhdGU+XG4gICAgICAgIDwvbmctdGVtcGxhdGU+XG4gICAgICAgIDxuZy1jb250YWluZXIgKm5nVGVtcGxhdGVPdXRsZXQ9XCJoYXNQaW5uZWRSZWNvcmRzICYmICFpc1Jvd1Bpbm5pbmdUb1RvcCA/IHBpbm5lZFJlY29yZHNUZW1wbGF0ZSA6IG51bGxcIj48L25nLWNvbnRhaW5lcj5cbiAgICAgICAgPG5nLXRlbXBsYXRlICNyZWNvcmRfdGVtcGxhdGUgbGV0LXJvd0luZGV4PVwiaW5kZXhcIiBsZXQtZGlzYWJsZWRSb3c9XCJkaXNhYmxlZFwiIGxldC1yb3dEYXRhPlxuICAgICAgICAgICAgPGlneC10cmVlLWdyaWQtcm93IFtncmlkSURdPVwiaWRcIiBbaW5kZXhdPVwicm93SW5kZXhcIiBbdHJlZVJvd109XCJyb3dEYXRhXCIgW2Rpc2FibGVkXT1cImRpc2FibGVkUm93XCJcbiAgICAgICAgICAgICAgICBbbmdDbGFzc109XCJyb3dDbGFzc2VzIHwgaWd4R3JpZFJvd0NsYXNzZXM6cm93OnJvdy5pbkVkaXRNb2RlOnJvdy5zZWxlY3RlZDpyb3cuZGlydHk6cm93LmRlbGV0ZWQ6cm93LmRyYWdnaW5nOnJvd0luZGV4Omhhc0NvbHVtbkxheW91dHM6cm93LnRyZWVSb3cuaXNGaWx0ZXJlZE91dFBhcmVudDpyb3dEYXRhOnBpcGVUcmlnZ2VyXCJcbiAgICAgICAgICAgICAgICBbbmdTdHlsZV09XCJyb3dTdHlsZXMgfCBpZ3hHcmlkUm93U3R5bGVzOnJvd0RhdGE6cm93SW5kZXg6cGlwZVRyaWdnZXJcIiAjcm93PlxuICAgICAgICAgICAgPC9pZ3gtdHJlZS1ncmlkLXJvdz5cbiAgICAgICAgPC9uZy10ZW1wbGF0ZT5cbiAgICAgICAgPG5nLXRlbXBsYXRlICNwaW5uZWRfcmVjb3JkX3RlbXBsYXRlIGxldC1yb3dJbmRleD1cImluZGV4XCIgbGV0LXJvd0RhdGE+XG4gICAgICAgICAgICA8aWd4LXRyZWUtZ3JpZC1yb3cgW2dyaWRJRF09XCJpZFwiIFtpbmRleF09XCJyb3dJbmRleFwiIFt0cmVlUm93XT1cInJvd0RhdGFcIlxuICAgICAgICAgICAgICAgIFtuZ0NsYXNzXT1cInJvd0NsYXNzZXMgfCBpZ3hHcmlkUm93Q2xhc3Nlczpyb3c6cm93LmluRWRpdE1vZGU6cm93LnNlbGVjdGVkOnJvdy5kaXJ0eTpyb3cuZGVsZXRlZDpyb3cuZHJhZ2dpbmc6cm93SW5kZXg6aGFzQ29sdW1uTGF5b3V0czpyb3cudHJlZVJvdy5pc0ZpbHRlcmVkT3V0UGFyZW50OnJvd0RhdGE6cGlwZVRyaWdnZXJcIlxuICAgICAgICAgICAgICAgIFtuZ1N0eWxlXT1cInJvd1N0eWxlcyB8IGlneEdyaWRSb3dTdHlsZXM6cm93RGF0YTpyb3dJbmRleDpwaXBlVHJpZ2dlclwiI3JvdyAjcGlubmVkUm93PlxuICAgICAgICAgICAgPC9pZ3gtdHJlZS1ncmlkLXJvdz5cbiAgICAgICAgPC9uZy10ZW1wbGF0ZT5cbiAgICAgICAgPG5nLXRlbXBsYXRlICNzdW1tYXJ5X3RlbXBsYXRlIGxldC1yb3dJbmRleD1cImluZGV4XCIgbGV0LXJvd0RhdGE+XG4gICAgICAgICAgICA8aWd4LWdyaWQtc3VtbWFyeS1yb3cgW2dyaWRJRF09XCJpZFwiIFtzdW1tYXJpZXNdPVwicm93RGF0YS5zdW1tYXJpZXNcIlxuICAgICAgICAgICAgICAgIFtmaXJzdENlbGxJbmRlbnRhdGlvbl09XCJyb3dEYXRhLmNlbGxJbmRlbnRhdGlvblwiIFtpbmRleF09XCJyb3dJbmRleFwiXG4gICAgICAgICAgICAgICAgY2xhc3M9XCJpZ3gtZ3JpZF9fc3VtbWFyaWVzLS1ib2R5XCIgcm9sZT1cInJvd1wiICNzdW1tYXJ5Um93PlxuICAgICAgICAgICAgPC9pZ3gtZ3JpZC1zdW1tYXJ5LXJvdz5cbiAgICAgICAgPC9uZy10ZW1wbGF0ZT5cbiAgICAgICAgPG5nLWNvbnRhaW5lciAqbmdUZW1wbGF0ZU91dGxldD1cInRlbXBsYXRlXCI+PC9uZy1jb250YWluZXI+XG4gICAgICAgIDxkaXYgY2xhc3M9XCJpZ3gtZ3JpZF9fcm93LWVkaXRpbmctb3V0bGV0XCIgaWd4T3ZlcmxheU91dGxldCAjaWd4Um93RWRpdGluZ092ZXJsYXlPdXRsZXQ+PC9kaXY+XG4gICAgICAgIDxpZ2MtdHJpYWwtd2F0ZXJtYXJrPjwvaWdjLXRyaWFsLXdhdGVybWFyaz5cbiAgICA8L2Rpdj5cbiAgICA8ZGl2IGlneFRvZ2dsZSAjbG9hZGluZ092ZXJsYXk+XG4gICAgICAgIDxpZ3gtY2lyY3VsYXItYmFyIFtpbmRldGVybWluYXRlXT1cInRydWVcIiAqbmdJZj0nc2hvdWxkT3ZlcmxheUxvYWRpbmcnPlxuICAgICAgICA8L2lneC1jaXJjdWxhci1iYXI+XG4gICAgPC9kaXY+XG4gICAgPHNwYW4gKm5nSWY9XCJtb3ZpbmcgJiYgY29sdW1uSW5EcmFnXCIgW2lneENvbHVtbk1vdmluZ0Ryb3BdPVwiaGVhZGVyQ29udGFpbmVyXCIgW2F0dHIuZHJvcHBhYmxlXT1cInRydWVcIlxuICAgICAgICBpZD1cInJpZ2h0XCIgY2xhc3M9XCJpZ3gtZ3JpZF9fc2Nyb2xsLW9uLWRyYWctcmlnaHRcIj48L3NwYW4+XG4gICAgICAgIDxkaXYgW2hpZGRlbl09JyFoYXNWZXJ0aWNhbFNjcm9sbCgpJyBjbGFzcz1cImlneC1ncmlkX190Ym9keS1zY3JvbGxiYXJcIiBbc3R5bGUud2lkdGgucHhdPVwic2Nyb2xsU2l6ZVwiICAocG9pbnRlcmRvd24pPVwiJGV2ZW50LnByZXZlbnREZWZhdWx0KClcIlxuICAgICAgICAgICAgW3N0eWxlLmhlaWdodC5weF09J2NhbGNIZWlnaHQnPlxuICAgICAgICA8ZGl2IGNsYXNzPVwiaWd4LWdyaWRfX3Rib2R5LXNjcm9sbGJhci1zdGFydFwiIFtzdHlsZS5oZWlnaHQucHhdPScgaXNSb3dQaW5uaW5nVG9Ub3AgPyBwaW5uZWRSb3dIZWlnaHQgOiAwJz48L2Rpdj5cbiAgICAgICAgPGRpdiBjbGFzcz1cImlneC1ncmlkX190Ym9keS1zY3JvbGxiYXItbWFpblwiIFtzdHlsZS5oZWlnaHQucHhdPSdjYWxjSGVpZ2h0Jz5cbiAgICAgICAgICAgIDxuZy10ZW1wbGF0ZSBpZ3hHcmlkRm9yIFtpZ3hHcmlkRm9yT2ZdPSdbXScgI3ZlcnRpY2FsU2Nyb2xsSG9sZGVyPjwvbmctdGVtcGxhdGU+XG4gICAgICAgIDwvZGl2PlxuICAgICAgICA8ZGl2IGNsYXNzPVwiaWd4LWdyaWRfX3Rib2R5LXNjcm9sbGJhci1lbmRcIiBbc3R5bGUuaGVpZ2h0LnB4XT0nIWlzUm93UGlubmluZ1RvVG9wID8gcGlubmVkUm93SGVpZ2h0IDogMCc+PC9kaXY+XG4gICAgPC9kaXY+XG4gICAgPGRpdiBjbGFzcz1cImlneC1ncmlkX19hZGRyb3ctc25hY2tiYXJcIj5cbiAgICAgICAgPGlneC1zbmFja2JhciAjYWRkUm93U25hY2tiYXIgW291dGxldF09XCJpZ3hCb2R5T3ZlcmxheU91dGxldFwiIFthY3Rpb25UZXh0XT1cInJlc291cmNlU3RyaW5ncy5pZ3hfZ3JpZF9zbmFja2Jhcl9hZGRyb3dfYWN0aW9udGV4dFwiIFtkaXNwbGF5VGltZV09J3NuYWNrYmFyRGlzcGxheVRpbWUnPnt7cmVzb3VyY2VTdHJpbmdzLmlneF9ncmlkX3NuYWNrYmFyX2FkZHJvd19sYWJlbH19PC9pZ3gtc25hY2tiYXI+XG4gICAgPC9kaXY+XG5cbiAgICA8ZGl2IGlneE92ZXJsYXlPdXRsZXQgI2lneEJvZHlPdmVybGF5T3V0bGV0PVwib3ZlcmxheS1vdXRsZXRcIj48L2Rpdj5cbjwvZGl2PlxuXG48ZGl2IGNsYXNzPVwiaWd4LWdyaWRfX3Rmb290XCIgcm9sZT1cInJvd2dyb3VwXCIgW3N0eWxlLmhlaWdodC5weF09J3N1bW1hcnlSb3dIZWlnaHQnICN0Zm9vdD5cbiAgICA8ZGl2IHRhYmluZGV4PVwiMFwiIChmb2N1cyk9XCJuYXZpZ2F0aW9uLmZvY3VzRmlyc3RDZWxsKGZhbHNlKVwiXG4gICAgKGtleWRvd24pPVwibmF2aWdhdGlvbi5zdW1tYXJ5TmF2KCRldmVudClcIiBbYXR0ci5hcmlhLWFjdGl2ZWRlc2NlbmRhbnRdPVwiYWN0aXZlRGVzY2VuZGFudFwiPlxuICAgICAgICA8aWd4LWdyaWQtc3VtbWFyeS1yb3cgW3N0eWxlLndpZHRoLnB4XT0nY2FsY1dpZHRoJyBbc3R5bGUuaGVpZ2h0LnB4XT0nc3VtbWFyeVJvd0hlaWdodCdcbiAgICAgICAgICAgICpuZ0lmPVwiaGFzU3VtbWFyaXplZENvbHVtbnMgJiYgcm9vdFN1bW1hcmllc0VuYWJsZWRcIiBbZ3JpZElEXT1cImlkXCIgcm9sZT1cInJvd1wiXG4gICAgICAgICAgICBbc3VtbWFyaWVzXT1cImlkIHwgaWd4R3JpZFN1bW1hcnlEYXRhUGlwZTpzdW1tYXJ5U2VydmljZS5yZXRyaWdnZXJSb290UGlwZVwiIFtpbmRleF09XCJkYXRhVmlldy5sZW5ndGhcIlxuICAgICAgICAgICAgY2xhc3M9XCJpZ3gtZ3JpZF9fc3VtbWFyaWVzXCIgI3N1bW1hcnlSb3c+XG4gICAgICAgIDwvaWd4LWdyaWQtc3VtbWFyeS1yb3c+XG4gICAgICAgIDxkaXYgY2xhc3M9XCJpZ3gtZ3JpZF9fdGZvb3QtdGh1bWJcIiBbaGlkZGVuXT0nIWhhc1ZlcnRpY2FsU2Nyb2xsKCknIFtzdHlsZS5oZWlnaHQucHhdPSdzdW1tYXJ5Um93SGVpZ2h0J1xuICAgICAgICAgICAgW3N0eWxlLndpZHRoLnB4XT1cInNjcm9sbFNpemVcIj48L2Rpdj5cbiAgICA8L2Rpdj5cbjwvZGl2PlxuXG48ZGl2IGNsYXNzPVwiaWd4LWdyaWRfX3Njcm9sbFwiIFtzdHlsZS5oZWlnaHQucHhdPVwic2Nyb2xsU2l6ZVwiICNzY3IgW2hpZGRlbl09XCJpc0hvcml6b250YWxTY3JvbGxIaWRkZW5cIiAocG9pbnRlcmRvd24pPVwiJGV2ZW50LnByZXZlbnREZWZhdWx0KClcIj5cbiAgICA8ZGl2IGNsYXNzPVwiaWd4LWdyaWRfX3Njcm9sbC1zdGFydFwiIFtzdHlsZS53aWR0aC5weF09J2lzUGlubmluZ1RvU3RhcnQgPyBwaW5uZWRXaWR0aCA6IGhlYWRlckZlYXR1cmVzV2lkdGgnIFtzdHlsZS5taW4td2lkdGgucHhdPSdpc1Bpbm5pbmdUb1N0YXJ0ID8gcGlubmVkV2lkdGggOiBoZWFkZXJGZWF0dXJlc1dpZHRoJz48L2Rpdj5cbiAgICA8ZGl2IGNsYXNzPVwiaWd4LWdyaWRfX3Njcm9sbC1tYWluXCIgW3N0eWxlLndpZHRoLnB4XT0ndW5waW5uZWRXaWR0aCc+XG4gICAgICAgIDxuZy10ZW1wbGF0ZSBpZ3hHcmlkRm9yIFtpZ3hHcmlkRm9yT2ZdPSdbXScgI3Njcm9sbENvbnRhaW5lcj5cbiAgICAgICAgPC9uZy10ZW1wbGF0ZT5cbiAgICA8L2Rpdj5cbiAgICA8ZGl2IGNsYXNzPVwiaWd4LWdyaWRfX3Njcm9sbC1lbmRcIiBbc3R5bGUuZmxvYXRdPSdcInJpZ2h0XCInIFtzdHlsZS53aWR0aC5weF09J3Bpbm5lZFdpZHRoJyBbc3R5bGUubWluLXdpZHRoLnB4XT0ncGlubmVkV2lkdGgnIFtoaWRkZW5dPVwicGlubmVkV2lkdGggPT09IDAgfHwgaXNQaW5uaW5nVG9TdGFydFwiPjwvZGl2PlxuPC9kaXY+XG5cbjxkaXYgY2xhc3M9XCJpZ3gtZ3JpZF9fZm9vdGVyXCIgI2Zvb3Rlcj5cbiAgICA8bmctY29udGVudCBzZWxlY3Q9XCJpZ3gtZ3JpZC1mb290ZXJcIj48L25nLWNvbnRlbnQ+XG4gICAgPG5nLWNvbnRhaW5lciAqbmdJZj1cInRvdGFsUmVjb3JkcyB8fCBwYWdpbmdNb2RlID09PSAxXCI+XG4gICAgICAgIDxuZy1jb250ZW50IHNlbGVjdD1cImlneC1wYWdpbmF0b3JcIj48L25nLWNvbnRlbnQ+XG4gICAgPC9uZy1jb250YWluZXI+XG48L2Rpdj5cblxuPG5nLXRlbXBsYXRlICNlbXB0eUZpbHRlcmVkR3JpZD5cbiAgICA8c3BhbiBjbGFzcz1cImlneC1ncmlkX190Ym9keS1tZXNzYWdlXCIgcm9sZT1cImNlbGxcIj5cbiAgICAgICAgPHNwYW4+e3tlbXB0eUZpbHRlcmVkR3JpZE1lc3NhZ2V9fTwvc3Bhbj5cbiAgICAgICAgPHNwYW4gKm5nSWY9J3Nob3dBZGRCdXR0b24nPlxuICAgICAgICAgICAgPG5nLWNvbnRhaW5lciAqbmdUZW1wbGF0ZU91dGxldD0nYWRkUm93RW1wdHlUZW1wbGF0ZSB8fCBkZWZhdWx0QWRkUm93RW1wdHlUZW1wbGF0ZSc+PC9uZy1jb250YWluZXI+XG4gICAgICAgIDwvc3Bhbj5cbiAgICA8L3NwYW4+XG48L25nLXRlbXBsYXRlPlxuXG48bmctdGVtcGxhdGUgI2RlZmF1bHRFbXB0eUdyaWQ+XG4gICAgPHNwYW4gY2xhc3M9XCJpZ3gtZ3JpZF9fdGJvZHktbWVzc2FnZVwiIHJvbGU9XCJjZWxsXCI+XG4gICAgICAgIDxzcGFuPnt7ZW1wdHlHcmlkTWVzc2FnZX19PC9zcGFuPlxuICAgICAgICA8c3BhbiAqbmdJZj0nc2hvd0FkZEJ1dHRvbic+XG4gICAgICAgICAgICA8bmctY29udGFpbmVyICpuZ1RlbXBsYXRlT3V0bGV0PSdhZGRSb3dFbXB0eVRlbXBsYXRlIHx8IGRlZmF1bHRBZGRSb3dFbXB0eVRlbXBsYXRlJz48L25nLWNvbnRhaW5lcj5cbiAgICAgICAgPC9zcGFuPlxuICAgIDwvc3Bhbj5cbjwvbmctdGVtcGxhdGU+XG5cbjxuZy10ZW1wbGF0ZSAjZGVmYXVsdEFkZFJvd0VtcHR5VGVtcGxhdGU+XG4gICAgPGJ1dHRvbiBpZ3hCdXR0b249XCJyYWlzZWRcIiBpZ3hSaXBwbGUgKGNsaWNrKT1cInRoaXMuY3J1ZFNlcnZpY2UuZW50ZXJBZGRSb3dNb2RlKG51bGwsIGZhbHNlLCAkZXZlbnQpXCI+XG4gICAgICAgIHt7cmVzb3VyY2VTdHJpbmdzLmlneF9ncmlkX2FkZF9yb3dfbGFiZWx9fVxuICAgIDwvYnV0dG9uPlxuPC9uZy10ZW1wbGF0ZT5cblxuPG5nLXRlbXBsYXRlICNkZWZhdWx0TG9hZGluZ0dyaWQ+XG4gICAgPGRpdiBjbGFzcz1cImlneC1ncmlkX19sb2FkaW5nXCI+XG4gICAgICAgIDxpZ3gtY2lyY3VsYXItYmFyIFtpbmRldGVybWluYXRlXT1cInRydWVcIj5cbiAgICAgICAgPC9pZ3gtY2lyY3VsYXItYmFyPlxuICAgIDwvZGl2PlxuPC9uZy10ZW1wbGF0ZT5cblxuPGRpdiAqbmdJZj1cInJvd0VkaXRhYmxlXCIgaWd4VG9nZ2xlICNyb3dFZGl0aW5nT3ZlcmxheT5cbiAgICA8ZGl2IFtjbGFzc05hbWVdPVwiYmFubmVyQ2xhc3NcIj5cbiAgICAgICAgPG5nLWNvbnRhaW5lclxuICAgICAgICAgICAgKm5nVGVtcGxhdGVPdXRsZXQ9XCJyb3dFZGl0Q29udGFpbmVyOyBjb250ZXh0OiB7IHJvd0NoYW5nZXNDb3VudDogcm93Q2hhbmdlc0NvdW50LCBlbmRFZGl0OiB0aGlzLmNydWRTZXJ2aWNlLmVuZEVkaXQuYmluZCh0aGlzKSB9XCI+XG4gICAgICAgIDwvbmctY29udGFpbmVyPlxuICAgIDwvZGl2PlxuPC9kaXY+XG5cbjxuZy10ZW1wbGF0ZSAjZGVmYXVsdFJvd0VkaXRUZXh0PlxuICAgIFlvdSBoYXZlIHt7IHJvd0NoYW5nZXNDb3VudCB9fSBjaGFuZ2VzIGluIHRoaXMgcm93XG48L25nLXRlbXBsYXRlPlxuXG48bmctdGVtcGxhdGUgI2RlZmF1bHRSb3dFZGl0QWN0aW9ucz5cbiAgICA8YnV0dG9uIGlneEJ1dHRvbiBpZ3hSb3dFZGl0VGFiU3RvcCAoY2xpY2spPVwidGhpcy5lbmRSb3dFZGl0VGFiU3RvcChmYWxzZSwgJGV2ZW50KVwiPnt7IHRoaXMucmVzb3VyY2VTdHJpbmdzLmlneF9ncmlkX3Jvd19lZGl0X2J0bl9jYW5jZWwgfX08L2J1dHRvbj5cbiAgICA8YnV0dG9uIGlneEJ1dHRvbiBpZ3hSb3dFZGl0VGFiU3RvcCAoY2xpY2spPVwidGhpcy5lbmRSb3dFZGl0VGFiU3RvcCh0cnVlLCAkZXZlbnQpXCI+e3sgdGhpcy5yZXNvdXJjZVN0cmluZ3MuaWd4X2dyaWRfcm93X2VkaXRfYnRuX2RvbmUgfX08L2J1dHRvbj5cbjwvbmctdGVtcGxhdGU+XG5cbjxuZy10ZW1wbGF0ZSAjZGVmYXVsdFJvd0VkaXRUZW1wbGF0ZT5cbiAgICA8ZGl2IGNsYXNzPVwiaWd4LWJhbm5lcl9fbWVzc2FnZVwiPlxuICAgICAgICA8c3BhbiBjbGFzcz1cImlneC1iYW5uZXJfX3RleHRcIj5cbiAgICAgICAgICAgIDxuZy1jb250YWluZXJcbiAgICAgICAgICAgICAgICAqbmdUZW1wbGF0ZU91dGxldD1cInRoaXMuY3J1ZFNlcnZpY2Uucm93Py5nZXRDbGFzc05hbWUoKSA9PT0gJ0lneEFkZFJvdycgPyByb3dBZGRUZXh0IDogcm93RWRpdFRleHQgPyByb3dFZGl0VGV4dCA6IGRlZmF1bHRSb3dFZGl0VGV4dDtcbiAgICAgICAgICAgICAgICBjb250ZXh0OiB7ICRpbXBsaWNpdDogdGhpcy5jcnVkU2VydmljZS5yb3c/LmdldENsYXNzTmFtZSgpICE9PSAnSWd4QWRkUm93JyA/IHJvd0NoYW5nZXNDb3VudCA6IG51bGwgfVwiPlxuICAgICAgICAgICAgPC9uZy1jb250YWluZXI+XG4gICAgICAgIDwvc3Bhbj5cbiAgICA8L2Rpdj5cbiAgICA8ZGl2IGNsYXNzPVwiaWd4LWJhbm5lcl9fYWN0aW9uc1wiPlxuICAgICAgICA8ZGl2IGNsYXNzPVwiaWd4LWJhbm5lcl9fcm93XCI+XG4gICAgICAgICAgICA8bmctY29udGFpbmVyXG4gICAgICAgICAgICAgICAgKm5nVGVtcGxhdGVPdXRsZXQ9XCJyb3dFZGl0QWN0aW9ucyA/IHJvd0VkaXRBY3Rpb25zIDogZGVmYXVsdFJvd0VkaXRBY3Rpb25zOyBjb250ZXh0OiB7ICRpbXBsaWNpdDogdGhpcy5lbmRFZGl0LmJpbmQodGhpcykgfVwiPlxuICAgICAgICAgICAgPC9uZy1jb250YWluZXI+XG4gICAgICAgIDwvZGl2PlxuICAgIDwvZGl2PlxuPC9uZy10ZW1wbGF0ZT5cblxuPG5nLXRlbXBsYXRlICNkcmFnSW5kaWNhdG9ySWNvbkJhc2U+XG4gICAgPGlneC1pY29uPmRyYWdfaW5kaWNhdG9yPC9pZ3gtaWNvbj5cbjwvbmctdGVtcGxhdGU+XG5cbjxpZ3gtZ3JpZC1jb2x1bW4tcmVzaXplciAqbmdJZj1cImNvbFJlc2l6aW5nU2VydmljZS5zaG93UmVzaXplclwiPjwvaWd4LWdyaWQtY29sdW1uLXJlc2l6ZXI+XG48ZGl2IGNsYXNzPVwiaWd4LWdyaWRfX2xvYWRpbmctb3V0bGV0XCIgI2lneExvYWRpbmdPdmVybGF5T3V0bGV0IGlneE92ZXJsYXlPdXRsZXQ+PC9kaXY+XG48ZGl2IGNsYXNzPVwiaWd4LWdyaWRfX291dGxldFwiICNpZ3hGaWx0ZXJpbmdPdmVybGF5T3V0bGV0IGlneE92ZXJsYXlPdXRsZXQ+PC9kaXY+XG4iXX0=